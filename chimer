#!/usr/bin/perl
# vi:set sw=2 ai sm:
#

# see https://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default for these crazy hacks
# THERE ARE MORE CRAZY HACKS THERE FOR MORE COMPLEX PROJECTS!!
use v5.12; # minimal for unicode string feature
use v5.14; # //u modifier
use utf8;
use open qw( :encoding(UTF-8) :std );
use charnames qw( :full :short );
use feature "unicode_strings";

use warnings qw( FATAL utf8 );
use Encode qw( encode decode );
#@ARGV = map { decode("UTF-8", $_) } @ARGV if grep /\P{ASCII}/ => @ARGV;


use strict;
use integer;

use POSIX;
use DateTime;
use Time::HiRes; # overrides (qw) do not seem to work

use Data::Dumper;

use vars qw( $use_datetime_event_sunrise );
use vars qw( $use_datetime_astro_sunrise );
use vars qw( $use_astro_sunrise );
BEGIN {
  if (eval { require DateTime::Event::Sunrise; }) {
    $use_datetime_event_sunrise = 1;
  } elsif (eval { require DateTime::Astro::Sunrise; }) {
    $use_datetime_astro_sunrise = 1;
  } elsif (eval { require Astro::Sunrise; }) {
    $use_astro_sunrise = 1;
  } else {
    die "Cannot find a usable Sunrise package";
  }
}

use Getopt::Long;
use Data::Dumper;

use vars qw( $fake );
use vars qw( $debug );
use vars qw( $enable_seconds );
use vars qw( $enable_nonproportional_watches );
use vars qw( $enable_qing_quarters );
use vars qw( $enable_chinese );
use vars qw( $enable_hebcal );
use vars qw( $enable_planetary $planetary_omit_details );
use vars qw( $enable_chinese $lang );
use vars qw( $enable_decaminutes $enable_minutes );
use vars qw( $enable_4th_hebrew_watch );
use vars qw( $decimals );
use vars qw( $sysline_mode );
use vars qw( $genmon_mode );
$enable_chinese = 1;
$enable_hebcal = 1;
$decimals = 2;
$lang = 'en';


use vars qw( $coords );

use vars qw( $representation );
$representation = 'name';

use vars qw( $lat $lon );

use vars qw( $em $_em $b $_b $i $_i $u $_u );
($b, $_b) = ('<span weight="900">', '</span>');
($i, $_i) = ('<i>', '</i>');
($u, $_u) = ('<u>', '</u>');
($em, $_em) = ($i, $_i);

use vars qw( @planets );
@planets = (
  {
    'name' => {'zh' => 'æ—¥', 'en' => 'Sun'},
    'icon' => 'â˜‰',
    'article' => {'en' => 'the'},
  },
  {
    'name' => {'zh' => 'æœˆ', 'en' => 'Moon'},
    'icon' => 'â˜½',
    'article' => {'en' => 'the'},
  },
  {
    'name' => {'zh' => 'ç«', 'en' => 'Mars'},
    'icon' => 'â™‚',
  },
  {
    'name' => {'zh' => 'æ°´', 'en' => 'Mercury'},
    'icon' => 'â˜¿',
  },
  {
    'name' => {'zh' => 'æœ¨', 'en' => 'Jupiter'},
    'icon' => 'â™ƒ',
  },
  {
    'name' => {'zh' => 'é‡‘', 'en' => 'Venus'},
    'icon' => 'â™€',
  },
  {
    'name' => {'zh' => 'åœŸ', 'en' => 'Saturn'},
    'icon' => 'â™„',
  },
);

use vars qw( @stems @branches );
@stems = (
  {
    'zh' => 'ç”²',
    'en' => 'Jia',
    'yue@latn' => 'Ë‰gap',
  },
  {
    'zh' => 'ä¹™',
    'en' => 'Yi',
    'yue@latn' => 'Ëjyt',
  },
  {
    'zh' => 'ä¸™',
    'en' => 'Bing',
    'yue@latn' => 'ËŠbiÅ‹',
  },
  {
    'zh' => 'ä¸',
    'en' => 'Ding',
    'yue@latn' => 'ËˆdiÅ‹',
  },
  {
    'zh' => 'æˆŠ',
    'en' => 'Wu',
    'yue@latn' => 'Ëmou',
  },
  {
    'zh' => 'å·±',
    'en' => 'Ji',
    'yue@latn' => 'ËŠgei',
  },
  {
    'zh' => 'åºš',
    'en' => 'Geng',
    'yue@latn' => 'ËˆgÉÅ‹',
  },
  {
    'zh' => 'è¾›',
    'en' => 'Xin',
    'yue@latn' => 'ËˆsÉn',
  },
  {
    'zh' => 'å£¬',
    'en' => 'Ren',
    'yue@latn' => 'ËŒjÉm',
  },
  {
    'zh' => 'ç™¸',
    'en' => 'Gui',
    'yue@latn' => 'Ë‰gwÉi',
  },
);
# Note that apparently the hours have names in the Han dynasty
# Cf. http://www.oldkids.cn/group/post_detail.php?did=669531
@branches = (
  {
    'zh' => 'å­',
    'en' => 'Zi',
    'yue@latn' => 'ËŠdzi',
    'name' => {'zh' => 'é¼ ', 'en' => 'Mouse'},
    'icon' => 'ðŸ',
    'han_hour' => 'å¤œåŠ',
  },
  {
    # feminine year
    'zh' => 'ä¸‘',
    'en' => 'Chou',
    'yue@latn' => 'ËŠtsÉu',
    'name' => {'zh' => 'ç‰›', 'en' => 'Cow'},
    'icon' => 'ðŸ„',
    'han_hour' => 'é›žé³´',
  },
  {
    'zh' => 'å¯…',
    'en' => 'Yin',
    'yue@latn' => 'ËŒjÉn',
    'name' => {'zh' => 'è™Ž', 'en' => 'Tiger'},
    'icon' => 'ðŸ…',
    'han_hour' => 'å¹³æ—¦',
  },
  {
    # feminine year
    'zh' => 'å¯',
    'en' => 'Mao',
    'yue@latn' => 'ËmÉu',
    'name' => {'zh' => 'å…”', 'en' => 'Rabbit'},
    'icon' => 'ðŸ‡',
    'han_hour' => 'æ—¥å‡º',
  },
  {
    'zh' => 'è¾°',
    'en' => 'Chen',
    'yue@latn' => 'ËŒsÉn',
    'name' => {'zh' => 'é¾', 'en' => 'Dragon'},
    'icon' => 'ðŸ‰',
    'han_hour' => 'é£Ÿæ™‚',
  },
  {
    # feminine year
    'zh' => 'å·³',
    'en' => 'Si',
    'yue@latn' => 'Ëdzi',
    'name' => {'zh' => 'è›‡', 'en' => 'Snake'},
    'icon' => 'ðŸ',
    'han_hour' => 'éš…ä¸­',
  },
  {
    'zh' => 'åˆ',
    'en' => 'Wu',
    'yue@latn' => 'ËÅ‹',
    'name' => {'zh' => 'é¦¬', 'en' => 'Horse'},
    'icon' => 'ðŸŽ',
    'han_hour' => 'æ—¥ä¸­',
  },
  {
    # feminine year
    'zh' => 'æœª',
    'en' => 'Wei',
    'yue@latn' => 'Ëmei',
    'name' => {'zh' => 'ç¾Š', 'en' => 'Sheep'},
    'icon' => 'ðŸ',
    'han_hour' => 'æ—¥æ˜³',
  },
  {
    'zh' => 'ç”³',
    'en' => 'Shen',
    'yue@latn' => 'ËˆsÉn',
    'name' => {'zh' => 'çŒ´', 'en' => 'Monkey'},
    'icon' => 'ðŸ’',
    'han_hour' => 'æ™¡æ™‚',
  },
  {
    # feminine year
    'zh' => 'é…‰',
    'en' => 'You',
    'yue@latn' => 'ËjÉu',
    'name' => {'zh' => 'é›ž', 'en' => 'Chicken'},
    'icon' => 'ðŸ”',
    'han_hour' => 'æ—¥å…¥',
  },
  {
    'zh' => 'æˆŒ',
    'en' => 'Xu',
    'yue@latn' => 'ËˆsÅ“t',
    'name' => {'zh' => 'ç‹—', 'en' => 'Dog'},
    'icon' => 'ðŸ•',
    'han_hour' => 'é»„æ˜',
  },
  {
    # feminine year
    'zh' => 'äº¥',
    'en' => 'Hai',
    'yue@latn' => 'ËhÉ”i',
    'name' => {'zh' => 'è±¬', 'en' => 'Pig'},
    'icon' => 'ðŸ–',
    'han_hour' => 'äººå®š',
  },
);

# We don't use the weird "meaningful" names found in https://zh.wikipedia.org/wiki/å¸Œä¼¯ä¾†æ›†
# even though they are short, because first, they're weird and unrecognizable, and also because
# according to the next link the meanings are also wrong.
#
# Note that it's easier to run months starting from Nisan because then Adar II would be just 13
# (cf. http://www.yashanet.com/library/hebrew-days-and-months.html ) but that gets weird if
# the year number increments at Tishrei
#
# Or we could in theory do what some programmers do and make Adar II 8 so in a non-leap year
# after 7 we'd get 9 (cf. https://www.qppstudio.net/webhelp_xv4/jewish-month-numbers.htm )
#
# But in theory Adar I is the leap month, not Adar II, so actually no matter what we do it gets weird
use vars qw( %hebrew_months );
%hebrew_months = (
  'Nisan' => {
    'zh' => 'ä¸ƒ',
    'en' => 'Nisan',
    'xx' => '7',
  },
  'Iyyar' => {
    'zh' => 'å…«',
    'en' => 'Iyyar',
    'xx' => '8',
  },
  'Sivan' => {
    'zh' => 'ä¹',
    'en' => 'Sivan',
    'xx' => '9',
  },
  'Tamuz' => {
    'zh' => 'å',
    'en' => 'Tammuz',
    'xx' => '10',
  },
  'Av' => {
    'zh' => '11',
    'en' => 'Av',
    'xx' => '11',
  },
  'Elul' => {
    'zh' => '12',
    'en' => 'Elul',
    'xx' => '12',
  },
  'Tishrei' => {
    'zh' => 'æ­£',
    'en' => 'Tishrei',
    'xx' => '1',
  },
  'Cheshvan' => {
    'zh' => 'äºŒ',
    'en' => 'Cheshvan',
    'xx' => '2',
  },
  'Kislev' => {
    'zh' => 'ä¸‰',
    'en' => 'Kislev',
    'xx' => '3',
  },
  'Tevet' => {
    'zh' => 'å››',
    'en' => 'Tevet',
    'xx' => '4',
  },
  "Sh'vat" => {
    'zh' => 'äº”',
    'en' => 'Shevat',
    'xx' => '5',
  },
  'Adar I' => {
    'zh' => 'é–å…­',
    'en' => 'Adar I',
    'xx' => '6a',
  },
  'Adar' => {
    'zh' => 'å…­',
    'en' => 'Adar II',
    'xx' => '6b',
  },
);

use vars qw( @solar_terms %solar_terms );
@solar_terms = (
  undef,
  {
    'name' => {
      'en' => 'Vernal Equinox',
      'zh' => 'æ˜¥åˆ†',
    },
  }, {
    'name' => {
      'en' => 'Bright & Clear',
      'zh' => 'æ¸…æ˜Ž',
    },
  }, {
    'name' => {
      'en' => 'Corn Rain',
      'zh' => 'ç©€é›¨',
    },
  }, {
    'name' => {
      'en' => 'Summer Commences',
      'zh' => 'ç«‹å¤',
    },
  }, {
    'name' => {
      'en' => 'Corn Forms',
      'zh' => 'å°æ»¿',
    },
  }, {
    'name' => {
      'en' => 'Corn on Ear',
      'zh' => 'èŠ’ç¨®',
    },
  }, {
    'name' => {
      'en' => 'Summer Solstice',
      'zh' => 'å¤è‡³',
    },
  }, {
    'name' => {
      'en' => 'Moderate Heat',
      'zh' => 'å°æš‘',
    },
  }, {
    'name' => {
      'en' => 'Great Heat',
      'zh' => 'å¤§æš‘',
    },
  }, {
    'name' => {
      'en' => 'Autumn Commences',
      'zh' => 'ç«‹ç§‹',
    },
  }, {
    'name' => {
      'en' => 'End of Heat',
      'zh' => 'è™•æš‘',
    },
  }, {
    'name' => {
      'en' => 'White Dew',
      'zh' => 'ç™½éœ²',
    },
  }, {
    'name' => {
      'en' => 'Autumnal Equinox',
      'zh' => 'ç§‹åˆ†',
    },
  }, {
    'name' => {
      'en' => 'Cold Dew',
      'zh' => 'å¯’éœ²',
    },
  }, {
    'name' => {
      'en' => 'Frost',
      'zh' => 'éœœé™',
    },
  }, {
    'name' => {
      'en' => 'Winter Commences',
      'zh' => 'ç«‹å†¬',
    },
  }, {
    'name' => {
      'en' => 'Light Snow',
      'zh' => 'å°é›ª',
    },
  }, {
    'name' => {
      'en' => 'Heavy Snow',
      'zh' => 'å¤§é›ª',
    },
  }, {
    'name' => {
      'en' => 'Winter Solstice',
      'zh' => 'å†¬è‡³',
    },
  }, {
    'name' => {
      'en' => 'Moderate Cold',
      'zh' => 'å°å¯’',
    },
  }, {
    'name' => {
      'en' => 'Severe Cold',
      'zh' => 'å¤§å¯’',
    },
  }, {
    'name' => {
      'en' => 'Spring Commences',
      'zh' => 'ç«‹æ˜¥',
    },
  }, {
    'name' => {
      'en' => 'Spring Showers',
      'zh' => 'é›¨æ°´',
    },
  }, {
    'name' => {
      'en' => 'Insects Waken',
      'zh' => 'é©šèŸ„',
    },
  }
);
%solar_terms = map { ($solar_terms[$_]->{'name'}->{'en'} => $_) } (1..$#solar_terms);

sub use_chinese () {
  return $lang =~ /^zh\b/i;
}

sub stem_name ($) {
  my($n) = @_;
  my $use_yue_latn = $lang eq 'en';
  my $key = $use_yue_latn? 'yue@latn': $lang;
  return $stems[$n - 1]->{$key};
}

sub branch_name ($) {
  my($n) = @_;
  my $use_yue_latn = $lang eq 'en';
  my $key = $use_yue_latn? 'yue@latn': $lang;
  return $branches[$n - 1]->{$key};
}

sub stem_branch_name ($) {
  my($year) = @_;
  $year -= 1;
  $year %= 60;
  my $use_yue_latn = $lang eq 'en';
  my $key = $use_yue_latn? 'yue@latn': $lang;
  return sprintf('%s%s%s', $stems[$year%10]->{$key}, ((use_chinese || $use_yue_latn)? '': '-'), $branches[$year%12]->{$key});
}

sub get_representation ($;$$) {
  my($s, $specific_representation, $use_article) = @_;
  my $prefix = $use_article && defined $s->{'article'}->{$lang}? sprintf('%s ', $s->{'article'}->{$lang}): '';
  my $base = (defined $specific_representation? $specific_representation: $representation) =~ /^icon/? $s->{'icon'}: $s->{'name'}->{$lang};
  return $prefix . $base;
}

sub start_of_day ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  return mktime(0, 0, 0, $mday, $mon, $year);
}

sub yesterday ($) {
  my($t) = @_;
  return start_of_day(start_of_day($t) - 12*3600);
}

sub tomorrow ($) {
  my($t) = @_;
  return start_of_day(start_of_day($t) + 36*3600);
}

sub estimate_sunrise ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->start;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[0];
    $it = $tmp->strftime('%s');
  } else {
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunrise;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub estimate_sunset ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->end;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[1];
    $it = $tmp->strftime('%s');
  } else {
    # this should be the same as the else case in estimate_sunrise except the last line
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunset;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub trim ($) {
  my($s) = @_;
  $s =~ s/^\s+//;
  $s =~ s/\s+$//;
  return $s;
}

sub ordinal ($) {
  my($n) = @_;
  my $det1 = $n%10;
  my $det2 = int($n/10)%10;
  return sprintf '%d%s', $n, ($det2 == 1? 'th': $det1 == 1? 'st': $det1 == 2? 'nd': $det1 == 3? 'rd': 'th');
}

sub guess_city () {
  my $input = '/etc/localtime';
  my $det = readlink $input;
  die "$input: $!\n" unless defined $det;
  return $1 if $det =~ /([^\/]+)$/s;
}

sub guess_coordinates () {
  my $it;
  my $city = guess_city;
  print STDERR "guessed city=($city)\n" if $debug;
  my @cmd = qw(hebcal cities);
  print STDERR 'DEBUG: running: ', join(' ', @cmd), "\n" if $debug;
  my $pid = open(INPUT, '-|');
  die "$0: guess_coordinates: $cmd[0]: fork: $!\n" unless defined $pid;
  if ($pid) {
    my $re = quotemeta $city;
    for (;;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp;
      if ($s =~ /^$re \((\d+)d(\d+)' ([NS]) lat, (\d+)d(\d+)' [EW] long/) {
	no integer;
	$it = {
	      'lat' => ($1 + $2/60)*($3 eq 'N'? 1: -1),
	      'lon' => ($4 + $5/60)*($6 eq 'E'? 1: -1),
	    };
      }
    last if defined $it;
    }
    close INPUT;
  } else {
    exec {$cmd[0]} @cmd;
    die "$0: guess_coordinates: $cmd[0]: exec: $!\n";
  }
  return $it;
}

use vars qw( %chinese_digits );
%chinese_digits = (
  'ä¸€' => 1,
  'äºŒ' => 2,
  'ä¸‰' => 3,
  'å››' => 4,
  'äº”' => 5,
  'å…­' => 6,
  'ä¸ƒ' => 7,
  'å…«' => 8,
  'ä¹' => 9,
  'å' => 10,
  'å»¿' => 20,
  'å…' => 30,
);
sub parse_chinese_number ($) {
  my($s) = @_;
  my($tens, $units) = ($chinese_digits{$1}, $chinese_digits{$2}) if $s =~ /^(\S?)(\S)$/;
  return ($units == 10 && defined $tens)? $tens*10: $tens + $units;
}

sub read_ini ($) {
  my($input) = @_;
  my $it;
  local(*INPUT, $.);
  if (open(INPUT, '<:utf8', $input)) {
    for (my $section;;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp $s;
      if ($s =~ /^\s*(?:[#\%;]|$)/) {
	;
      } elsif ($s =~ /^\s*\[\s*([^\[\]]+?)\s*\]\s*$/) {
	$section = $1;
      } elsif ($s =~ /^\s*([^=]+?)\s*=\s*(.*)/) {
	if (defined $section) {
	  $it->{$section}->{$1} = $2;
	} else {
	  $it->{$1} = $2;
	}
      } else {
	warn "$input:$.: Warning: Unknown input \"$s\"\n";
      }
    }
    close INPUT;
  }
  return $it;
}


# Quarters are weird. See https://zh.wikipedia.org/wiki/%E5%88%BB
#                     and http://yywz.snnu.edu.cn/show.aspx?id=697&cid=26
# Apparently the old Chinese system also used proportional hours... so we'll need to refactor things here at some point
# http://www.twword.com/wiki/%E5%B9%B2%E6%94%AF%E7%B4%80%E6%B3%95
sub determine_chinese_time ($) {
  my($t) = @_;
  my $it;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $midnight = start_of_day $t;
  my $deciday;
  my $slice; # size of proportional hour, needed to figure out when to sound the next chime
  # NOTE: according to one source (forgot which), the first hour (ËŠdzi) spans [2300, 0100) but the new day still starts at 0000. Very odd :-/
  # therefore the old adjustment for [2300, 0000) has been deleted
  if (defined $coords) {
    my $today = start_of_day $t;
    my $yesterday = yesterday $t;
    my $tomorrow = tomorrow $t;
    my($daybreak, $slice_start, $slice_end, $starting_hour);
    # Proportional hour is used in a very early system (Spring and Autumn Period / Warring States),
    # but I don't even have an idea when the day starts (probably day before night) so we'll arbitrarily use sunrise as cutoff
    if ($t < estimate_sunrise($today)) {
      $daybreak = estimate_sunrise($yesterday);
      $slice_start = estimate_sunset($yesterday);
      $slice_end = estimate_sunrise($today);
      $starting_hour = 6;
    } elsif ($t < estimate_sunset($today)) {
      $daybreak = estimate_sunrise($today);
      $slice_start = $daybreak;
      $slice_end = estimate_sunset($today);
      $starting_hour = 1;
    } else {
      $daybreak = estimate_sunrise($today);
      $slice_start = estimate_sunset($today);
      $slice_end = estimate_sunrise($tomorrow);
      $starting_hour = 6;
    }
    if ($slice_start && $slice_end) {
      no integer;
      $slice = ($slice_end - $slice_start)/5;
      $deciday = $starting_hour + ($t - $slice_start)/$slice;
    }
  }
  my($greg_year, $greg_month, $greg_day) = ($year + 1900, $mon + 1, $mday);
  my $relative_chinese_hour = eval { no integer; fmod(($t - ($midnight - 3600))/7200, 12) };
  my $chinese_hour = $relative_chinese_hour + 1;
  my $quarter;
  my $centiday = eval { no integer; ($t - $midnight)/864 };
  if ($enable_qing_quarters) {
    $quarter = $min/15 + 1;
    $quarter += 4 if $hour%2 == 0;
  } else {
    # NOTE: traditionally these aren't quarters, but number of centiday marks past the beginning of the hour
    no integer;
    #
    # 0.5 hours maps exactly to 0 centidays. So to calculate the reporting origin, which is fractional.
    # Each hour is 86400/12 seconds, each centiday is 86400/100 seconds, so each hour is 100/12 centidays
    # In theory, each zero-based hour h begins exactly at âŒŠh - 0.5âŒ‹*100/12 centidays
    # However, when h âˆˆ [0, 0.5) this gives unexpected results because the formula will give a negative result
    # There's no easy way to fix this because reporting origins are hour-aligned, not half-hour aligned
    # (so we can't even change âŒŠh - 0.5âŒ‹ to (âŒŠh*2 - 1âŒ‹%24)/2 because this breaks for h > 1.0)
    #
    my $reporting_origin = POSIX::floor(($relative_chinese_hour < 0.5? 11.5: (int($relative_chinese_hour) - 0.5)) * 100 / 12);
    print STDERR "relative_chinese_hour=$relative_chinese_hour => reporting_origin=$reporting_origin\n" if $debug;
    $quarter = $centiday - int($reporting_origin);
  }
  $it = [undef, undef, undef, undef, $chinese_hour, $quarter, $centiday, $deciday,
      $wday, eval { no integer; $relative_chinese_hour < 0.5 }, $slice];
  return $it;
}

sub determine_events ($$$$$$$$$) {
  my($t0, $hour, $min, $sec, $chinese_hour, $quarter, $centiday, $deciday, $deciday_size) = @_;
  my @it;
  no integer;

  # Western quarter-hour chime
  my $seconds_since_hour_change = 60*$min + $sec;
  my $t_next_quarter_chime = int($t0) + (900 - $seconds_since_hour_change%900);
  my $next_quarter = (int($seconds_since_hour_change / 900) + 1)%4;
  my $next_hour = (($next_quarter? $hour: $hour + 1) + 11)%12 + 1;
  my $prechime_length;
  die "Calculation error, next quarter $t_next_quarter_chime is in the past" if $t_next_quarter_chime < $t0;
  die "Calculation error, next quarter $t_next_quarter_chime more than 15 minutes away" if $t_next_quarter_chime - $t0 > 900;
  if ($next_quarter == 0) {
    push @it, {
      't' => $t_next_quarter_chime,
      'id' => "h$next_hour",
      'type' => 'hour',
      'comment' => "hour $next_hour chime",
    };
    $prechime_length = 25;
  } elsif ($next_quarter == 1) {
    $prechime_length = 5;
  } elsif ($next_quarter == 2) {
    $prechime_length = 10;
  } elsif ($next_quarter == 3) {
    $prechime_length = 15;
  }
  push @it, {
    't' => $t_next_quarter_chime - $prechime_length,
    'id' => "q$next_hour.$next_quarter",
    'type' => 'quarter',
    'comment' => "hour $next_hour quarter $next_quarter prechime",
  };

  # Shang-era proportional-deciday-based night watch chimes
  if ($deciday > 5 && $deciday < 6) { # 5 is the last deciday in the "day" moitie
    my $t_first_watch = $t0 + (6 - $deciday)*$deciday_size;
    push @it, {
      't' => $t_first_watch,
      'id' => 'w1.1',
      'type' => 'watch',
      'comment' => 'watch 1',
    };
  } elsif ($deciday >= 6) {
    my $zero_based_next_watch_number = (int(5*($deciday - 6)) + 1)%25;
    if ($zero_based_next_watch_number) {
      my $next_watch = int($zero_based_next_watch_number/5) + 1;
      my $next_fifth_of_watch = $zero_based_next_watch_number%5 + 1;
      my $t_next_fifth_of_watch = $t0 + fmod($deciday, 0.2)*$deciday_size;
      push @it, {
	't' => $t_next_fifth_of_watch,
	'id' => "w$next_watch.$next_fifth_of_watch",
	'type' => 'watch',
	'comment' => "watch $next_watch.$next_fifth_of_watch",
      };
    }
  }

  @it = sort { $a->{'t'} <=> $b->{'t'} } @it;
  return wantarray? @it: \@it;
}

sub usage (;$) {
  my($st) = @_;
  my $h = $st? *STDERR: *STDOUT;
  print $h <<EOF;
Usage: $0 [OPTION]...
Display date and time information in a non-mainstream calendar.

  -b, --bold                  Show unexpected dates and times in bold
  -d, --decimals=N            Display N decimal places for fractional ancient
                              Chinese centidays (used only when decaminutes
                              are not enabled)
      --disable-chinese       Do not display Chinese date and time
      --disable-hebrew        Do not display Hebrew date and time
  -g, --genmon                Terse format suitable as two-line genmon input
      --iconic                Use zodiac symbols
  -i, --italics               Show unexpected dates and times in italics
  -M, --decaminutes           Enable display of ancient Chinese decaminutes
                              (and disable display of fractional centidays)
  -m, --minutes               Enable display of Western "planetary" minutes (and
                              ancient Chinese minutes if decaminutes are enabled)
      --nonproportional-watches
                              Use watches that are aligned to Chinese hours
  -p, --enable-planetary=all  Enable the Western "planetary" system and display
                              current time in addition to the equivalent zodiac
  -p, --enable-planetary=minimal
                              Enable the Western "planetary" system but display
                              only the zodiac corresponding to the current hour
  -Q, --qing                  Same as --nonproportional-watches --qing-quarters
      --qing-quarters         Use the Qing quarters system (identical to modern
                              quarters) instead of the ancient centiday system
  -s, --seconds               Enable display of Western "planetary" seconds
  -u, --underline             Show unexpected dates and times underlined
  -w, --sysline               Terse format suitable as a sysline .who file
      --what-if=TIME          (FOR DEBUGGING ONLY) Pretend current time is TIME
  -z, --chinese, --kanji      Use kanji instead of English
  -3, --disable-4th-watch     Use 3 watches for Hebrew system. This is the default
  -4, --enable-4th-watch      Use 4 watches for Hebrew system
      --symbolic              Use zodiac names
      --debug                 Produce debugging output

Note that Chinese and Hebrew dates and times are always shown. Western "planetary"
times are shown only when enabled.
EOF
  exit $st;
}

binmode STDIN, ':utf8';
binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';

select((select(STDERR), $| = 1)[0]); # I don't know why this is needed for STDERR

$coords = guess_coordinates unless defined $coords;
($lat, $lon) = ($coords->{'lat'}, $coords->{'lon'}) unless defined $lat;
die "$0: Can't determine coordinates\n" unless defined $coords;

if (!caller) {
  Getopt::Long::config('bundling');
  GetOptions(
    'b|bold' => sub { ($em, $_em) = ($b, $_b); },
    'debug' => sub { $debug += 1; },
    'd|decimals=i' => \$decimals,
    'disable-chinese' => sub { $enable_chinese = 0; },
    'H|disable-hebrew' => sub { $enable_hebcal = 0; },
    'i|italics' => sub { ($em, $_em) = ($i, $_i); },
    'M|enable-decaminutes|decaminutes' => \$enable_decaminutes,
    'm|enable-minutes|minutes' => \$enable_minutes,
    's|enable-seconds|seconds' => \$enable_seconds,
    'enable-nonproportional-watches|nonproportional-watches' => \$enable_nonproportional_watches,
    'enable-qing-quarters|qing-quarters' => \$enable_qing_quarters,
    'Q|qing' => sub { ($enable_nonproportional_watches, $enable_qing_quarters) = (1, 1); },
    'p|enable-planetary=s' => sub {
	  $enable_planetary = 1;
	  die "You must specify either \"all\" or \"minimal\"\n" unless $_[1] =~ /^(?:all|full|min(?:imal(?:istic)?)?)/;
	  $planetary_omit_details = 1 if $_[1] =~ /^min/;
	},
    'g|genmon' => \$genmon_mode,
    'u|underline' => sub { ($em, $_em) = ($u, $_u); },
    'w|sysline' => \$sysline_mode,
    'z|zh|chinese|kanji' => sub { $lang = 'zh'; },
    '3|disable-4th-hebrew-watch|disable-4th-watch' => sub { $enable_4th_hebrew_watch = 0; },
    '4|enable-4th-hebrew-watch|enable-4th-watch' => \$enable_4th_hebrew_watch,
    'iconic' => sub { $representation = 'icon' },
    'symbolic' => sub { $representation = 'name' },
    'help' => \&usage,
  ) || usage(1);

}

sub COUNTDOWN () { 10 }

for (my $epsilon = 0, my $countdown = COUNTDOWN, my %events;;) {
  my $t0 = Time::HiRes::time;
  my $c = determine_chinese_time $t0;
  ($_, $_, $_, $_, my $chinese_hour, my $quarter, my $centiday, my $deciday, $_, $_, my $deciday_size) = @$c;
  my($sec, $min, $hour) = localtime $t0;

  # Determine what should happen next
  no integer;
  my @event = determine_events($t0, $hour, $min, $sec, $chinese_hour, $quarter, $centiday, $deciday, $deciday_size);
  for my $event (@event) {
    $events{+$event->{'t'}} = $event;
  }
  for my $t (keys %events) {
    delete $events{$t} if $t < $t0;
  }

  # Determine when we should wake up; try to make some effort to align it to a second boundary
  my $t1 = Time::HiRes::time;
  my $t_next = int($t0) + ($countdown > 0? 1: ($event[0]->{'t'} - $t0)/2);
  my $dt = $t_next - $t1 + $epsilon;
  $dt = 0 if $dt < 0;

  # Debug message
  printf STDERR "%10.2f = %02d:%02d:%02d - %02d %2.2f %2.2f %2.2f (âˆ‚t=%2.2f, É›=%2.2f) - next: %s\033[K\r",
      $t0, $hour, $min, $sec, $chinese_hour, $quarter, $centiday, $deciday, $dt, $epsilon,
      join(', ', map { sprintf '%s %s', $_->{'t'}, $_->{'id'} } @event);

  # Try to compensate for the printf. This actually seems to make things worse
  my $t2 = Time::HiRes::time;
  $epsilon = $t2 - $t1;

  Time::HiRes::sleep $dt;

  # Check if any event has been fired
  my $now = Time::HiRes::time;
  for my $t (keys %events) {
    if ($now >= $t) {
      my $e = $events{$t};
      my $dt = $now - $t;
      printf STDERR "\nEVENT %s (%d) fired at %d (%s)\n", $e->{'id'}, $t, $now, ($dt < 0.01? 'on time': sprintf('%.2f s late', $dt));
      delete $events{$t};
    }
  }

  $countdown -= 1;
  $countdown = COUNTDOWN if $countdown < 0;
}

1;
