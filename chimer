#!/usr/bin/perl
# vi:set sw=2 ai sm:
#
# Re-implementation of the Javascript chiming clocks (sysline, silliness) in Perl
# Copyright © 2021 by Ambrose Li
# The primary purpose of this script is to avoid running the two chiming clock pages
# as Firefox tabs, because Firefox (and all Chrome-based browsers) are now unfriendly
# to Javascript pages that use audio as their primary UI. Firefox also leaks memory
# really fast so it's best to not keep Firefox running for long periods of time.
#
# Eventually this script might provide a way to make the genmon script less CPU
# intensive.
#
# This re-implementation uses the following sounds:
#
# strangehorizon. (2021). "Tuned Chau Gongs: g16_D#5-gong.wav" (audio file).
# Retrieved from https://freesound.org/people/strangehorizon/sounds/582159/
#
# ------
#
# Concept from the Javascript chiming clocks:
# "Copyright © 2018 by Ambrose Li :-)"
#
# ------
#
# Mostly based on the genmon script for Chinese/Hebrew dates:
# "Copyright 2016-2018, 2021 by Ambrose Li <ambrose.li@gmail.com>
# The primary purpose of this script is to figure out the year number in the Chinese system
# so that I can name my CV's without having to look up two web pages.
# Everything else is just for kicks =P"
#

# see https://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default for these crazy hacks
# THERE ARE MORE CRAZY HACKS THERE FOR MORE COMPLEX PROJECTS!!
use v5.12; # minimal for unicode string feature
use v5.14; # //u modifier
use utf8;
use open qw( :encoding(UTF-8) :std );
use charnames qw( :full :short );
use feature "unicode_strings";

use warnings qw( FATAL utf8 );
use Encode qw( encode decode );
#@ARGV = map { decode("UTF-8", $_) } @ARGV if grep /\P{ASCII}/ => @ARGV;


use strict;
use integer;

use POSIX;
use DateTime;
use Time::HiRes; # overrides (qw) do not seem to work

use vars qw( $use_datetime_event_sunrise );
use vars qw( $use_datetime_astro_sunrise );
use vars qw( $use_astro_sunrise );
BEGIN {
  if (eval { require DateTime::Event::Sunrise; }) {
    $use_datetime_event_sunrise = 1;
  } elsif (eval { require DateTime::Astro::Sunrise; }) {
    $use_datetime_astro_sunrise = 1;
  } elsif (eval { require Astro::Sunrise; }) {
    $use_astro_sunrise = 1;
  } else {
    die "Cannot find a usable Sunrise package";
  }
}

use Getopt::Long;
use Data::Dumper;

use vars qw( $debug );
use vars qw( $verbose_p );
use vars qw( $enable_seconds );
use vars qw( $enable_nonproportional_watches );
use vars qw( $enable_qing_quarters );
use vars qw( $enable_planetary $planetary_omit_details );
use vars qw( $enable_decaminutes $enable_minutes );
use vars qw( $enable_4th_hebrew_watch );

use vars qw( $coords );

use vars qw( $lat $lon );

use vars qw( $datadir );
$datadir = "$1/data" if $0 =~ /^(.*?)\/[^\/]+$/;

# night watch chime patterns
sub LONG_STRIKE  () { 1.5 }
sub SHORT_STRIKE () { 0.75 }
sub GAP          () { 5 }
# watch chime patterns: repetitions, pattern
# gap needs to be long enough to hear it, but short enough to not mistake it for a long strike. This is HARD
use vars qw( @watch_chime_pattern );
@watch_chime_pattern = ( # v. https://zh.wikipedia.org/wiki/打更 (q.v.)
   [3, '- .'		],
   [2, '. .'		],
   [3, '- . .'		],
   [4, '- . . .'	],
   [5, '- . . . .'	],
   [1, '-'		],		# test chime X
   [1, '.'		],		# test chime Y
);


sub start_of_day ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  return mktime(0, 0, 0, $mday, $mon, $year);
}

sub yesterday ($) {
  my($t) = @_;
  return start_of_day(start_of_day($t) - 12*3600);
}

sub tomorrow ($) {
  my($t) = @_;
  return start_of_day(start_of_day($t) + 36*3600);
}

sub estimate_sunrise ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->start;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[0];
    $it = $tmp->strftime('%s');
  } else {
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunrise;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub estimate_sunset ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->end;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[1];
    $it = $tmp->strftime('%s');
  } else {
    # this should be the same as the else case in estimate_sunrise except the last line
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunset;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub trim ($) {
  my($s) = @_;
  $s =~ s/^\s+//;
  $s =~ s/\s+$//;
  return $s;
}

sub guess_city () {
  my $input = '/etc/localtime';
  my $det = readlink $input;
  die "$input: $!\n" unless defined $det;
  return $1 if $det =~ /([^\/]+)$/s;
}

sub guess_coordinates () {
  my $it;
  my $city = guess_city;
  print STDERR "guessed city=($city)\n" if $debug;
  my @cmd = qw(hebcal cities);
  print STDERR 'DEBUG: running: ', join(' ', @cmd), "\n" if $debug;
  my $pid = open(INPUT, '-|');
  die "$0: guess_coordinates: $cmd[0]: fork: $!\n" unless defined $pid;
  if ($pid) {
    my $re = quotemeta $city;
    for (;;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp;
      if ($s =~ /^$re \((\d+)d(\d+)' ([NS]) lat, (\d+)d(\d+)' [EW] long/) {
	no integer;
	$it = {
	      'lat' => ($1 + $2/60)*($3 eq 'N'? 1: -1),
	      'lon' => ($4 + $5/60)*($6 eq 'E'? 1: -1),
	    };
      }
    last if defined $it;
    }
    close INPUT;
  } else {
    exec {$cmd[0]} @cmd;
    die "$0: guess_coordinates: $cmd[0]: exec: $!\n";
  }
  return $it;
}

sub read_ini ($) {
  my($input) = @_;
  my $it;
  local(*INPUT, $.);
  if (open(INPUT, '<:utf8', $input)) {
    for (my $section;;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp $s;
      if ($s =~ /^\s*(?:[#\%;]|$)/) {
	;
      } elsif ($s =~ /^\s*\[\s*([^\[\]]+?)\s*\]\s*$/) {
	$section = $1;
      } elsif ($s =~ /^\s*([^=]+?)\s*=\s*(.*)/) {
	if (defined $section) {
	  $it->{$section}->{$1} = $2;
	} else {
	  $it->{$1} = $2;
	}
      } else {
	warn "$input:$.: Warning: Unknown input \"$s\"\n";
      }
    }
    close INPUT;
  }
  return $it;
}


# Quarters are weird. See https://zh.wikipedia.org/wiki/%E5%88%BB
#                     and http://yywz.snnu.edu.cn/show.aspx?id=697&cid=26
# Apparently the old Chinese system also used proportional hours... so we'll need to refactor things here at some point
# http://www.twword.com/wiki/%E5%B9%B2%E6%94%AF%E7%B4%80%E6%B3%95
sub determine_chinese_time ($) {
  my($t) = @_;
  my $it;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $midnight = start_of_day $t;
  my $deciday;
  my $slice; # size of proportional hour, needed to figure out when to sound the next chime
  # NOTE: according to one source (forgot which), the first hour (ˊdzi) spans [2300, 0100) but the new day still starts at 0000. Very odd :-/
  # therefore the old adjustment for [2300, 0000) has been deleted
  if (defined $coords) {
    my $today = start_of_day $t;
    my $yesterday = yesterday $t;
    my $tomorrow = tomorrow $t;
    my($daybreak, $slice_start, $slice_end, $starting_hour);
    # Proportional hour is used in a very early system (Spring and Autumn Period / Warring States),
    # but I don't even have an idea when the day starts (probably day before night) so we'll arbitrarily use sunrise as cutoff
    if ($t < estimate_sunrise($today)) {
      $daybreak = estimate_sunrise($yesterday);
      $slice_start = estimate_sunset($yesterday);
      $slice_end = estimate_sunrise($today);
      $starting_hour = 6;
    } elsif ($t < estimate_sunset($today)) {
      $daybreak = estimate_sunrise($today);
      $slice_start = $daybreak;
      $slice_end = estimate_sunset($today);
      $starting_hour = 1;
    } else {
      $daybreak = estimate_sunrise($today);
      $slice_start = estimate_sunset($today);
      $slice_end = estimate_sunrise($tomorrow);
      $starting_hour = 6;
    }
    if ($slice_start && $slice_end) {
      no integer;
      $slice = ($slice_end - $slice_start)/5;
      $deciday = $starting_hour + ($t - $slice_start)/$slice;
    }
  }
  my($greg_year, $greg_month, $greg_day) = ($year + 1900, $mon + 1, $mday);
  my $relative_chinese_hour = eval { no integer; fmod(($t - ($midnight - 3600))/7200, 12) };
  my $chinese_hour = $relative_chinese_hour + 1;
  my $quarter;
  my $centiday = eval { no integer; ($t - $midnight)/864 };
  if ($enable_qing_quarters) {
    $quarter = $min/15 + 1;
    $quarter += 4 if $hour%2 == 0;
  } else {
    # NOTE: traditionally these aren't quarters, but number of centiday marks past the beginning of the hour
    no integer;
    #
    # 0.5 hours maps exactly to 0 centidays. So to calculate the reporting origin, which is fractional.
    # Each hour is 86400/12 seconds, each centiday is 86400/100 seconds, so each hour is 100/12 centidays
    # In theory, each zero-based hour h begins exactly at ⌊h - 0.5⌋*100/12 centidays
    # However, when h ∈ [0, 0.5) this gives unexpected results because the formula will give a negative result
    # There's no easy way to fix this because reporting origins are hour-aligned, not half-hour aligned
    # (so we can't even change ⌊h - 0.5⌋ to (⌊h*2 - 1⌋%24)/2 because this breaks for h > 1.0)
    #
    my $reporting_origin = POSIX::floor(($relative_chinese_hour < 0.5? 11.5: (int($relative_chinese_hour) - 0.5)) * 100 / 12);
    print STDERR "relative_chinese_hour=$relative_chinese_hour => reporting_origin=$reporting_origin\n" if $debug;
    $quarter = $centiday - int($reporting_origin);
  }
  $it = [undef, undef, undef, undef, $chinese_hour, $quarter, $centiday, $deciday,
      $wday, eval { no integer; $relative_chinese_hour < 0.5 }, $slice];
  return $it;
}

sub determine_events ($$$$$$$$$) {
  my($t0, $hour, $min, $sec, $chinese_hour, $quarter, $centiday, $deciday, $deciday_size) = @_;
  my @it;
  no integer;

  # Western quarter-hour chime
  # Make absolutely sure we have a chime event, in case it gets thrown out because we're too close to the actual next quarter hour
  my $seconds_since_hour_change = 60*$min + $sec;
  my $t_next_quarter_chime = int($t0) + (900 - $seconds_since_hour_change%900);
  my $next_quarter = (int($seconds_since_hour_change / 900) + 1)%4;
  my $next_hour = (($next_quarter? $hour: $hour + 1) + 11)%12 + 1;
  my $quarter_chime_event_pushed_p = 0;
  die "Calculation error, next quarter $t_next_quarter_chime is in the past" if $t_next_quarter_chime < $t0;
  die "Calculation error, next quarter $t_next_quarter_chime more than 15 minutes away" if $t_next_quarter_chime - $t0 > 900;
  for (my $i = 0; $i < 2; $i += 1,
			  $t_next_quarter_chime += 900,
			  $next_quarter = ($next_quarter + 1)%4,
			  $next_hour += !$next_quarter, $next_hour = ($next_hour - 1)%12 + 1) {
    my $prechime_length;
    if ($next_quarter == 0) {
      push @it, {
	't' => $t_next_quarter_chime,
	'id' => "h$next_hour",
	'type' => 'hour',
	'comment' => "hour $next_hour chime",
      };
      $prechime_length = 25;
    } elsif ($next_quarter == 1) {
      $prechime_length = 5;
    } elsif ($next_quarter == 2) {
      $prechime_length = 10;
    } elsif ($next_quarter == 3) {
      $prechime_length = 15;
    }
    if ($t_next_quarter_chime - $prechime_length >= $t0) {
      push @it, {
	't' => $t_next_quarter_chime - $prechime_length,
	'id' => "q$next_quarter",
	'type' => 'quarter',
	'comment' => "hour $next_hour quarter $next_quarter prechime",
      };
      $quarter_chime_event_pushed_p = 1;
    }
  last if $quarter_chime_event_pushed_p;
  }

  # Shang-era proportional-deciday-based night watch chimes
  # 1 watch is exactly 1 deciday, which is not actually 1/10 of a day but 1/5 of the current proportional moitie
  if ($deciday > 5 && $deciday < 6) { # 5 is the last deciday in the "day" moitie
    my $t_first_watch = $t0 + (6 - $deciday)*$deciday_size;
    push @it, {
      't' => $t_first_watch,
      'id' => 'w1.1',
      'type' => 'watch',
      'comment' => 'watch 1',
    };
  } elsif ($deciday >= 6) {
    my $decidays_into_night = $deciday - 6;
    my $subwatches_into_night = 5*$decidays_into_night;
    my $zero_based_next_subwatch = (int($subwatches_into_night) + 1)%25;
    if ($zero_based_next_subwatch) {
      my $next_watch = int($zero_based_next_subwatch/5) + 1;
      my $next_fifth_of_watch = $zero_based_next_subwatch%5 + 1;
      my $t_next_fifth_of_watch = $t0 + (1 - fmod($subwatches_into_night, 1)) * ($deciday_size/5);
      push @it, {
	't' => $t_next_fifth_of_watch,
	'id' => "w$next_watch.$next_fifth_of_watch",
	'type' => 'watch',
	'comment' => "watch $next_watch.$next_fifth_of_watch",
      };
    }
  }

  @it = sort { $a->{'t'} <=> $b->{'t'} } @it;
  return wantarray? @it: \@it;
}

sub play_sound_file ($;$) {
  my($input, $volume) = @_;
  $volume = 50 unless defined $volume;

  # Fork and play it in the background
  $ENV{'PULSE_SINK'} = 'alsa_output.pci-0000_00_14.2.analog-stereo'; # FIXME
  my @cmd = ('mpv', '--no-video', '--really-quiet', '--volume', $volume, $input);
  my $h = fork;
  die "$cmd[0]: fork: $!\n" unless defined $h;
  if ($h == 0) {
    exec { $cmd[0] } @cmd;
    die "$cmd[0]: exec: $!\n";
  }
}

sub strike_gong () {
  play_sound_file "$datadir/582159__strangehorizon__g16-d-5-gong.wav", 40;
}

sub announce_quarter_hour ($) {
  my($quarter) = @_;
  print STDERR "Pretending to announce quarter hour for quarter $quarter\n";
}

sub announce_hour ($) {
  my($hour) = @_;
  print STDERR "Pretending to announce hour for hour $hour\n";
}

sub announce_night_watch ($$) {
  my($watch, $subwatch) = @_;
  # Fork and play it in the background
  my $h = fork;
  die "fork: $!\n" unless defined $h;
  if ($h == 0) {
    my($repeats, $pattern) = @{$watch_chime_pattern[$watch - 1]};
    for (my $i = 0; $i < $repeats; $i += 1) {
      print STDERR "DEBUG: pattern is $pattern\n" if $debug;
      for my $length (split(/\s+/, $pattern)) {
	$length = ($length eq '.'? SHORT_STRIKE: LONG_STRIKE);
	strike_gong;
	Time::HiRes::sleep $length;
      }
      Time::HiRes::sleep GAP unless $i + 1 == $repeats;
    }
  }
}

sub do_event ($) {
  my($id) = @_;
  if ($id =~ /^q(\d+)$/) {			# quarter hour chime
    announce_quarter_hour $1;
  } elsif ($id =~ /^h(\d+)$/) {		# hourly chime
    announce_hour $1;
  } elsif ($id =~ /^w(\d+)\.(\d+)$/) {	# night watch
    announce_night_watch $1, $2;
  } else {
    print STDERR "Unknown event $id ignored\n";
  }
}

sub usage (;$) {
  my($st) = @_;
  my $h = $st? *STDERR: *STDOUT;
  print $h <<EOF;
Usage: $0 [OPTION]...
Display date and time information in a non-mainstream calendar.

      --disable-hebrew        Do not display Hebrew date and time
  -M, --decaminutes           Enable display of ancient Chinese decaminutes
                              (and disable display of fractional centidays)
  -m, --minutes               Enable display of Western "planetary" minutes (and
                              ancient Chinese minutes if decaminutes are enabled)
      --nonproportional-watches
                              Use watches that are aligned to Chinese hours
  -p, --enable-planetary=all  Enable the Western "planetary" system and display
                              current time in addition to the equivalent zodiac
  -p, --enable-planetary=minimal
                              Enable the Western "planetary" system but display
                              only the zodiac corresponding to the current hour
  -Q, --qing                  Same as --nonproportional-watches --qing-quarters
      --qing-quarters         Use the Qing quarters system (identical to modern
                              quarters) instead of the ancient centiday system
  -s, --seconds               Enable display of Western "planetary" seconds
  -v, --verbose               Explain what is being done
  -3, --disable-4th-watch     Use 3 watches for Hebrew system. This is the default
  -4, --enable-4th-watch      Use 4 watches for Hebrew system
      --symbolic              Use zodiac names
      --debug                 Produce debugging output

Note that Chinese and Hebrew dates and times are always shown. Western "planetary"
times are shown only when enabled.
EOF
  exit $st;
}

binmode STDIN, ':utf8';
binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';

select((select(STDERR), $| = 1)[0]); # I don't know why this is needed for STDERR

$coords = guess_coordinates unless defined $coords;
($lat, $lon) = ($coords->{'lat'}, $coords->{'lon'}) unless defined $lat;
die "$0: Can't determine coordinates\n" unless defined $coords;

if (!caller) {
  Getopt::Long::config('bundling');
  GetOptions(
    'debug' => sub { $debug += 1; },
    'M|enable-decaminutes|decaminutes' => \$enable_decaminutes,
    'm|enable-minutes|minutes' => \$enable_minutes,
    's|enable-seconds|seconds' => \$enable_seconds,
    'enable-nonproportional-watches|nonproportional-watches' => \$enable_nonproportional_watches,
    'enable-qing-quarters|qing-quarters' => \$enable_qing_quarters,
    'Q|qing' => sub { ($enable_nonproportional_watches, $enable_qing_quarters) = (1, 1); },
    '3|disable-4th-hebrew-watch|disable-4th-watch' => sub { $enable_4th_hebrew_watch = 0; },
    '4|enable-4th-hebrew-watch|enable-4th-watch' => \$enable_4th_hebrew_watch,
    'v|verbose' => \$verbose_p,
    'help' => \&usage,
  ) || usage(1);

}

sub COUNTDOWN () { 5 } # things stablize after 2-3 times, we do 5 just in case (10 is overkill)

for (my $epsilon = 0, my $countdown = COUNTDOWN, my %events;;) {
  my $t0 = Time::HiRes::time;
  my $c = determine_chinese_time $t0;
  ($_, $_, $_, $_, my $chinese_hour, my $quarter, my $centiday, my $deciday, $_, $_, my $deciday_size) = @$c;
  my($sec, $min, $hour) = localtime $t0;

  # Determine what should happen next
  no integer;
  my @event = determine_events($t0, $hour, $min, $sec, $chinese_hour, $quarter, $centiday, $deciday, $deciday_size);
  for my $event (@event) {
    $events{+$event->{'t'}} = $event;
  }
  for my $t (keys %events) {
    if ($t0 - $t > 0.25) { # just do it if we missed it by just a fraction of a second
      printf STDERR "\nEVENT %s (%d) MISSED at %d (%.2f too late)\n", $events{$t}->{'id'}, $t, $t0, $t0 - $t;
      delete $events{$t};
    }
  }

  # Determine when we should wake up; try to make some effort to align it to a second boundary
  my $t1 = Time::HiRes::time;
  my $dt0 = $event[0]->{'t'} - $t1;
  my $t_next = ($countdown && $dt0 > 1)? (int($t0) + 1): ($t1 + $dt0/2);
  my $dt = $t_next - $t1 + $epsilon;
  $dt = 0 if $dt < 0;

  # Debug message
  printf STDERR "%10.2f - %02d %2.2f %2.2f %2.2f (Δt=%2.2f, ε=%2.2f) > %s\033[K\r",
      $t0, $chinese_hour, $quarter, $centiday, $deciday, $dt, $epsilon,
      join(', ', map { sprintf '%.2f (%+.1f) %s', $_->{'t'}, ($_->{'t'} - $t0), $_->{'id'} } @event) if $verbose_p;

  # Try to compensate for the printf. This actually seems to make things worse
  my $t2 = Time::HiRes::time;
  $epsilon = $t2 - $t1;

  Time::HiRes::sleep $dt;

  # Check if any event should be fired
  my $now = Time::HiRes::time;
  my $dt_actual = $now - $t2;
  printf STDERR "\nWARNING: tried to sleep for %.2f s but slept for %.2f s\n", $dt, $dt_actual if $dt_actual > $dt + 1;
  for my $t (keys %events) {
    if ($now >= $t) {
      my $e = $events{$t};
      my $dt = $now - $t;
      my $id = $e->{'id'};
      printf STDERR "\nEVENT %s (%d) fired at %d (%s)\n", $id, $t, $now, ($dt < 0.01? 'on time': sprintf('%.2f s late', $dt));
      do_event $id;
      $countdown = 0; # force a re-countdown
      delete $events{$t};
    }
  }

  $countdown -= 1;
  $countdown = COUNTDOWN if $countdown < 0;
}

1;
