#!/usr/bin/perl
# vi:set sw=2 ai sm:
#
# Re-implementation of the Javascript chiming clocks (sysline, silliness) in Perl
# Copyright © 2021 by Ambrose Li
# The primary purpose of this script is to avoid running the two chiming clock pages
# as Firefox tabs, because Firefox (and all Chrome-based browsers) are now unfriendly
# to Javascript pages that use audio as their primary UI. Firefox also leaks memory
# really fast so it's best to not keep Firefox running for long periods of time.
#
# Eventually this script might provide a way to make the genmon script less CPU
# intensive.
#
# This re-implementation uses the following sounds:
#
# strangehorizon. (2021). "Tuned Chau Gongs: g16_D#5-gong.wav" (audio file).
# Retrieved from https://freesound.org/people/strangehorizon/sounds/582159/
#
# ------
#
# Concept from the Javascript chiming clocks:
# "Copyright © 2018 by Ambrose Li :-)"
#
# ------
#
# Mostly based on the genmon script for Chinese/Hebrew dates:
# "Copyright 2016-2018, 2021 by Ambrose Li <ambrose.li@gmail.com>
# The primary purpose of this script is to figure out the year number in the Chinese system
# so that I can name my CV's without having to look up two web pages.
# Everything else is just for kicks =P"
#

# see https://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default for these crazy hacks
# THERE ARE MORE CRAZY HACKS THERE FOR MORE COMPLEX PROJECTS!!
use v5.12; # minimal for unicode string feature
use v5.14; # //u modifier
use utf8;
open qw( :encoding(UTF-8) :std );
use charnames qw( :full :short );
use feature "unicode_strings";

use warnings qw( FATAL utf8 );
use Encode qw( encode decode );
#@ARGV = map { decode("UTF-8", $_) } @ARGV if grep /\P{ASCII}/ => @ARGV;


use strict;
use integer;

use POSIX;
use POSIX ":sys_wait_h"; # for nonblocking read
use DateTime;
use Time::HiRes; # overrides (qw) do not seem to work

use vars qw( @restart_cmd );
@restart_cmd = ($0, @ARGV); # save this because GetOpt will clear @ARGV

use vars qw( $use_datetime_event_sunrise );
use vars qw( $use_datetime_astro_sunrise );
use vars qw( $use_astro_sunrise );
BEGIN {
  if (eval { require DateTime::Event::Sunrise; }) {
    $use_datetime_event_sunrise = 1;
  } elsif (eval { require DateTime::Astro::Sunrise; }) {
    $use_datetime_astro_sunrise = 1;
  } elsif (eval { require Astro::Sunrise; }) {
    $use_astro_sunrise = 1;
  } else {
    die "Cannot find a usable Sunrise package";
  }
}

use Getopt::Long;
use Data::Dumper;

use vars qw( $config );
use vars qw( $debug );
use vars qw( $verbose_p );
use vars qw( $enable_seconds );
use vars qw( $enable_nonproportional_watches );
use vars qw( $enable_qing_quarters );
use vars qw( $enable_planetary $planetary_omit_details );
use vars qw( $enable_decaminutes $enable_minutes );
use vars qw( $enable_4th_hebrew_watch );

use vars qw( $coords );
use vars qw( $lat $lon );
use vars qw( @sinks );
use vars qw( %synth );
use vars qw( %children );

sub MAX_UPTIME_ALLOWED () { 14400 }

use vars qw( $boottime );
$boottime = Time::HiRes::time;

use vars qw( $basedir $datadir );
$basedir = $1 if $0 =~ /^(.*?)\/+[^\/]+$/;
$basedir =~ s/(?:^|\/+)bin$//;
$basedir = '.' if $basedir eq '';
$datadir = "$basedir/data";

# number of times we try sleeping for 1 second until we sleep until the target event
sub COUNTDOWN () { 5 } # things stablize after 2-3 times, we do 5 just in case (10 is overkill)

sub MODE__SYSLINE   () { 'sysline' }
sub MODE__CUCKOO    () { 'cuckoo' }
sub MODE__CARILLON  () { 'carillon' }
sub METHOD__SAMPLES () { 'samples' }
sub METHOD__SYNTH   () { 'synth' }

use vars qw( $mode $method );
$mode   = MODE__CARILLON;
$method = METHOD__SAMPLES;

# night watch chime patterns
sub LONG_STRIKE  () { 2 }
sub SHORT_STRIKE () { 1.25 }
sub GAP          () { 3.5 }
# watch chime patterns: repetitions, pattern
# gap needs to be long enough to hear it, but short enough to not mistake it for a long strike. This is HARD
use vars qw( @watch_chime_pattern );
@watch_chime_pattern = ( # v. https://zh.wikipedia.org/wiki/打更 (q.v.)
   [3, '— .'		],
   [2, '. .'		],
   [3, '— . .'		],
   [4, '— . . .'	],
   [5, '— . . . .'	],
   [1, '—'		],		# test chime X
   [1, '.'		],		# test chime Y
);

use vars qw( @midi_number_to_note %note_to_midi_number );
@midi_number_to_note = (
  'c0', 'c#0', 'd0', 'd#0', 'e0', 'f0', 'f#0', 'g0', 'g#0', 'a0', 'a#0', 'b0',
  'c1', 'c#1', 'd1', 'd#1', 'e1', 'f1', 'f#1', 'g1', 'g#1', 'a1', 'a#1', 'b1',
  'c2', 'c#2', 'd2', 'd#2', 'e2', 'f2', 'f#2', 'g2', 'g#2', 'a2', 'a#2', 'b2',
  'c3', 'c#3', 'd3', 'd#3', 'e3', 'f3', 'f#3', 'g3', 'g#3', 'a3', 'a#3', 'b3',
  'c4', 'c#4', 'd4', 'd#4', 'e4', 'f4', 'f#4', 'g4', 'g#4', 'a4', 'a#4', 'b4',
  'c5', 'c#5', 'd5', 'd#5', 'e5', 'f5', 'f#5', 'g5', 'g#5', 'a5', 'a#5', 'b5',
  'c6', 'c#6', 'd6', 'd#6', 'e6', 'f6', 'f#6', 'g6', 'g#6', 'a6', 'a#6', 'b6',
  'c7', 'c#7', 'd7', 'd#7', 'e7', 'f7', 'f#7', 'g7', 'g#7', 'a7', 'a#7', 'b7',
  'c8', 'c#8', 'd8', 'd#8', 'e8', 'f8', 'f#8', 'g8', 'g#8', 'a8', 'a#8', 'b8',
  'c9', 'c#9', 'd9', 'd#9', 'e9', 'f9', 'f#9', 'g9', 'g#9', 'a9', 'a#9', 'b9',
);
%note_to_midi_number = map { $midi_number_to_note[$_] => $_ } 0..$#midi_number_to_note;

use vars qw( %gong_scale %chime_scale );
%gong_scale = (
  'c4'	=> '582141__strangehorizon__g01-c-4-gong.wav',
  'c#4'	=> '582140__strangehorizon__g02-c-4-gong.wav',
  'd4'	=> '582139__strangehorizon__g03-d-4-gong.wav',
  'd#4'	=> '582138__strangehorizon__g04-d-4-gong.wav',
  'e4'	=> '582145__strangehorizon__g05-e-4-gong.wav',
  'f4'	=> '582144__strangehorizon__g06-f-4-gong.wav',
  'f#4'	=> '582143__strangehorizon__g07-f-4-gong.wav',
  'g4'	=> '582142__strangehorizon__g08-g-4-gong.wav',
  'g#4'	=> '582147__strangehorizon__g09-g-4-gong.wav',
  'a4'	=> '582146__strangehorizon__g10-a-4-gong.wav',
  'a#4'	=> '582156__strangehorizon__g11-a-4-gong.wav',
  'b4'	=> '582155__strangehorizon__g12-b-4-gong.wav',
  'c5'	=> '582154__strangehorizon__g13-c-5-gong.wav',
  'c#5'	=> '582153__strangehorizon__g14-c-5-gong.wav',
  'd5'	=> '582160__strangehorizon__g15-d-5-gong.wav',
  'd#5'	=> '582159__strangehorizon__g16-d-5-gong.wav',
  'e5'	=> '582158__strangehorizon__g17-e-5-gong.wav',
  'f5'	=> '582157__strangehorizon__g18-f-5-gong.wav',
  'f#5'	=> '582162__strangehorizon__g19-f-5-gong.wav',
  'g5'	=> '582161__strangehorizon__g20-g-5-gong.wav',
);
%chime_scale = (
  'c4'	=> 'chimes_C1.ogg',
  'c#4'	=> 'chimes_C#1.ogg',
  'd4'	=> 'chimes_D1.ogg',
  'd#4'	=> 'chimes_D#1.ogg',
  'e4'	=> 'chimes_E1.ogg',
  'f4'	=> 'chimes_F1.ogg',
  'f#4'	=> 'chimes_F#1.ogg',
  'g4'	=> 'chimes_G1.ogg',
  'g#4'	=> 'chimes_G#1.ogg',
  'a4'	=> 'chimes_A1.ogg',
  'a#4'	=> 'chimes_A#1.ogg',
  'b4'	=> 'chimes_B1.ogg',
  'c5'	=> 'chimes_C2.ogg',
  'c#5'	=> 'chimes_C#2.ogg',
  'd5'	=> 'chimes_D2.ogg',
  'd#5'	=> 'chimes_D#2.ogg',
  'e5'	=> 'chimes_E2.ogg',
  'f5'	=> 'chimes_F2.ogg',
);
use vars qw( $p1 $p2 $p3 $p4 $p5 $rest $strike );
$p1 = [
    ['g#4', 1],
    ['f#4', 1],
    ['e4', 1],
    ['b3', 2],
    ['r', 1],
  ];
$p2 = [
    ['e4', 1],
    ['g#4', 1],
    ['f#4', 1],
    ['b3', 2],
    ['r', 1],
  ];
$p3 = [
    ['e4', 1],
    ['f#4', 1],
    ['g#4', 1],
    ['e4', 2],
    ['r', 1],
  ];
$p4 = [
    ['g#4', 1],
    ['e4', 1],
    ['f#4', 1],
    ['b3', 2],
    ['r', 1],
  ];
$p5 = [
    ['b3', 1],
    ['f#4', 1],
    ['g#4', 1],
    ['e4', 2],
    ['r', 1],
  ];
$rest = [
    ['r', 1],
  ];
$strike = [
    ['e3', 4],
  ];

use vars qw( $_gensym );
sub gensym () {
  my $it = sprintf('g%d', $_gensym);
  $_gensym += 1;
  return $it;
}

sub start_of_day ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  return mktime(0, 0, 0, $mday, $mon, $year);
}

sub yesterday ($) {
  my($t) = @_;
  return start_of_day(start_of_day($t) - 12*3600);
}

sub tomorrow ($) {
  my($t) = @_;
  return start_of_day(start_of_day($t) + 36*3600);
}

sub estimate_sunrise ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->start;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[0];
    $it = $tmp->strftime('%s');
  } else {
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunrise;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub estimate_sunset ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->end;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[1];
    $it = $tmp->strftime('%s');
  } else {
    # this should be the same as the else case in estimate_sunrise except the last line
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunset;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub trim ($) {
  my($s) = @_;
  $s =~ s/^\s+//;
  $s =~ s/\s+$//;
  return $s;
}

sub guess_city () {
  my $input = '/etc/localtime';
  my $det = readlink $input;
  die "$input: $!\n" unless defined $det;
  return $1 if $det =~ /([^\/]+)$/s;
}

sub guess_coordinates () {
  my $it;
  my $city = guess_city;
  print STDERR "guessed city=($city)\n" if $debug;
  my @cmd = qw(hebcal cities);
  print STDERR 'DEBUG: running: ', join(' ', @cmd), "\n" if $debug;
  my $pid = open(INPUT, '-|');
  die "$0: guess_coordinates: $cmd[0]: fork: $!\n" unless defined $pid;
  if ($pid) {
    my $re = quotemeta $city;
    for (;;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp;
      if ($s =~ /^$re \((\d+)d(\d+)' ([NS]) lat, (\d+)d(\d+)' ([EW]) long/) {
	no integer;
	$it = {
	      'lat' => ($1 + $2/60)*($3 eq 'N'? 1: -1),
	      'lon' => ($4 + $5/60)*($6 eq 'E'? 1: -1),
	    };
      }
    last if defined $it;
    }
    close INPUT;
  } else {
    exec {$cmd[0]} @cmd;
    die "$0: guess_coordinates: $cmd[0]: exec: $!\n";
  }
  return $it;
}

# NOTE: modified to act like the current PHP version (root section goes to /, duplicate keys allowed and get stashed into an array)
sub read_ini ($) {
  my($input) = @_;
  my $it;
  local(*INPUT, $.);
  if (open(INPUT, '<:utf8', $input)) {
    for (my $section = '/';;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp $s;
      if ($s =~ /^\s*(?:[#\%;]|$)/) {
	;
      } elsif ($s =~ /^\s*\[\s*([^\[\]]+?)\s*\]\s*$/) {
	$section = $1;
      } elsif ($s =~ /^\s*([^=]+?)\s*=\s*(.*)/) {
	if (defined $section) {
	  $it->{$section}->{$1} = [] unless defined $it->{$section}->{$1};
	  push @{$it->{$section}->{$1}}, $2;
	} else {
	  $it->{$1} = [] unless defined $it->{$1};
	  push @{$it->{$1}}, $2;
	}
      } else {
	warn "$input:$.: Warning: Unknown input \"$s\"\n";
      }
    }
    close INPUT;
  }
  return $it;
}

use vars qw( $deciday_1_re $deciday_2_re $deciday_3_re $deciday_4_re $deciday_5_re );
use vars qw( $deciday_6_re $deciday_7_re $deciday_8_re $deciday_9_re $deciday_10_re );
use vars qw( $clocktime_re $deciday_re );
$clocktime_re = '(?:(?:0?\d|1\d|2[0-3]):[0-5]\d|24:00)';
$deciday_1_re = '\b(?:morning|ˈ?dziu)\b';
$deciday_2_re = '\b(?:forenoon|ˌ?jy)\b';
$deciday_3_re = '\b(?:midday|ˈ?dzuŋ)\b';
$deciday_4_re = '\b(?:afternoon|ˈbou)\b';
$deciday_5_re = '\b(?:evening|ˍdzik)\b';
$deciday_6_re = '\b(?:A|ˉ?gap)\b';
$deciday_7_re = '\b(?:B|ˍ?jyt)\b';
$deciday_8_re = '\b(?:C|ˊ?biŋ)\b';
$deciday_9_re = '\b(?:D|ˈ?diŋ)\b';
$deciday_10_re = '\b(?:E|ˍ?mou)\b';
$deciday_re = "(?:$deciday_1_re|$deciday_2_re|$deciday_3_re|$deciday_4_re|$deciday_5_re|$deciday_6_re|$deciday_7_re|$deciday_8_re|$deciday_9_re|$deciday_10_re)";

use vars qw( $sun_re $mon_re $tue_re $wed_re $thu_re $fri_re $sat_re $dow_re $dow_range_re );
$sun_re = '(?:\b(?:U|Sun(?:day)?)\b)';
$mon_re = '(?:\b(?:M|Mon(?:day)?)\b)';
$tue_re = '(?:\b(?:T|Tue(?:s(?:day)?)?)\b)';
$wed_re = '(?:\b(?:W|Wed(?:nes(?:day)?)?)\b)';
$thu_re = '(?:\b(?:R|Thu(?:r(?:s(?:day)?)?)?)\b)';
$fri_re = '(?:\b(?:F|Fri(?:day)?)\b)';
$sat_re = '(?:\b(?:S|Sat(?:urday)?)\b)';
$dow_re = "(?:$sun_re|$mon_re|$tue_re|$wed_re|$thu_re|$fri_re|$sat_re)";
$dow_range_re = "(?:[UMTWRFS]+|(?:$dow_re(?:\s*[-,]\s*$dow_re)*))";

sub parse_dow ($) {
  my($s) = @_;
  local($`, $&, $');
  return $s =~ /^$sun_re$/? 0:
	 $s =~ /^$mon_re$/? 1:
	 $s =~ /^$tue_re$/? 2:
	 $s =~ /^$wed_re$/? 3:
	 $s =~ /^$thu_re$/? 4:
	 $s =~ /^$fri_re$/? 5:
	 $s =~ /^$sat_re$/? 6: undef;
}


sub parse_clocktime ($) {
  my($s) = @_;
  local($`, $&, $', $1, $2);
  no integer;
  return $s =~ /^(?=$clocktime_re$)(\d+):(\d\d)/? $1 + $2/60: undef;
}

sub parse_named_deciday ($) {
  my($s) = @_;
  local($`, $&, $', $1, $2);
  no integer;
  return $s =~ /^$deciday_1_re$/? 1:
	 $s =~ /^$deciday_2_re$/? 2:
	 $s =~ /^$deciday_3_re$/? 3:
	 $s =~ /^$deciday_4_re$/? 4:
	 $s =~ /^$deciday_5_re$/? 5:
	 $s =~ /^$deciday_6_re$/? 6:
	 $s =~ /^$deciday_7_re$/? 7:
	 $s =~ /^$deciday_8_re$/? 8:
	 $s =~ /^$deciday_9_re$/? 9:
	 $s =~ /^$deciday_10_re$/? 10: undef
}

sub parse_dow_range ($) {
  my($s) = @_;
  my $it;
  if (defined $s) {
    local($`, $&, $', $1, $2);
    if ($s =~ /^[UMTWRFS]+$/) { # Waterloo style single-letter codes
      $it = join(',', map { parse_dow($_) } split(//, $s));
    } else {
      $it = join('', map { substr($_, 0, 1) =~ /[-,]/? (substr($_, 0, 1) . parse_dow(substr($_, 1))): parse_dow($_) } split(/(?=[-,]|$)/, $s));
      $it = 'ERROR' unless $it =~ /^\d+(?:[-,]\d+)*$/;

      # Handle looparounds like Fri-Sun or Sat-Tue
      $it =~ s/\b([1-6])-([1-6])\b/ $1 < $2? $&: "$1-6,0-$2" /ge;
      $it =~ s/\b(?<!-)([1-5])-0\b/\1-6,0/g;
      $it =~ s/\b(?<!-)(6)-0\b/\1,0/g;
    }
  }
  return $it;
}

sub parse_clocktime_range ($) {
  my($s) = @_;
  my $it;
  if (defined $s) {
    local($`, $&, $', $1, $2);
    $it = join('', map { substr($_, 0, 1) =~ /[-,]/? (substr($_, 0, 1) . parse_clocktime(substr($_, 1))): parse_clocktime($_) } split(/(?=[-,]|$)/, $s));
    $it = 'ERROR' unless $it =~ /^\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*$/;

    # Handle looparounds like 23:00-07:00
    no integer;
    $it =~ s/\b(\d+(?:.\d+)?)-(0)\b/ $1 < $2? $&: "$1-24" /ge;
    $it =~ s/\b(\d+(?:.\d+)?)-(\d+(?:.\d+)?)\b/ $1 < $2? $&: "$1-24,0-$2" /ge;
  }
  return $it;
}

sub parse_named_deciday_range ($) {
  my($s) = @_;
  my $it;
  if (defined $s) {
    local($`, $&, $', $1, $2);
    $it = join('', map { substr($_, 0, 1) =~ /[-,]/? (substr($_, 0, 1) . parse_named_deciday(substr($_, 1))): parse_named_deciday($_) } split(/(?=[-,]|$)/, $s));
    $it = 'ERROR' unless $it =~ /^\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*$/;

    # Handle looparounds like C-morning
    no integer;
    $it =~ s/\b(\d+)-(1)\b/ $1 < $2? $&: "$1-10,1" /ge;
    $it =~ s/\b(\d+)-(\d+)\b/ $1 < $2? $&: "$1-10,1-$2" /ge;
  }
  return $it;
}


# Quarters are weird. See https://zh.wikipedia.org/wiki/%E5%88%BB
#                     and http://yywz.snnu.edu.cn/show.aspx?id=697&cid=26
# Apparently the old Chinese system also used proportional hours... so we'll need to refactor things here at some point
# http://www.twword.com/wiki/%E5%B9%B2%E6%94%AF%E7%B4%80%E6%B3%95
sub determine_chinese_time ($) {
  my($t) = @_;
  my $it;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $midnight = start_of_day $t;
  my $deciday;
  my $slice; # size of proportional hour, needed to figure out when to sound the next chime
  # NOTE: according to one source (forgot which), the first hour (ˊdzi) spans [2300, 0100) but the new day still starts at 0000. Very odd :-/
  # therefore the old adjustment for [2300, 0000) has been deleted
  if (defined $coords) {
    my $today = start_of_day $t;
    my $yesterday = yesterday $t;
    my $tomorrow = tomorrow $t;
    my($daybreak, $slice_start, $slice_end, $starting_hour);
    # Proportional hour is used in a very early system (Spring and Autumn Period / Warring States),
    # but I don't even have an idea when the day starts (probably day before night) so we'll arbitrarily use sunrise as cutoff
    if ($t < estimate_sunrise($today)) {
      $daybreak = estimate_sunrise($yesterday);
      $slice_start = estimate_sunset($yesterday);
      $slice_end = estimate_sunrise($today);
      $starting_hour = 6;
    } elsif ($t < estimate_sunset($today)) {
      $daybreak = estimate_sunrise($today);
      $slice_start = $daybreak;
      $slice_end = estimate_sunset($today);
      $starting_hour = 1;
    } else {
      $daybreak = estimate_sunrise($today);
      $slice_start = estimate_sunset($today);
      $slice_end = estimate_sunrise($tomorrow);
      $starting_hour = 6;
    }
    if ($slice_start && $slice_end) {
      no integer;
      $slice = ($slice_end - $slice_start)/5;
      $deciday = $starting_hour + ($t - $slice_start)/$slice;
    }
  }
  my($greg_year, $greg_month, $greg_day) = ($year + 1900, $mon + 1, $mday);
  my $relative_chinese_hour = eval { no integer; fmod(($t - ($midnight - 3600))/7200, 12) };
  my $chinese_hour = $relative_chinese_hour + 1;
  my $quarter;
  my $centiday = eval { no integer; ($t - $midnight)/864 };
  if ($enable_qing_quarters) {
    $quarter = $min/15 + 1;
    $quarter += 4 if $hour%2 == 0;
  } else {
    # NOTE: traditionally these aren't quarters, but number of centiday marks past the beginning of the hour
    no integer;
    #
    # 0.5 hours maps exactly to 0 centidays. So to calculate the reporting origin, which is fractional.
    # Each hour is 86400/12 seconds, each centiday is 86400/100 seconds, so each hour is 100/12 centidays
    # In theory, each zero-based hour h begins exactly at ⌊h - 0.5⌋*100/12 centidays
    # However, when h ∈ [0, 0.5) this gives unexpected results because the formula will give a negative result
    # There's no easy way to fix this because reporting origins are hour-aligned, not half-hour aligned
    # (so we can't even change ⌊h - 0.5⌋ to (⌊h*2 - 1⌋%24)/2 because this breaks for h > 1.0)
    #
    my $reporting_origin = POSIX::floor(($relative_chinese_hour < 0.5? 11.5: (int($relative_chinese_hour) - 0.5)) * 100 / 12);
    print STDERR "relative_chinese_hour=$relative_chinese_hour => reporting_origin=$reporting_origin\n" if $debug;
    $quarter = $centiday - int($reporting_origin);
  }
  $it = [undef, undef, undef, undef, $chinese_hour, $quarter, $centiday, $deciday,
      $wday, eval { no integer; $relative_chinese_hour < 0.5 }, $slice];
  return $it;
}

sub determine_events ($$$$$$$$$) {
  my($t0, $hour, $min, $sec, $chinese_hour, $quarter, $centiday, $deciday, $deciday_size) = @_;
  my @it;
  no integer;
  my $global_delay = $config->{'/'}->{'delay'}->[0] if defined $config->{'/'}->{'delay'};
  $global_delay = 0 unless defined $global_delay;

  # Western quarter-hour chime
  # Make absolutely sure we have a chime event, in case it gets thrown out because we're too close to the actual next quarter hour
  my $seconds_since_hour_change = 60*$min + $sec;
  my $t_next_quarter_chime = int($t0) + (900 - $seconds_since_hour_change%900) + $global_delay;
  my $next_quarter = (int($seconds_since_hour_change / 900) + 1)%4;
  my $next_hour = (($next_quarter? $hour: $hour + 1) + 11)%12 + 1;
  my $quarter_chime_event_pushed_p = 0;
  die "Calculation error, next quarter $t_next_quarter_chime is in the past" if $t_next_quarter_chime < $t0;
  die "Calculation error, next quarter $t_next_quarter_chime more than 15 minutes away" if $t_next_quarter_chime - $t0 > 900;
  for (my $i = 0; $i < 2; $i += 1,
			  $t_next_quarter_chime += 900,
			  $next_quarter = ($next_quarter + 1)%4,
			  $next_hour += !$next_quarter, $next_hour = ($next_hour - 1)%12 + 1) {
    my $prechime_length;
    if ($next_quarter == 0) {
      push @it, {
	't' => $t_next_quarter_chime,
	'id' => "h$next_hour",
	'type' => 'hour',
	'comment' => "hour $next_hour chime",
      };
      $prechime_length = 25;
    } elsif ($next_quarter == 1) {
      $prechime_length = 5;
    } elsif ($next_quarter == 2) {
      $prechime_length = 10;
    } elsif ($next_quarter == 3) {
      $prechime_length = 15;
    }
    if ($t_next_quarter_chime - $prechime_length >= $t0) {
      push @it, {
	't' => $t_next_quarter_chime - $prechime_length,
	'id' => "q$next_quarter",
	'type' => 'quarter',
	'comment' => "hour $next_hour quarter $next_quarter prechime",
	'anticipating' => $prechime_length,
      };
      $quarter_chime_event_pushed_p = 1;
    }
  last if $quarter_chime_event_pushed_p;
  }

  # Spring-and-Autumn-era proportional-deciday-based night watch chimes
  # 1 watch is exactly 1 deciday, which is not actually 1/10 of a day but 1/5 of the current proportional moitie
  if ($deciday > 5 && $deciday < 6) { # 5 is the last deciday in the "day" moitie
    my $t_first_watch = $t0 + (6 - $deciday)*$deciday_size;
    push @it, {
      't' => $t_first_watch,
      'id' => 'w1.1',
      'type' => 'watch',
      'comment' => 'watch 1',
    };
  } elsif ($deciday >= 6) {
    my $decidays_into_the_night = $deciday - 6;
    my $subwatches_into_the_night = 5*$decidays_into_the_night;
    my $zero_based_next_subwatch = (int($subwatches_into_the_night) + 1)%25;
    if ($zero_based_next_subwatch) {
      my $next_watch = int($zero_based_next_subwatch/5) + 1;
      my $next_subwatch = $zero_based_next_subwatch%5 + 1;
      my $t_next_subwatch = $t0 + (1 - fmod($subwatches_into_the_night, 1)) * ($deciday_size/5) + $global_delay;
      push @it, {
	't' => $t_next_subwatch,
	'id' => "w$next_watch.$next_subwatch",
	'type' => 'watch',
	'comment' => "watch $next_watch.$next_subwatch",
      };
      # Check if we should delay this because it would run into the middle of a quarter hour chime
      my $delay = 0;
      for my $event (@it) {
	my $t = $event->{'t'};
	if ($event->{'id'} =~ /^[qh]/ && (($t - 30 <= $t_next_subwatch + $delay && $t_next_subwatch + $delay <= $t)
				      || ($t <= $t_next_subwatch + $delay && $t_next_subwatch + $delay <= $t + 30))) {
	  $delay = ($t + 30) - $t_next_subwatch;
	  $it[$#it]->{'delay'} = $delay;
	}
      }
    }
  }

  @it = sort { $a->{'t'} <=> $b->{'t'} } @it;
  return wantarray? @it: \@it;
}

sub in_range ($$) {
  my($n, $range_spec) = @_;
  my $it = 0;
  no integer;
  for my $subrange_spec (split(/\s*,\s*/, $range_spec)) {
    die "in_range: Malformed element \"$subrange_spec\" in \"$range_spec\"" unless $subrange_spec =~ /^(\d+(?:\.\d+)?)(?:-(\d+(?:\.\d+)?))?$/;
    if (defined $2) {
      $it = $1 <= $n && $n <= $2;
    } else {
      $it = $1 == $n;
    }
  last if $it;
  }
  return $it;
}

sub in_semi_closed_range ($$) {
  my($n, $range_spec) = @_;
  my $it = 0;
  no integer;
  for my $subrange_spec (split(/\s*,\s*/, $range_spec)) {
    die "in_range: Malformed element \"$subrange_spec\" in \"$range_spec\"" unless $subrange_spec =~ /^(\d+(?:\.\d+)?)(?:-(\d+(?:\.\d+)?))?$/;
    if (defined $2) {
      $it = $1 <= $n && $n < $2;
    } else {
      $it = $1 == $n;
    }
  last if $it;
  }
  return $it;
}

sub get_sink () {
  return $ENV{'PULSE_SINK'};
}

sub set_sink ($) {
  my($sink) = @_;
  $ENV{'PULSE_SINK'} = $sink if defined $sink;
}

sub set_test_params () {
  @sinks = @{$config->{'test'}->{'sink'}} if defined $config->{'test'}->{'sink'};
  $mode = $config->{'test'}->{'mode'}->[0] if defined $config->{'test'}->{'mode'};
  $method = $config->{'test'}->{'method'}->[0] if defined $config->{'test'}->{'method'};
  printf STDERR "test params set at %.2f: mode=%s, method=%s\n", $boottime, $mode, $method if $verbose_p || $debug;
}

sub set_sink_volume ($$) {
  my($sink, $volume) = @_;
  my @cmd = ('pactl', 'set-sink-volume', $sink, int($volume));
  print STDERR 'DEBUG: running: ', join(' ', @cmd), "\n" if $debug;
  system { $cmd[0] } @cmd;
}

sub determine_volume_from_directive_and_time ($$$$$$) {
  my($directive, $hour, $min, $sec, $deciday, $wday) = @_;
  my($target_dow, $target_times, $target_volume, $dow_in_range_p, $time_in_range_p);
  my($result, $error);
  no integer;
  if ($directive =~ /^(?:($dow_range_re)\s+)?hours?\s+(\d+(?:[-,]\d+)*)\s*[:=]\s*(\d+(?:\.\d+)?)$/) {		# integer to integer
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range($hour, $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?hours?\s+(\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*)\s*[:=]\s*(\d+(?:\.\d+)?)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range($hour + $min/60 + $sec/3600, $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?decidays?\s+(\d+(?:[-,]\d+)*)\s*[:=]\s*(\d+(?:\.\d+)?)$/) {	# integer to integer
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range(int($deciday), $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?decidays?\s+(\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*)\s*[:=]\s*(\d+(?:\.\d+)?)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range($deciday, $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?($clocktime_re-$clocktime_re)\s*[:=]\s*(\d+(?:\.\d+)?)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_semi_closed_range($hour + $min/60 * $sec/3600, parse_clocktime_range $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?($deciday_re(?:\s*-\s*$deciday_re)?)\s*[:=]\s*(\d+(?:\.\d+)?)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range(int($deciday), parse_named_deciday_range $target_times);
  } elsif ($directive =~ /^\d+(?:\.\d+)?$/) {	# just a number
    ($target_dow, $time_in_range_p, $target_volume) = (undef, 1, $directive);
  } else {
    $error = "unrecognized directive \"$directive\"";
  }
  $dow_in_range_p = !defined $target_dow || in_range($wday, parse_dow_range($target_dow)) if !defined $error;
  if (defined $error || !$dow_in_range_p || !defined $time_in_range_p || !$time_in_range_p) {
    ;
  } elsif ($target_volume >= 0 && $target_volume <= 1) {
    $result = $target_volume;
  } else {
    $error = "out of range volume $target_volume";
  }
  return wantarray? ($result, $error): [$result, $error];
}

sub set_sink_volumes ($$$$$) {
  my($hour, $min, $sec, $deciday, $wday) = @_;
  for my $sink (@sinks) {
    my $label = defined $config->{$sink} && defined $config->{$sink}->{'label'}? $config->{$sink}->{'label'}->[0]: "sink $sink";
    no integer;
    my $adj;
    my $reason;
    if (defined $config->{$sink} && defined $config->{$sink}->{'volume'}) {
      for my $directive (map { split /(?:^|(?<=\d))\s*,\s*/ } @{$config->{$sink}->{'volume'}}) {
	my($candidate_adj, $error) = determine_volume_from_directive_and_time($directive, $hour, $min, $sec, $deciday, $wday);
	($adj, $reason) = ($candidate_adj, "because of volume rule \"$directive\"") if defined $candidate_adj;
	print STDERR "CONFIG ERROR: $error in [$sink] volumes\n" if defined $error;
      last if defined $adj;
      }
      $adj = 1.0 unless defined $adj;
    } else {
      # Default adjustment for "night"
      $adj = 1.0;
      $adj *= 0.9 if $deciday < 1 || $deciday > 5;
      $adj *= 0.9 if $hour < 9 || $hour > 8;
    }
    $reason = 'by default' if defined $adj && !defined $reason;
    print STDERR "Volume adjusted to $adj for $label $reason\n" if $debug || $verbose_p;
    set_sink_volume $sink, 65535 * $adj;
  }
}

sub send_midi_command ($) {
  my($cmd) = @_;
  my $sink = get_sink;
  connect_synth() unless defined $synth{$sink};
  my $h = $synth{$sink}->{'fh'};
  no strict 'refs';
  print $h "$cmd\n";
}

sub connect_synth () {
  my $sink = get_sink;
  if (!defined $synth{$sink}) {
    no strict 'refs';
    print STDERR "Connecting synth for sink $sink\n" if $debug || $verbose_p;
    my @cmd = ('fluidsynth', '-a', 'pulseaudio',
			     '-g', '1',
			     '--midi-channels', '3',
			     '--audio-file-format', 's8',
			     '/usr/share/sounds/sf2/FluidR3_GM.sf2');

    my $h = gensym;
    my $pid = open($h, '|-');
    die "$0: connect_synth: $cmd[0]: fork: $!\n" unless defined $pid;
    if (!$pid) {
      exec { $cmd[0] } @cmd;
      die "$0: connect_synth: $cmd[0]: exec: $!\n";
    }
    select((select($h), $| = 1)[0]);
    $synth{$sink} = {'fh' => $h, 'pid' => $pid};
    $children{$pid} = $sink;
    send_midi_command "select 1 1 0 14";
    send_midi_command "select 2 1 128 48";
  }
  return $synth{$sink};
}

sub generate_sound_clips () {
  # FIXME - unimplemented
}

sub play_sound_file_real ($;$$$) {
  my($input, $volume, $start, $end) = @_;
  my $sink = get_sink;
  $input = "$1.mp3" if !-f $input && $input =~ /^(.*?)\.wav$/ && -f "$1.mp3";

  # Fork and play it in the background
  my @cmd = ('mpv', '--audio-client-name', 'Chiming clock', '--no-video', '--really-quiet', '--input-terminal', 'no', '--volume', $volume);
  push @cmd, ('--start', $start) if defined $start;
  push @cmd, ('--end', $end) if defined $end;
  push @cmd, ("--ao=pulse::$sink") if $sink;
  push @cmd, $input;
  print STDERR 'DEBUG: running: ', join(' ', @cmd), "\n" if $debug;
  my $h = fork;
  die "$cmd[0]: fork: $!\n" unless defined $h;
  if ($h == 0) {
    my $sink = get_sink;
    my $dt = $config->{$sink}->{'delay'}->[0] if defined $config->{$sink} && defined $config->{$sink}->{'delay'};
    Time::HiRes::sleep $dt if $dt > 0;
    POSIX::close(0);
    exec { $cmd[0] } @cmd;
    die "$cmd[0]: exec: $!\n";
  }
  $children{$h} = 1;
}

sub play_sound_file ($;$$$) {
  my($input, $volume, $start, $end) = @_;
  $volume = 50 unless defined $volume;
  if (@sinks) {
    for my $sink (@sinks) {
      print STDERR "set sink $sink\n" if $debug;
      set_sink $sink;
      play_sound_file_real($input, $volume, $start, $end);
    }
  } else {
    play_sound_file_real($input, $volume, $start, $end);
  }
}

sub strike_gong (;$) {
  my($note) = @_;
  if ($note ne 'r') {
    $note = 'd#5' if !defined $note || !defined $gong_scale{$note};
    play_sound_file sprintf('%s/%s', $datadir, $gong_scale{$note}), 50;
  }
}

sub strike_bell ($) {
  my($note) = @_;
  if ($note ne 'r') {
    $note = 'd#5' if !defined $note || !defined $chime_scale{$note};
    play_sound_file sprintf('%s/%s', $datadir, $chime_scale{$note}), 100;
  }
}

sub strike_stick () {
  #send_midi_command sprintf('noteon 2 31 127');
  #play_sound_file sprintf('%s/269735__theriavirra__drumsticks-stagg-maple-sm5a-powerclick-no4a.wav', $datadir), 70;
  play_sound_file sprintf('%s/claves_ff.mp3', $datadir), 90;
}

sub transpose_note ($;$) {
  my($note, $shift) = @_;
  my $it = $midi_number_to_note[$note_to_midi_number{$note} + $shift] if $note ne 'r';
  return defined $it? $it: $note;
}

sub strike_tune (@) {
  my @tune = @_;
  printf STDERR "Striking %s\n", join(' ', map { $_->[0] } @tune) if $debug || $verbose_p;
  for my $spec (@tune) {
    my($note, $time) = @$spec;
    # The gongs have a range of [c4, g5], or [48, 67]; the Westminster chimes require a range of [b3, g#4] or [47, 56]
    # for just the melody, or [e3, g#4], or [40, 56], if we count also the strikes that count the hours
    # If we just deal with the melody, we therefore need to transpose everything up by 1 to 11 semitones
    # (and be content that the hourly strikes will sound a random note); otherwise we need to transpose it up by 8 to 11 semitones.
    # The VCSL chimes have a slightly narrower range of [c4, f5] or [48, 65] so we'll need to transpose it up by 8 to 9 semitones.
    #strike_gong transpose_note $note, 8;
    strike_bell transpose_note $note, 8;
    Time::HiRes::sleep $time;
  }
}

sub announce_quarter_hour_by_carillon ($) {
  my($quarter) = @_;
  my @tune;
  if ($quarter == 1) {
    @tune = @$p1;
  } elsif ($quarter == 2) {
    @tune = (@$p2, @$p3);
  } elsif ($quarter == 3) {
    @tune = (@$p4, @$p5, @$p1);
  } else {
    @tune = (@$p2, @$p3, @$p4, @$p5);
  }
  strike_tune @tune;
}

sub announce_quarter_hour_by_cuckoo ($) {
  my($quarter) = @_;
  if ($quarter == 2) {
    print STDERR "Cuckoo announcing quarter $quarter\n" if $debug || $verbose_p;
    strike_gong 'c#4';
    play_sound_file "$datadir/121203__inchadney__cuckoo.wav", 100, 1.25, 3.05;
  } else {
    print STDERR "Cuckoo does not announce quarter $quarter\n" if $debug || $verbose_p;
  }
}

sub announce_quarter_hour ($) {
  my($quarter) = @_;
  if ($mode eq MODE__CUCKOO) {
    announce_quarter_hour_by_cuckoo($quarter);
  } else {
    announce_quarter_hour_by_carillon($quarter);
  }
}

sub announce_hour_by_carillon ($) {
  my($hour) = @_;
  my @tune = (@$strike) x $hour;
  strike_tune @tune;
}

sub announce_hour_by_cuckoo ($) {
  my($hour) = @_;
  my $f = sub { my($x) = @_; no integer; 1.5 + 1.55*$x };
  print STDERR "Cuckoo announcing hour $hour\n" if $debug || $verbose_p;
  play_sound_file "$datadir/121203__inchadney__cuckoo.wav", 100, 1.25, &$f($hour);
  for (my $i = 0; $i < $hour; $i += 1) {
    #strike_gong 'c#4';
    Time::HiRes::sleep(1.5);
  }
}

sub announce_hour ($) {
  my($hour) = @_;
  if ($mode eq MODE__CUCKOO) {
    announce_hour_by_cuckoo($hour);
  } else {
    announce_hour_by_carillon($hour);
  }
}

sub announce_night_watch ($$) {
  my($watch, $subwatch) = @_;
  my($repeats, $pattern) = @{$watch_chime_pattern[$watch - 1]};
  no integer;
  for (my $i = 0, my $sleep = 0; $i < $repeats; $i += 1) {
    printf STDERR "Striking %s\n", $pattern if $debug || $verbose_p;
    for my $length (split(/\s+/, $pattern)) {
      Time::HiRes::sleep($sleep);
      if ($length eq '.') {
	strike_stick;
	$sleep = SHORT_STRIKE;
      } else {
	strike_gong;
	$sleep = LONG_STRIKE;
      }
    }
    $sleep += GAP;
  }
}

sub do_event ($) {
  my($id) = @_;
  if ($id =~ /^q(\d+)$/) {			# quarter hour chime
    announce_quarter_hour $1;
  } elsif ($id =~ /^h(\d+)$/) {		# hourly chime
    announce_hour $1;
  } elsif ($id =~ /^w(\d+)\.(\d+)$/) {	# night watch
    announce_night_watch $1, $2;
  } else {
    print STDERR "Unknown event $id ignored\n";
  }
}

sub restart_script_real () {	# NOTE: this function exists only to silence the "Statement unlikely to be reached" warning
  for my $pid (keys %children) {
    print STDERR "DEBUG: killing synth $pid\033[K\n" if $debug;
    kill 'TERM', $pid;
  }
  my @cmd = @restart_cmd;
  print STDERR 'DEBUG: restarting: ', join(' ', @cmd), "\033[K\n" if $verbose_p || $debug;
  exec { $cmd[0] } @cmd;
}

sub restart_script () {
  restart_script_real;
  print STDERR "WARNING: restart failed: $!\n";
}

sub safe_to_restart_p () {
  my @cmd = ('perl', '-cw', $restart_cmd[0]);
  print STDERR 'DEBUG: running: ', join(' ', @cmd), "\n" if $debug;
  local $SIG{'CHLD'} = 'DEFAULT'; # need this to check exit status
  return 0 == system { $cmd[0] } @cmd;
}

sub usage (;$) {
  my($st) = @_;
  my $h = $st? *STDERR: *STDOUT;
  print $h <<EOF;
Usage: $0 [OPTION]...
Display date and time information in a non-mainstream calendar.

  -d, --sink SINK             Use the specified SINK for audio
      --disable-hebrew        Do not display Hebrew date and time
  -M, --decaminutes           Enable display of ancient Chinese decaminutes
                              (and disable display of fractional centidays)
  -m, --minutes               Enable display of Western "planetary" minutes (and
                              ancient Chinese minutes if decaminutes are enabled)
      --nonproportional-watches
                              Use watches that are aligned to Chinese hours
  -p, --enable-planetary=all  Enable the Western "planetary" system and display
                              current time in addition to the equivalent zodiac
  -p, --enable-planetary=minimal
                              Enable the Western "planetary" system but display
                              only the zodiac corresponding to the current hour
  -Q, --qing                  Same as --nonproportional-watches --qing-quarters
      --qing-quarters         Use the Qing quarters system (identical to modern
                              quarters) instead of the ancient centiday system
  -s, --seconds               Enable display of Western "planetary" seconds
      --test-hour HOUR        Play hourly chime for HOUR (1..12)
      --test-quarter QUARTER  Play quarter chime for QUARTER (0..3)
      --test-watch WATCH      Play night watch chime for WATCH (1..5)
  -v, --verbose               Explain what is being done
  -3, --disable-4th-watch     Use 3 watches for Hebrew system. This is the default
  -4, --enable-4th-watch      Use 4 watches for Hebrew system
      --symbolic              Use zodiac names
      --debug                 Produce debugging output

Note that Chinese and Hebrew dates and times are always shown. Western "planetary"
times are shown only when enabled.
EOF
  exit $st;
}

###############################################################################
# BEGIN test cases
{ no integer;
for my $test ([1,	'1',		1],
	      [1,	'2',		0],
	      [1,	'1-2',		1],
	      [1,	'2, 1',		1],
	      [2,	'1-2',		1],
	      [2,	'1-3',		1],
	      [2.5,	'1-2',		0],
	      [2.5,	'1-3',		1],
	      [5,	'1, 3-8, 10',	1]) {
  my($n, $range_spec, $expected_result) = @$test;
  my $actual_result = in_range($n, $range_spec);
  die "in_range($n, \"$range_spec\"): test failed: expected $expected_result but got $actual_result\n" unless $expected_result == $actual_result;
}
for my $test (['Sunday',		0],
	      ['Monday',		1],
	      ['Tuesday',		2],
	      ['Wednesday',		3],
	      ['Thursday',		4],
	      ['Friday',		5],
	      ['Saturday',		6],
	      ['Sun',			0],
	      ['Mon',			1],
	      ['Tue',			2],
	      ['Tues',			2],
	      ['Wed',			3],
	      ['Thu',			4],
	      ['Thur',			4],
	      ['Thurs',			4],
	      ['Fri',			5],
	      ['Sat',			6],
	      ['Sun',			0],
	      ['M',			1],
	      ['T',			2],
	      ['W',			3],
	      ['R',			4],
	      ['F',			5],
	      ['S',			6],
	      ['someday',		undef]) {
  my($s, $expected_result) = @$test;
  my $actual_result = parse_dow($s);
  die "parse_dow(\"$s\"): test failed: expected $expected_result but got $actual_result\n" unless $expected_result == $actual_result;
  # dow_re
  ($expected_result, $actual_result) = (defined $expected_result, $s =~ /^$dow_re$/);
  die "\"$s\" =~ /\$dow_re/: test failed: expected $expected_result but got $actual_result\n" unless $expected_result == $actual_result;
  # dow_range_re
  ($expected_result, $actual_result) = ($expected_result, $s =~ /^$dow_range_re$/);
  die "\"$s\" =~ /\$dow_range_re/: test failed: expected $expected_result but got $actual_result\n" unless $expected_result == $actual_result;
}
for my $test (['Thursday',		'4'],
	      ['M-R',			'1-4'],
	      ['Tues-Wed',		'2-3'],
	      ['Mon,Tues-Wed',		'1,2-3'],
	      ['Fri-Sun',		'5-6,0'],
	      ['Fri-Tue',		'5-6,0-2'],
	      ['TRF',			'2,4,5'],
	      ['someday',		'ERROR']) {
  my($s, $expected_result) = @$test;
  my $actual_result = parse_dow_range($s);
  die "parse_dow_range(\"$s\"): test failed: expected $expected_result but got $actual_result\n" unless $expected_result eq $actual_result;
  # dow_range_re
  ($expected_result, $actual_result) = (defined $expected_result && $expected_result ne 'ERROR', $s =~ /^$dow_range_re$/);
  die "\"$s\" =~ /\$dow_range_re/: test failed: expected $expected_result but got $actual_result\n" unless $expected_result == $actual_result;
}
for my $test (['A',		6],
	      ['B',		7],
	      ['E',		10],
	      ['morning',	1],
	      ['midday',	3],
	      ['evening',	5]) {
  my($name, $expected_result) = @$test;
  my $actual_result = parse_named_deciday($name);
  die "parse_named_deciday(\"$name\"): test failed: expected $expected_result but got $actual_result\n" unless $expected_result == $actual_result;
}
for my $test (['00:00',		0.0],
	      ['07:30',		7.5],
	      ['19:15',		19.25],
	      ['24:00',		24.0]) {
  my($name, $expected_result) = @$test;
  my $actual_result = parse_clocktime($name);
  die "parse_clocktime(\"$name\"): test failed: expected $expected_result but got $actual_result\n" unless $expected_result == $actual_result;
}
for my $test (['00:00',		'0'],
	      ['12:00-12:30',	'12-12.5'],
	      ['12:00-00:00',	'12-24'],
	      ['23:00-7:00',	'23-24,0-7']) {
  my($s, $expected_result) = @$test;
  my $actual_result = parse_clocktime_range($s);
  die "parse_clocktime_range(\"$s\"): test failed: expected $expected_result but got $actual_result\n" unless $expected_result eq $actual_result;
}
for my $test (['morning',		'1'],
	      ['morning-evening',	'1-5'],
	      ['evening-B',		'5-7'],
	      ['midday,A',		'3,6'],
	      ['C-morning',		'8-10,1']) {
  my($s, $expected_result) = @$test;
  my $actual_result = parse_named_deciday_range($s);
  die "parse_named_deciday_range(\"$s\"): test failed: expected $expected_result but got $actual_result\n" unless $expected_result eq $actual_result;
}
for my $test (['Thursday hour 19.75-22: 0.25',	21, 30,  0, 6.66, 0, undef, undef],
	      ['Thursday 19:45-22:00: 0.25',	21, 30,  0, 6.66, 0, undef, undef],
	      ['morning: 0.5',			17, 53, 36, 5.14, 0, undef, undef],
	      ['E-evening: 0.75',		17, 53,  0, 5.14, 0, 0.75,  undef],
	      ['3:00-9:00: 0.6',		14, 0,   0, 3.76, 2, undef, undef],	# actual failure on 20210817
	      ['Tue,Fri-Sat,Sun 19:31-20:30: 0.5',21, 0, 0, 6.37, 2, undef, undef],	# actual failure on 20210817
	      ['A: 0.5',			21, 30,  0, 6.66, 0, 0.5,   undef],
	      ['0.5',                           12, 30,  0, 3.20, 0, 0.5,   undef]) {
  my($directive, $hour, $min, $sec, $deciday, $wday, $expected_result1, $expected_result2) = @$test;
  my($actual_result1, $actual_result2) = determine_volume_from_directive_and_time($directive, $hour, $min, $sec, $deciday, $wday);
  die "determine_volume_from_directive_and_time(\"$directive\", $hour, $min, $sec, $deciday, $wday): test failed: expected ($expected_result1, $expected_result2) but got ($actual_result1, $actual_result2)\n" unless $expected_result1 == $actual_result1 && $expected_result2 eq $actual_result2;
}
}
# END test cases
###############################################################################

binmode STDIN, ':utf8';
binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';

select((select(STDERR), $| = 1)[0]); # I don't know why this is needed for STDERR

# SIGCHLD handler must be IGNORE, otherwise Time::HiRes::sleep will fail randomly
$SIG{CHLD} = 'IGNORE';

# Handle config file
$config = read_ini("$ENV{HOME}/.chimerrc");
@sinks = @{$config->{'/'}->{'sink'}} if defined $config->{'/'}->{'sink'};
$coords = {'lon' => $config->{'/'}->{'longitude'}->[0], 'lat' => $config->{'/'}->{'latitude'}->[0]}
    if defined $config->{'/'}->{'longitude'} && defined $config->{'/'}->{'latitude'};
#connect_synths;

# Guess location if not specified in config file
$coords = guess_coordinates unless defined $coords;
($lat, $lon) = ($coords->{'lat'}, $coords->{'lon'}) unless defined $lat;
die "$0: Can't determine coordinates\n" unless defined $coords;

# Check command-line arguments
if (!caller) {
  Getopt::Long::config('bundling');
  GetOptions(
    'D|debug' => sub { $debug += 1; },
    'd|sink=s' => sub { @sinks = $_[1]; },
    'M|enable-decaminutes|decaminutes' => \$enable_decaminutes,
    'm|enable-minutes|minutes' => \$enable_minutes,
    's|enable-seconds|seconds' => \$enable_seconds,
    'enable-nonproportional-watches|nonproportional-watches' => \$enable_nonproportional_watches,
    'enable-qing-quarters|qing-quarters' => \$enable_qing_quarters,
    'Q|qing' => sub { ($enable_nonproportional_watches, $enable_qing_quarters) = (1, 1); },
    'test' => sub { set_test_params;
    exit strike_tune(['c4', 1], ['d4', 1], ['e4', 1], ['f4', 1], ['g4', 1]);
	},
    'test-hour=i' => sub { set_test_params; exit announce_hour(($_[1] - 1) % 12 + 1) },
    'test-quarter=i' => sub { set_test_params; exit announce_quarter_hour($_[1] % 4) },
    'test-watch=i' => sub { set_test_params; exit announce_night_watch(($_[1] - 1) % 5 + 1, 1) },
    '3|disable-4th-hebrew-watch|disable-4th-watch' => sub { $enable_4th_hebrew_watch = 0; },
    '4|enable-4th-hebrew-watch|enable-4th-watch' => \$enable_4th_hebrew_watch,
    'v|verbose' => \$verbose_p,
    'help' => \&usage,
  ) || usage(1);

  printf STDERR "chimer booted at %.2f in %s mode using %s\n", $boottime, $mode, $method if $verbose_p || $debug;
  generate_sound_clips if $method eq METHOD__SYNTH;
  for (my $countdown = COUNTDOWN, my %pending_events, my %completed_events;;) {
    my $t0 = Time::HiRes::time;
    my $c = determine_chinese_time $t0;
    ($_, $_, $_, $_, my $chinese_hour, my $quarter, my $centiday, my $deciday, $_, $_, my $deciday_size) = @$c;
    (my $sec, my $min, my $hour, $_, $_, $_, my $wday) = localtime $t0;

    # Detect terminated child processes
    for my $pid (keys %children) {
      if (!kill 0, $pid || waitpid($pid, WNOHANG) == $pid) {
	print STDERR "\nDEBUG: child process $pid has exited" if $debug;
	delete $children{$pid};
      }
    }

    # Determine what should happen next
    no integer;
    my @event = determine_events($t0, $hour, $min, $sec, $chinese_hour, $quarter, $centiday, $deciday, $deciday_size);
    my $next_event;
    for my $event (@event) {
      # Don't trust floating point calculations - don't use t as key, use id instead
      $pending_events{+$event->{'id'}} = $event;
    }
    for my $id (keys %pending_events) {
      my $e = $pending_events{$id};
      my $t = $e->{'t'};
      $t += $e->{'delay'} if defined $e->{'delay'};
      if ($t0 - $t > 60) { # just do it if we missed it by just a fraction of a second, actually it's fine even if it's a whole minute
	printf STDERR "\nEVENT %s (%d) MISSED at %d (%.2f too late)\n", $id, $t, $t0, $t0 - $t;
	delete $pending_events{$id};
      }
    }
    # reconstitute the @event array
    @event = sort { $a->{'t'} + $a->{'delay'} <=> $b->{'t'} + $b->{'delay'} } map { $pending_events{$_} } keys %pending_events;

    # Determine when we should wake up; try to make some effort to align it to a second boundary
    my $t1 = Time::HiRes::time;
    my $dt0 = $event[0]->{'t'} - $t1;
    my $t_next = ($countdown && $dt0 > 1)? (int($t0) + 1): ($t1 + $dt0/2);
    my $dt = $t_next - $t1;
    $dt = 0 if $dt < 0;

    # If we've been up long enough AND the next event isn't going to fire in a while, restart the script to free up memory (?)
    restart_script if $t0 - $boottime > MAX_UPTIME_ALLOWED && $dt0 > 300 && safe_to_restart_p;

    # Debug message
    printf STDERR "%10.2f - %02d %2.2f %2.2f %2.2f (Δt=%2.2f) > %s\033[K\r",
	$t0, $chinese_hour, $quarter, $centiday, $deciday, $dt,
	join(', ', map { sprintf '%.2f (%+.1f) %s', $_->{'t'}, ($_->{'t'} - $t0), $_->{'id'} } @event) if $verbose_p;

    my $t2 = Time::HiRes::time;
    Time::HiRes::sleep $dt;

    # Check if any event should be fired
    my $now = Time::HiRes::time;
    my $dt_actual = $now - $t2;
    printf STDERR "\nWARNING: tried to sleep for %.2f s but slept for %.2f s\n", $dt, $dt_actual if $dt_actual > $dt + 1;
    for my $id (keys %pending_events) {
      my $e = $pending_events{$id};
      my $t = $e->{'t'};
      $t += $e->{'delay'} if defined $e->{'delay'};
      if ($now < $t) {
	;
      } elsif (defined $completed_events{$id} && $now - $completed_events{$id} < 15) { # This should never happen (but it does)
	printf STDERR "\nERROR: EVENT %s (%.2f) already fired at %.2f (%.2f s ago)\n", $id, $t, $completed_events{$id}, $now - $completed_events{$id} if $debug;
	delete $pending_events{$id};
      } else {
	my $dt = $now - $t;
	printf STDERR "\nEVENT %s (%.2f) fired at %.2f (%s)\n", $id, $t, $now, ($dt < 0.01? 'on time': sprintf('%.2f s late', $dt));
	set_sink_volumes($hour, $min, $sec, $deciday, $wday);
	do_event $id;
	$countdown = 0; # force a re-countdown
	$completed_events{$id} = $now;
	delete $pending_events{$id};
      }
    }

    $countdown -= 1;
    $countdown = COUNTDOWN if $countdown < 0;
  }
}

1;
