#!/usr/bin/perl
# vi:set sw=2 ai sm:
# Copyright © 2021–2023 by Ambrose Li

=pod

=encoding utf8

=head1 NAME

chimer – Re-implementation of the Javascript chiming clocks in Perl

=head1 DESCRIPTION

The primary purpose of this script is to avoid running the two chiming clock pages as Firefox tabs,
because Firefox (and Chromium-based browsers) are now unfriendly to pages that primarily use audio for UI.
Firefox also leaks memory really fast so it's best to not keep Firefox running for long periods of time.

Eventually this script might provide a way to make the genmon script less CPU intensive.

=head1 INTERNALS

=cut

# see https://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default for these crazy hacks
# THERE ARE MORE CRAZY HACKS THERE FOR MORE COMPLEX PROJECTS!!
use v5.12; # minimal for unicode string feature
use v5.14; # //u modifier
use utf8;
open qw( :encoding(UTF-8) :std );
use charnames qw( :full :short );
use feature "unicode_strings";

use warnings qw( FATAL utf8 );
use Encode qw( encode decode );
#@ARGV = map { decode("UTF-8", $_) } @ARGV if grep /\P{ASCII}/ => @ARGV;

binmode STDIN, ':utf8';
binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';



use strict;
use integer;


package Debug;
use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype tainted weaken isweak isvstring looks_like_number set_prototype);

sub lazy_sorter ($$) {
  my($a, $b) = @_;
  my $it;
  if ($a =~ /^(.*?)(\d+(?:\.\d+)?)$/s) {
    no integer;
    my($a1, $a2) = ($1, $2);
    if ($b =~ /^(.*?)(\d+(?:\.\d+)?)$/s) {
      my($b1, $b2) = ($1, $2);
      if ($a1 eq $b1 && $a1 =~ /q$/s) {		# q0 = q4 therefore > q3
	$it = ($a2 + 3)%4 <=> ($b2 + 3)%4;
      } else {
	$it = $a1 cmp $b1;
	$it = $a2 <=> $b2 unless $it;
      }
    }
  }
  $it = $a cmp $b unless defined $it && $it;
  return $it;
}

sub cvs ($) {
  my($s) = @_;
  my $it;
  sub compute_size ($) {
    my($s) = @_;
    my $it;
    if (!defined $s || !ref $s) {
      $it = 1;
    } elsif (ref $s eq 'ARRAY') {
      for my $val (@$s) {
	$it += compute_size($val);
      }
    } else { # hash or object
      $it += 2 unless ref $s eq 'HASH';
      for my $val (values %$s) {
	$it += 1 + compute_size($val);
      }
    }
    return $it;
  }
  sub format_scalar ($) {
    my($it) = @_;
    no integer;
    if (!looks_like_number($it)) {
      $it =~ s/([\\\(\)])/\\\1/sg;
      $it =~ s/(\n)/\\n/sg;
      $it = "($it)";
    }
    return $it;
  }
  sub format_as_name ($) {
    my($s) = @_;
    return $s =~ /^[-\.\w]+$/? "/$s": sprintf('%s cvn', cvs($s));
  }
  sub format_array_inner ($) {
    my($s) = @_;
    my $it;
    if (compute_size($s) <= 12) {	# cf. https://picolisp.com/wiki/?prettyPrint
      $it = join(' ', map { cvs($_) } @$s);
    } else {
      my @s = @$s;
      $it = cvs($s[0]) . "\n   " . format_array_inner([@s[1..$#s]]);
    }
    return $it;
  }
  sub format_hash ($) {
    my($s) = @_;
    my @keys = sort { lazy_sorter($a, $b) } keys %$s;
    my @size;
    my $it;
    for (my $i = $#keys; $i >= 0; $i -= 1) {
      my $key = $keys[$i];
      $size[$i] = compute_size($key) + compute_size($s->{$key});
      $size[$i] += $size[$i + 1] if $i < $#keys;
    }
    for (my $i = 0; $i < @keys; $i += 1) {
      my $key = $keys[$i];
      $it .= ($size[$i] <= 12? ' ': "\n") if defined $it;
      $it .= sprintf('%s %s', format_as_name $key, cvs($s->{$key}));
    }
    return "<<$it>>";
  }
  if (!defined $s) {
    $it = 'null';
  } elsif (ref $s eq 'ARRAY') {
    $it = sprintf('[%s]', format_array_inner($s));
  } elsif (ref $s eq 'HASH') {
    $it = format_hash $s;
  } elsif (!ref $s) {
    $it = format_scalar $s;
  } else { # object :-/
    $it = sprintf '%s %s bless', format_hash $s, format_as_name ref $s;
  }
  return $it;
}


package Interpret_Melody_State;
no integer;

sub unit_beat {
  my $self = shift;
  $self->{'unit-beat'} = shift if @_;
  return $self->{'unit-beat'};
}

sub tempo {
  my $self = shift;
  if (@_ && defined $_[0]) {
    my($divisor, $beats_per_minute) = ref $_[0]? @{$_[0]}: @_;
    $self->{'tempo'} = [$divisor, $beats_per_minute];
    $self->unit_beat(($divisor*60)/(4*$beats_per_minute));
  }
  return wantarray? @{$self->{'tempo'}}: $self->{'tempo'};
}

sub relative_p {
  my $self = shift;
  $self->{'relative-p'} = shift if @_;
  return $self->{'relative-p'};
}

sub drummode_p {
  my $self = shift;
  $self->{'drummode-p'} = shift if @_;
  return $self->{'drummode-p'};
}

sub home_position {
  my $self = shift;
  $self->{'home-position'} = shift if @_;
  return $self->{'home-position'};
}

sub repeat_start {
  my $self = shift;
  $self->{'repeat-start'} = shift if @_;
  return $self->{'repeat-start'};
}

sub repeat_count {
  my $self = shift;
  $self->{'repeat-count'} = shift if @_;
  return $self->{'repeat-count'};
}

sub repeat_stacklevel {
  my $self = shift;
  $self->{'repeat-stacklevel'} = shift if @_;
  return $self->{'repeat-stacklevel'};
}

sub stacklevel {
  my $self = shift;
  return scalar @{$self->{'stack'}};
}

sub transpose {
  my $self = shift;
  $self->{'transpose'} = shift if @_; # FIXME?
  return $self->{'transpose'};
}

sub new {
  my $class = shift;
  my $self = {};
  bless $self, $class;
  $self->unit_beat(1);
  $self->relative_p(0);
  $self->drummode_p(0);
  $self->transpose(0);
  $self->{'stack'} = [];
  return $self;
}

sub gsave {
  my $self = shift;
  my $tempo = $self->tempo();
  my $unit_beat = $self->unit_beat();
  my $relative_p = $self->relative_p();
  my $drummode_p = $self->drummode_p();
  my $home_position = $self->home_position();
  my $transpose = $self->transpose();
  my $repeat_stacklevel = $self->repeat_stacklevel();
  my $repeat_start = $self->repeat_start();
  my $repeat_count = $self->repeat_count();
  push @{$self->{'stack'}}, [$tempo, $unit_beat, $relative_p, $drummode_p, $home_position, $transpose,
			    $repeat_stacklevel, $repeat_start, $repeat_count];
}

sub grestore {
  my $self = shift;
  if (@{$self->{'stack'}}) {
    my                      ($tempo, $unit_beat, $relative_p, $drummode_p, $home_position, $transpose,
			      $repeat_stacklevel, $repeat_start, $repeat_count)
	= @{ pop @{$self->{'stack'}} };

    $self->tempo		($tempo);		# tempo must be restored first because setting it changes unit_beat
    $self->unit_beat		($unit_beat);
    $self->relative_p		($relative_p);
    $self->drummode_p		($drummode_p);
    $self->home_position	($home_position);
    $self->transpose		($transpose);
    $self->repeat_stacklevel	($repeat_stacklevel);
    $self->repeat_start		($repeat_start);
    $self->repeat_count		($repeat_count);
  } else {
    my $comment = sprintf(' (context: %s)', Debug::cvs($1)) if @_ && $_[0] =~ /^(.[^\n]*)/s;
    die "grestore called but stack is empty$comment";
  }
}


package Latency;
no integer;
use Time::HiRes;

sub MAX_LATENCIES_REMEMBERED () { 32 }
sub MAX_ERRORS_REMEMBERED    () { 64 }

sub get_cpu_count () {
  state $it;
  my $input = '/proc/cpuinfo';
  if (!defined $it && open(INPUT, '<', $input)) {	# probably not Linux if we can't open it
    for (;;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      $it += 1 if $s =~ /^processor\s*:/s;		# don't grep for "cpu cores" because some archs don't do that
    }
    close INPUT;
  }
  return $it;
}

sub get_loadavg () {
  my $it;
  my $input = '/proc/loadavg';
  if (open(INPUT, '<', $input)) {			# probably not Linux if we can't open it
    my $s = scalar <INPUT>;
    no integer;
    $it = $1 + 0 if $s =~ /^(\d+\.\d+)\s/s;
    close INPUT;
  }
  return $it;
}

sub register_error {
  my $self = shift;
  my($method, $delta) = @_;
  $self->{'errors'}->{$method} = [] unless defined $self->{'errors'}->{$method};
  push @{$self->{'errors'}->{$method}}, $delta;
  shift @{$self->{'errors'}->{$method}} while scalar @{$self->{'errors'}->{$method}} > MAX_ERRORS_REMEMBERED;
}

sub remember {
  my $self = shift;
  my($latency, $tag) = @_;
  my $node = {
      'latency' => $latency,
      't' => Time::HiRes::time,
    };
  $node->{'tag'} = $tag if defined $tag;
  my $loadavg = get_loadavg;
  if (defined $loadavg) {
    $node->{'loadavg'} = $loadavg;
  }
  if (defined $self->{'predictions'}) {
    foreach my $method (keys %{$self->{'predictions'}}) {
      $self->register_error($method, $latency - $self->{'predictions'}->{$method});
    }
    $self->{'predictions'} = undef;
  }
  push @{$self->{'latencies'}}, $node;
  shift @{$self->{'latencies'}} while scalar @{$self->{'latencies'}} > MAX_LATENCIES_REMEMBERED;
}

sub has_usable_measurements_p {
  my $self = shift;
  my $loadavg = get_loadavg;
  my $it;
  if (defined $loadavg) {
    for my $latency (@{$self->{'latencies'}}) {
      $it = 1 if abs($loadavg - $latency->{'loadavg'}) < 5;	# XXX
    last if defined $it;
    }
    $it = 0 unless defined $it;
  } else {
    # We have no way to tell. Just say yes.
    $it = '0 but true';
  }
  return $it;
}

sub summation (@) {
   my(@x) = @_;
   my $it = 0;
   foreach my $x_i (@x) {
      $it += $x_i;
   }
   return $it;
}

sub error_estimate {
  my $self = shift;
  my($method) = @_;
  my $deltas =  $self->{'errors'}->{$method} if defined $self->{'errors'}->{$method};
  return defined $deltas && @$deltas? summation(map { abs $_ } @$deltas)/scalar(@$deltas): undef;
}

sub predict_via_exponential_curve_fitting (\@$$) {
  my($latencies, $loadavg, $t) = @_;
  my $it;
  if (@$latencies > 2 && defined $loadavg) {
    no integer;
    # Assume latency is exponentially related to loadavg
    my($a, $b);
    my $f = sub { my($x) = @_; $a * exp($b * $x) }; # log f = $b * $x + log($a)
    # But simplify the approximation using log f (cf. p. 429 in my numerical methods textbook)
    # not because the simplication is sound but because my numerical skills are not up to par
    my $m = @$latencies;
    my @x = map { $_->{'loadavg'} } @$latencies;
    my @y = map { $_->{'latency'} } @$latencies;
    my @i = 0..($m - 1);
    my $denominator = ($m * summation(map { $x[$_]**2 } @i) - summation(@x)**2);
    if ($denominator) {
      $b = ($m * summation(map { $x[$_]*$y[$_] } @i) - summation(@x) * summation(@y)) / $denominator;
      $a = (summation(@x) * summation(@y) - summation(map { $x[$_] * $y[$_] } @i) * summation(@x)) / $denominator;
      $a = exp($a);
      $it = &$f($loadavg);
    }
  }
  return $it;
}

sub predict_via_polynomial_curve_fitting (\@$$) {
  my($latencies, $loadavg, $t) = @_;
  my $it;
  if (@$latencies > 2 && defined $loadavg) {
    no integer;
    # Assume latency is quadratically related to loadavg
    my($a, $b);
    my $f = sub { my($x) = @_; $a * $x + $b };
    my $m = @$latencies;
    my @x = map { $_->{'loadavg'} } @$latencies;
    my @y = map { $_->{'latency'} } @$latencies;
    my @i = 0..($m - 1);
    my $denominator = ($m * summation(map { $x[$_]**2 } @i) - summation(@x)**2);
    if ($denominator) {
      $a = ($m * summation(map { $x[$_]*$y[$_] } @i) - summation(@x) * summation(@y)) / $denominator;
      $b = (summation(@x) * summation(@y) - summation(map { $x[$_] * $y[$_] } @i) * summation(@x)) / $denominator;
      $it = &$f($loadavg);
    }
  }
  return $it;
}

sub predict_via_averaging (\@$$) {
  my($latencies, $loadavg, $t) = @_;
  my $it;
  if (@$latencies) {
    no integer;
    my $m = @$latencies;
    my @y = map { $_->{'latency'} } @$latencies;
    $it = summation(@y)/$m;
  }
  return $it;
}

sub predict_via_weighted_averaging (\@$$) {
  my($latencies, $loadavg, $t) = @_;
  my $it;
  if (@$latencies && defined $loadavg) {
    no integer;
    state $k = 2**0.125;
    my $m = @$latencies;
    my @y = map { $_->{'latency'} * 2**($loadavg - $_->{'loadavg'}) } @$latencies;
    $it = summation(@y)/$m;
  }
  return $it;
}

sub predict_from_loadavg {
  my $self = shift;
  my($loadavg) = @_;
  my $prediction_method;
  my $it;
  my $t = Time::HiRes::time;
  my @latencies = @{$self->{'latencies'}};
  my %candidates;

  # Calculate candidates predictions
  # Exponential and polynomial sound like good ideas, but they actually give wildly inaccurate predictions
  #$candidates{'exponential curve fitting'} = predict_via_exponential_curve_fitting(@latencies, $loadavg, $t);
  #$candidates{'polynomial curve fitting'} = predict_via_polynomial_curve_fitting(@latencies, $loadavg, $t);
  $candidates{'weighted-averaging'} = predict_via_weighted_averaging(@latencies, $loadavg, $t);
  $candidates{'averaging'} = predict_via_averaging(@latencies, $loadavg, $t);

  # Remove candidates that returned no results
  for my $method (keys %candidates) {
    delete $candidates{$method} unless defined $candidates{$method};
  }

  # Remove candidates that look implausible
  for my $method (keys %candidates) {
    if ($method ne 'averaging' && $candidates{$method} > 15) {
      Chimer::log_debug(sprintf 'implausible candidate %s from %s removed from consideration', Debug::cvs($candidates{$method}), $method)
	  if (defined $Chimer::verbose_p && $Chimer::verbose_p > 1) || (defined $Chimer::debug && $Chimer::debug > 1);
      delete $candidates{$method};
    }
  }
  Chimer::log_debug(sprintf 'remaining candidates: %s', Debug::cvs(\%candidates))
      if (defined $Chimer::verbose_p && $Chimer::verbose_p > 1) || (defined $Chimer::debug && $Chimer::debug > 1);

  # Choose "best" prediction from candidates
  if (keys %candidates == 1) {
    ($prediction_method, $it) = %candidates;
    Chimer::log_debug(sprintf 'prediction %s from %s used because it was the only candidate', Debug::cvs(\@latencies), $prediction_method)
	  if (defined $Chimer::verbose_p && $Chimer::verbose_p > 1) || (defined $Chimer::debug && $Chimer::debug > 1);
  } elsif (%candidates) {
    my @scores = sort { $a->{'error'} <=> $b->{'error'} } map { { 'method' => $_, 'error' => $self->error_estimate($_) } } keys %candidates;
    $prediction_method = $scores[0]->{'method'};
    $it = $candidates{$prediction_method};
    Chimer::log_debug(sprintf 'prediction %s from %s used because it looks historically accurate', Debug::cvs(\@latencies), $prediction_method)
	  if (defined $Chimer::verbose_p && $Chimer::verbose_p > 1) || (defined $Chimer::debug && $Chimer::debug > 1);
  } else {
    Chimer::log_debug(sprintf 'insufficient data to predict latency from %s', Debug::cvs(\@latencies))
	  if (defined $Chimer::verbose_p && $Chimer::verbose_p > 1) || (defined $Chimer::debug && $Chimer::debug > 1);
  }
  $self->{'predictions'} = \%candidates;
  return wantarray? ($it, $prediction_method): $it;
}

sub predict {
  my $self = shift;
  return $self->predict_from_loadavg(get_loadavg);
}

sub tag {
  my $self = shift;
  $self->{'tag'} = shift if @_;
  return $self->{'tag'};
}                                                                                                                                                    

sub new {
  my $class = shift;
  my($latency, $tag) = @_;
  my $self = {};
  bless $self, $class;
  $self->remember($latency, $tag) if defined $latency;
  return $self;
}


package Synth;
use feature 'signatures';
no warnings 'experimental::signatures';


package Chime_Id;
use feature 'signatures';
no warnings 'experimental::signatures';

sub new ($class, $id = undef) {
  my $self = {
      'implementation' => [],
    };
  $self->{'id'} = $id if defined $id;
  bless $self, $class;
  return $self;
}

sub id ($self, $id = undef) {
  my $it = $self;
  if (defined $id) {
    $self->{'id'} = $id;
  } else {
    $it = $self->{'id'};
  }
  return $it;
}

sub mode ($self, $mode = undef) {
  my $it = $self;
  if (defined $mode) {
    $self->{'mode'} = $mode;
  } else {
    $it = $self->{'mode'};
  }
  return $it;
}

sub melody ($self, $melody = undef) {
  my $it = $self;
  if (defined $melody) {
    $self->{'melody'} = $melody;
  } else {
    $it = $self->{'melody'};
  }
  return $it;
}

sub implementation ($self) {
  return $self->{'implementation'};
}

sub count ($self) {
  return scalar @{$self->implementation};
}

sub prepend ($self, $event) {
  unshift @{$self->implementation}, $event;
  return $self;
}

sub append ($self, $event) {
  push @{$self->implementation}, $event;
  return $self;
}


package Event_List;
use feature 'signatures';
no warnings 'experimental::signatures';

sub new ($class) {
  my $self = {
      'events' => [],
    };
  bless $self, $class;
  return $self;
}

sub value ($self) {
  return $self->{'events'};
}

sub count ($self) {
  return scalar @{$self->value};
}

sub prepend ($self, $event) {
  unshift @{$self->value}, $event;
  return $self;
}

sub append ($self, $event) {
  push @{$self->value}, $event;
  return $self;
}

sub id ($self) {
  return join(',', map { $_->id } @{$self->value});
}

sub t ($self) {
  return $self->value->[0]->t if @{$self->value};
}

sub delay ($self) {
  return $self->value->[0]->delay if @{$self->value};
}

sub type ($self) {
  my $it;
  for my $node (@{$self->value}) {
    $it = $node->type if defined $node->type && $node->type !~ /^(?:pre|post)/;
  last if defined $it;
  }
  return $it;
}


package Event;
use feature 'signatures';
no warnings 'experimental::signatures';

sub new ($class, $t, $delta, $id, $type, $comment = undef) {
  my $self = {
	't' => $t,
	'delta' => $delta,
	'id' => $id,
	'type' => $type,
    };
  $self->{'comment'} = $comment if defined $comment;
  $self->{'anticipating'} = -$delta if defined $delta && $delta < 0;
  bless $self, $class;
  return $self;
}

sub t ($self) {
  return $self->{'t'} + $self->{'delta'};
}

sub id ($self) {
  return $self->{'id'};
}

sub type ($self) {
  return $self->{'type'};
}

sub hour ($self) {
  return (localtime $self->t)[2];
}

sub minute ($self) {
  return (localtime $self->t)[1];
}

sub delay ($self) {
  return $self->{'delay'};
}


package Event::Quarter::Half;
use vars qw( @ISA @EXPORT @EXPORT_OK );
@ISA = qw(Event::Quarter Exporter);
use feature 'signatures';
no warnings 'experimental::signatures';

sub new ($class, $t, $delta, $half_quarter_number) {
  $half_quarter_number = 0 if $half_quarter_number == 8;
  my($id, $type);
  my($sec, $min, $hour) = localtime $t;
  my $hour12 = $hour%12;
  $hour12 = 12 unless $hour12;
  if ($delta == 0 && $half_quarter_number == 0) {
    $id = "h$hour12";
    $type = 'hour';
  } elsif ($delta == 0 && $half_quarter_number == 4) {
    $id = sprintf('halb%d', $hour12%12 + 1);
    $type = 'half-hour';
  } elsif ($delta < 0 && $half_quarter_number%2) {
    $id = "e$half_quarter_number";
    $type = 'half quarter';
  } elsif ($delta < 0) {
    $id = sprintf('q%d', $half_quarter_number/2);
    $type = 'quarter';
  } elsif ($delta > 0 && $half_quarter_number == 0) {
    $id = "posth$hour12";
    $type = 'post-quarter';
  } elsif ($delta > 0 && $half_quarter_number == 4) {
    $id = sprintf('posthalb%d', $hour12%12 + 1);
    $type = 'post-quarter';
  } else {
    die "Event::Quarter::Half->new: Unhandled case delta = $delta, half_quarter_number = $half_quarter_number\n";
  }
  return new Event($t, $delta, $id, $type);
}


package Event::Quarter;
use vars qw( @ISA @EXPORT @EXPORT_OK );
@ISA = qw(Event Exporter);
use feature 'signatures';
no warnings 'experimental::signatures';

sub new ($class, $t, $delta, $quarter_number) {
  return new Event::Quarter::Half($t, $delta, 2*$quarter_number);
}


package Event::Watch;
use vars qw( @ISA @EXPORT @EXPORT_OK );
@ISA = qw(Event Exporter);
use feature 'signatures';
no warnings 'experimental::signatures';

sub new ($class, $t, $watch_number, $subwatch_number) {
  my $id = "w$watch_number.$subwatch_number";
  return new Event($t, undef, $id, 'quarter');
}


package Chimer;

use POSIX;
use POSIX ":sys_wait_h"; # for nonblocking read
use DateTime;
use Time::HiRes; # overrides (qw) do not seem to work
use Expect::Simple;
no feature 'signatures';

use Exporter;
require Exporter;
use vars qw( @ISA @EXPORT @EXPORT_OK );
@ISA = qw(Exporter);
@EXPORT_OK = qw( $dow_re $dow_range_re %expressive_mark_to_midi_velocity );

use vars qw( @restart_cmd );
@restart_cmd = ($0, @ARGV); # save this because GetOpt will clear @ARGV

use vars qw( $user_agent );
$user_agent = 'Chiming clock';

use vars qw( $use_datetime_event_sunrise );
use vars qw( $use_datetime_astro_sunrise );
use vars qw( $use_astro_sunrise );
use vars qw( $sunrise_module );
use vars qw( $sunrise_module_version );
BEGIN {
  if (eval { require DateTime::Event::Sunrise; }) {
    $sunrise_module = 'DateTime::Event::Sunrise';
    $sunrise_module_version = DateTime::Event::Sunrise->VERSION if defined DateTime::Event::Sunrise->VERSION;
    $use_datetime_event_sunrise = 1;
  } elsif (eval { require DateTime::Astro::Sunrise; }) {
    $sunrise_module = 'DateTime::Astro::Sunrise';
    $sunrise_module_version = DateTime::Astro::Sunrise->VERSION if defined DateTime::Astro::Sunrise->VERSION;
    $use_datetime_astro_sunrise = 1;
  } elsif (eval { require Astro::Sunrise; }) {
    $sunrise_module = 'Astro::Sunrise';
    $sunrise_module_version = Astro::Sunrise->VERSION if defined Astro::Sunrise->VERSION;
    $use_astro_sunrise = 1;
  } else {
    die "Cannot find a usable Sunrise package";
  }
}

use Getopt::Long;
use Data::Dumper;

use vars qw( $config );
use vars qw( $overrides );
use vars qw( $debug );
use vars qw( $no_cache_p $create_cache_p $test_p );
use vars qw( $latent_action );
use vars qw( $verbose_p );
use vars qw( $quit_p );
use vars qw( $enable_nonproportional_watches );
use vars qw( $enable_qing_quarters );

use vars qw( $coords );
use vars qw( $lat $lon );
use vars qw( $use_jack_p );
use vars qw( @sinks );
use vars qw( $synth );
use vars qw( %children );
use vars qw( %expected_latency );

use vars qw( $wood_note );
use vars qw( %instrument_name_to_channel_number );
use vars qw( %instrument_name_to_mf_velocity );
use vars qw( $fluidR3 );
$fluidR3 = '/usr/share/sounds/sf2/FluidR3_GM.sf2';

use vars qw( $beat_length );
$beat_length = 1;

use vars qw( $boottime );
$boottime = Time::HiRes::time;

use vars qw( $time_displacement );
sub current_time () { no integer; Time::HiRes::time + $time_displacement }

use vars qw( $basedir $datadir );
$basedir = $1 if $0 =~ /^(.*?)\/+[^\/]+$/;
$basedir =~ s/(?:^|\/+)bin$//;
$basedir = '.' if $basedir eq '';
$datadir = "$basedir/data";

# number of times we try sleeping for 1 second until we sleep until the target event
sub COUNTDOWN () { 5 } # things stablize after 2-3 times, we do 5 just in case (10 is overkill)

# number of seconds to sleep before we disconnect the synth - from observation this must be at least 6
sub SECONDS_BEFORE_DISCONNECT () { 7 }

sub MODE__SYSLINE   () { 'sysline' }
sub MODE__CUCKOO    () { 'cuckoo' }
sub MODE__CARILLON  () { 'carillon' }
sub METHOD__SAMPLES () { 'samples' }
sub METHOD__SYNTH   () { 'synth' }

sub MELODY__ABBEY         () { 'abbey' }
sub MELODY__CAMBRIDGE     () { 'cambridge' }
sub MELODY__CAMBRIDGE_RCC () { 'cambridge_rcc' }
sub MELODY__CANTERBURY    () { 'canterbury' }
sub MELODY__GUILDFORD     () { 'guildford' }
sub MELODY__MAGDALEN      () { 'magdalen' }
sub MELODY__NEWCOLLEGE    () { 'newcollege' }
sub MELODY__NORWICH       () { 'norwich' }
sub MELODY__TINGTANG2A    () { 'tingtang2a' }
sub MELODY__TINGTANG2B    () { 'tingtang2b' }
sub MELODY__TINGTANG3A    () { 'tingtang3a' }
sub MELODY__TINGTANG3B    () { 'tingtang3b' }
sub MELODY__TINGTANG4     () { 'tingtang4' }
sub MELODY__TINGTANG5     () { 'tingtang5' }
sub MELODY__WESTMINSTER   () { 'westminster' }
sub MELODY__WHITTINGTON   () { 'whittington' }
sub MELODY__WHITTINGTON11 () { 'whittington11' }

sub MELODY__TORONTO       () { 'toronto' }

use vars qw( $mode $method $melody );
$mode   = MODE__CARILLON;
$method = METHOD__SAMPLES;
$melody = MELODY__WESTMINSTER;

use vars qw( %alias_to_canonical_instrument );
%alias_to_canonical_instrument = (
  'Keyboard'	=> 'Piano',
  'Carillon'	=> 'Bell',
  'Chimes'	=> 'Church Bells',
);

use vars qw( %laisser_vibrer_p );
%laisser_vibrer_p = (
  'Bell'	=> 1,
  'Gong'	=> 1,
);

# night watch chime patterns
sub LONG_STRIKE  () { 1.5 }
sub SHORT_STRIKE () { 0.5 }
sub GAP          () { 2.5 }
# watch chime patterns: repetitions, pattern
# gap needs to be long enough to hear it, but short enough to not mistake it for a long strike. This is HARD
use vars qw( @watch_chime_pattern );
@watch_chime_pattern = ( # v. https://zh.wikipedia.org/wiki/打更 (q.v.)
   [3, '— .'		],
   [2, '. .'		],
   [3, '— . .'		],
   [4, '— . . .'	],
   [5, '— . . . .'	],
);

use vars qw( @midi_number_to_note %note_to_midi_number );
@midi_number_to_note = (
  'c0', 'c#0', 'd0', 'd#0', 'e0', 'f0', 'f#0', 'g0', 'g#0', 'a0', 'a#0', 'b0',
  'c1', 'c#1', 'd1', 'd#1', 'e1', 'f1', 'f#1', 'g1', 'g#1', 'a1', 'a#1', 'b1',
  'c2', 'c#2', 'd2', 'd#2', 'e2', 'f2', 'f#2', 'g2', 'g#2', 'a2', 'a#2', 'b2',
  'c3', 'c#3', 'd3', 'd#3', 'e3', 'f3', 'f#3', 'g3', 'g#3', 'a3', 'a#3', 'b3',
  'c4', 'c#4', 'd4', 'd#4', 'e4', 'f4', 'f#4', 'g4', 'g#4', 'a4', 'a#4', 'b4',
  'c5', 'c#5', 'd5', 'd#5', 'e5', 'f5', 'f#5', 'g5', 'g#5', 'a5', 'a#5', 'b5',
  'c6', 'c#6', 'd6', 'd#6', 'e6', 'f6', 'f#6', 'g6', 'g#6', 'a6', 'a#6', 'b6',
  'c7', 'c#7', 'd7', 'd#7', 'e7', 'f7', 'f#7', 'g7', 'g#7', 'a7', 'a#7', 'b7',
  'c8', 'c#8', 'd8', 'd#8', 'e8', 'f8', 'f#8', 'g8', 'g#8', 'a8', 'a#8', 'b8',
  'c9', 'c#9', 'd9', 'd#9', 'e9', 'f9', 'f#9', 'g9', 'g#9', 'a9', 'a#9', 'b9',
);
%note_to_midi_number = map { $midi_number_to_note[$_] => $_ } 0..$#midi_number_to_note;

use vars qw( %gong_scale %chime_scale );
%gong_scale = (
  'c4'	=> '582141__strangehorizon__g01-c-4-gong.wav',
  'c#4'	=> '582140__strangehorizon__g02-c-4-gong.wav',
  'd4'	=> '582139__strangehorizon__g03-d-4-gong.wav',
  'd#4'	=> '582138__strangehorizon__g04-d-4-gong.wav',
  'e4'	=> '582145__strangehorizon__g05-e-4-gong.wav',
  'f4'	=> '582144__strangehorizon__g06-f-4-gong.wav',
  'f#4'	=> '582143__strangehorizon__g07-f-4-gong.wav',
  'g4'	=> '582142__strangehorizon__g08-g-4-gong.wav',
  'g#4'	=> '582147__strangehorizon__g09-g-4-gong.wav',
  'a4'	=> '582146__strangehorizon__g10-a-4-gong.wav',
  'a#4'	=> '582156__strangehorizon__g11-a-4-gong.wav',
  'b4'	=> '582155__strangehorizon__g12-b-4-gong.wav',
  'c5'	=> '582154__strangehorizon__g13-c-5-gong.wav',
  'c#5'	=> '582153__strangehorizon__g14-c-5-gong.wav',
  'd5'	=> '582160__strangehorizon__g15-d-5-gong.wav',
  'd#5'	=> '582159__strangehorizon__g16-d-5-gong.wav',
  'e5'	=> '582158__strangehorizon__g17-e-5-gong.wav',
  'f5'	=> '582157__strangehorizon__g18-f-5-gong.wav',
  'f#5'	=> '582162__strangehorizon__g19-f-5-gong.wav',
  'g5'	=> '582161__strangehorizon__g20-g-5-gong.wav',
);
%chime_scale = (
  'c4'	=> 'chimes_C1.ogg',
  'c#4'	=> 'chimes_C#1.ogg',
  'd4'	=> 'chimes_D1.ogg',
  'd#4'	=> 'chimes_D#1.ogg',
  'e4'	=> 'chimes_E1.ogg',
  'f4'	=> 'chimes_F1.ogg',
  'f#4'	=> 'chimes_F#1.ogg',
  'g4'	=> 'chimes_G1.ogg',
  'g#4'	=> 'chimes_G#1.ogg',
  'a4'	=> 'chimes_A1.ogg',
  'a#4'	=> 'chimes_A#1.ogg',
  'b4'	=> 'chimes_B1.ogg',
  'c5'	=> 'chimes_C2.ogg',
  'c#5'	=> 'chimes_C#2.ogg',
  'd5'	=> 'chimes_D2.ogg',
  'd#5'	=> 'chimes_D#2.ogg',
  'e5'	=> 'chimes_E2.ogg',
  'f5'	=> 'chimes_F2.ogg',
);

sub gensym () {
  state $n;
  return sprintf('g%d', $n++);
}

sub log_internal ($$;$$$) {
  my($flag, $s, $prefix, $newline_p, $keep_p) = @_;
  state $last_logged;
  my $daemon_p = !-t STDERR;
  $newline_p = 1 if $s =~ s/^\n+//s;
  $newline_p = 0 unless defined $last_logged;
  $newline_p = 1 if defined $last_logged && $last_logged->{'keep'};
  $newline_p = 0 if $daemon_p;
  my $cleol_p = !$daemon_p && !$newline_p;
  $keep_p = 1 if $debug;
  $prefix .= ': ' if defined $prefix && $prefix =~ /\S/s && $prefix !~ /: $/s;
  chomp $s;
  printf STDERR "%s%10.2f%s\t%s%s%s%s", ($newline_p? "\n": ''),
      current_time, $flag, $prefix, $s, ($cleol_p? "\033[K": ''), ($daemon_p? "\n": "\r");

  $last_logged->{'keep'} = $keep_p + 0;
}

sub log_input   ($) { log_internal '<', $_[0] }
sub log_output  ($) { log_internal '>', $_[0] }
sub log_comment ($) { log_internal '#', $_[0] }
sub log_debug   ($) { log_internal '#', $_[0], 'DEBUG', 1, 1 }
sub log_info    ($) { log_internal '#', $_[0], undef,   0, 1 }
sub log_error   ($) { log_internal '#', $_[0], 'ERROR', 1, 1 }
sub log_warning ($) { log_internal '#', $_[0], 'WARNING', 1, 1 }
sub log_command (@) { log_debug 'running: '. join(' ', map { s/([\\"])/\\\1/sg if /\s/; /\s|^$/? "\"$_\"": $_ } @_) }


=pod

=head2 Chime melodies

Each chime melody is internally represented as an array of
B<[>I<midi note name>, I<time in seconds>, I<percentage volume>, I<instrument>B<]> entries
(I<instrument> can be undef),
but written as calls to I<define_event> which takes 3 parameters –
the identifier for the mode,
the identifier for the melody,
a string containing any definitions (in the form S<I<var> = I<some definition>>) –
plus a list of key-value pairs.
Valid keys are B<q1> for first-quarter chimes,
B<q2> for second-quarter chimes,
B<q3> for third-quarter chimes,
B<q0> for fourth-quarter chimes,
and B<h> for the hour strike.

As many definitions as needed can be included, but each definition I<must> be of the form of either of

=over

I<var> = B<\relative> I<pitch> B<{> I<melody> B<}>

I<var> = B<\drums> B<{> I<melody> B<}>

I<var> B<{> I<tempo or some other initialization> B<}>

=back

The values are written in LilyPond notation
(in either relative pitch or drum mode, optionally including note lengths and basic expressive marks),
described in

=over

Relative Octave Entry. (n.d.). In I<LilyPond — Notation Reference v2.22.1 (stable-branch)>.
Retrieved August 18, 2021, from http://lilypond.org/doc/v2.22/Documentation/notation/writing-pitches#relative-octave-entry

Percussion notes. (n.d.). In I<LilyPond — Notation Reference v2.22.1 (stable-branch)>.
Retrieved August 20, 2021, from http://lilypond.org/doc/v2.22/Documentation/notation/percussion-notes

=back

For the hour strike, you should normally use B<%I> for represent the hour
so that you can strike the bell the correct number of times
(you should of course omit B<%I> for I<sysline> mode
or for ancient ting-tang quarters that always strike the hour strike once).

I<event_def> calls I<interpret_melody> to convert this notation into the internal representation described above,
but this conversion is just a simple pattern match and therefore can produce incorrect results.
If results are incorrect but the notation typesets correctly in LilyPond, the bug is in I<interpret_melody>.

The mapping between Lilypond expressive marks and MIDI velocities is based on

=over

Yamaha. (n.d.). I<Everything You've Ever Wanted to Know About Using MIDI with a Disklavier>.
Yamaha Disklavier Education Network.
Retrieved August 19, 2021, from https://www.yamahaden.com/easyblog/entry/everything-you-ve-ever-wanted-to-know-about-using-midi-with-a-disklavier

Vandenneucker, D.Z<Dominique> (2012). MIDI tutorial.
Retrieved September 5, 2021, from http://www.music-software-development.com/midi-tutorial.html

=back

The mapping between Lilypond percussion notes and MIDI percussion notes is based on

=over

General MIDI instrument codes. (n.d.).
Retrieved August 20, 2021, from http://www.ccarh.org/courses/253/handout/gminstruments/

=back

=cut

use vars qw( %ly_notes );
%ly_notes = (
  'ces' => -1, 'c' => 0, 'cis' => 1,
  'des' => 1, 'd' => 2, 'dis' => 3,
  'ees' => 3, 'e' => 4, 'eis' => 5,
  'fes' => 4, 'f' => 5, 'fis' => 6,
  'ges' => 6, 'g' => 7, 'gis' => 8,
  'aes' => 8, 'a' => 9, 'ais' => 10,
  'bes' => 10, 'b' => 11, 'bis' => 12,
);
use vars qw( %percussion_note_to_midi_number );
%percussion_note_to_midi_number = (
  'bassdrum'		=> 36,		'bd'	=> 36,
  'acousticbassdrum'	=> 35,		'bda'	=> 35,
  'snare'		=> 38,		'sn'	=> 38,		# arbitrarily map to sna
  'acousticsnare'	=> 38,		'sna'	=> 38,
  'electricsnare'	=> 40,		'sne'	=> 40,
  'lowfloortom'		=> 41,		'tomfl'	=> 41,
  'highfloortom'	=> 43,		'tomfh'	=> 43,
  'lowtom'		=> 45,		'toml'	=> 45,
  'hightom'		=> 50,		'tomh'	=> 50,
  'lowmidtom'		=> 47,		'tomml'	=> 47,
  'himidtom'		=> 48,		'tommh'	=> 48,
  'highhat'		=> 44,		'hh'	=> 44,		# arbitrarily map to hhp
  'closedhighhat'	=> 42,		'hhc'	=> 42,
  'openhighhat'		=> 46,		'hho'	=> 46,
  'halfopenhighhat'	=> undef,	'hhho'	=> undef,	# don't know how to map
  'pedalhighhat'	=> 44,		'hhp'	=> 44,
  'crashcymbal'		=> 49,		'cymc'	=> 49,		# arbitrarily map to cymca
  'crashcymbala'	=> 49,		'cymca'	=> 49,
  'crashcymbalb'	=> 57,		'cymcb'	=> 57,
  'ridecymbal'		=> 51,		'cymr'	=> 51,		# arbitrarily map to cymra
  'ridecymbala'		=> 51,		'cymra'	=> 51,
  'ridecymbalb'		=> 59,		'cymrb'	=> 59,
  'chinesecymbal'	=> 52,		'cymch'	=> 52,
  'splashcymbal'	=> 55,		'cyms'	=> 55,
  'ridebell'		=> 53,		'rb'	=> 53,
  'cowbell'		=> 56,		'cb'	=> 56,
  'hibongo'		=> 60,		'boh'	=> 60,
  'openhibongo'		=> undef,	'boho'	=> undef,	# don't know how to map
  'muteopenhibongo'	=> undef,	'bohm'	=> undef,	# don't know how to map
  'lobongo'		=> 61,		'bol'	=> 61,
  'openlobongo'		=> undef,	'bolo'	=> undef,	# don't know how to map
  'muteopenlobongo'	=> undef,	'bolm'	=> undef,	# don't know how to map
  'hiconga'		=> 63,		'cgh'	=> 63,		# arbitrarily map to cgho
  'openhiconga'		=> 63,		'cgho'	=> 63,
  'mutehiconga'		=> 62,		'cghm'	=> 62,
  'loconga'		=> 64,		'cgl'	=> 64,
  'openloconga'		=> undef,	'cglo'	=> undef,	# don't know how to map
  'muteloconga'		=> undef,	'cglm'	=> undef,	# don't know how to map
  'hitimbale'		=> 65,		'timh'	=> 65,
  'lotimbale'		=> 66,		'timl'	=> 66,
  'hiagogo'		=> 67,		'agh'	=> 67,
  'loagogo'		=> 68,		'agl'	=> 68,
  'sidestick'		=> 37,		'ss'	=> 37,
  'hisidestick'		=> undef,	'ssh'	=> undef,	# don't know how to map
  'losidestick'		=> undef,	'ssl'	=> undef,	# don't know how to map
  'guiro'		=> 73,		'gui'	=> 73,		# arbitrarily map to guis
  'shortguiro'		=> 73,		'guis'	=> 73,
  'longguiro'		=> 74,		'guil'	=> 74,
  'cabasa'		=> 69,		'cab'	=> 69,
  'maracas'		=> 70,		'mar'	=> 70,
  'shortwhistle'	=> 71,		'whs'	=> 71,
  'longwhistle'		=> 72,		'whl'	=> 72,
  'handclap'		=> 39,		'hc'	=> 39,
  'tambourine'		=> 54,		'tamb'	=> 54,
  'vibraslap'		=> 58,		'vibs'	=> 58,
  'tamtam'		=> undef,	'tt'	=> undef,	# no way to map this
  'claves'		=> 75,		'cl'	=> 75,
  'hiwoodblock'		=> 76,		'wbh'	=> 76,
  'lowoodblock'		=> 77,		'wbl'	=> 77,
  'opencuica'		=> 79,		'cuio'	=> 79,
  'mutecuica'		=> 78,		'cuim'	=> 78,
  'triangle'		=> 81,		'tri'	=> 81,		# arbitrarily map to trio
  'opentriangle'	=> 81,		'trio'	=> 81,
  'mutetriangle'	=> 80,		'trim'	=> 80,
  'oneup'		=> undef,	'ua'	=> undef,	# no idea what this is
  'twoup'		=> undef,	'ub'	=> undef,	# no idea what this is
  'threeup'		=> undef,	'uc'	=> undef,	# no idea what this is
  'fourup'		=> undef,	'ud'	=> undef,	# no idea what this is
  'fiveup'		=> undef,	'ue'	=> undef,	# no idea what this is
  'onedown'		=> undef,	'da'	=> undef,	# no idea what this is
  'twodown'		=> undef,	'db'	=> undef,	# no idea what this is
  'threedown'		=> undef,	'dc'	=> undef,	# no idea what this is
  'fourdown'		=> undef,	'dd'	=> undef,	# no idea what this is
  'fivedown'		=> undef,	'de'	=> undef,	# no idea what this is
);
use vars qw( %expressive_mark_to_midi_velocity );
%expressive_mark_to_midi_velocity = (
  'ppppp'	=> 1,
  'pppp'	=> 8,	# this should be 8 according to Vandenneucker (2012)
  'ppp'		=> 20,	# this should be close to 20 according to Yamaha (n.d.), exactly 20 according to Vandenneucker (2012)
  'pp'		=> 31,
  'p'		=> 42,
  'mp'		=> 53,
  'mf'		=> 64,
  'f'		=> 80,
  'ff'		=> 96,
  'fff'		=> 112,	# this should be close to 110 according to Yamaha (n.d.), exactly 112 according to Vandenneucker (2012)
  'ffff'	=> 119,	# this should be 127 according to Vandenneucker (2012)
  'fffff'	=> 127,
);
use vars qw( %interpretation );
use vars qw( %typesettable_version );
use vars qw( %mode_description );
use vars qw( %melody_description );

sub interpret_absolute_pitch ($) { # interpret c' as c4
  my($s) = @_;
  my $it;
  if ($s =~ /^(\w+)(?:(,*)|('*))$/) {
    $it = $ly_notes{$1} + 12*(3 - length($2) + length($3));
  } else {
    die "Can't interpret absolute pitch " . Debug::cvs($s);
  }
  return $it;
}

sub interpret_divisor ($) {
  my($s) = @_;
  no integer;
  return !defined $s? $s: $s =~ /\x{5c}longa/? 0.25: $s =~ /\x{5c}breve/? 0.5: $s =~ /^\d+$/? $s + 0: $s; # XXX
}

sub calculate_beat_length ($$) {
  my($divisor, $dots) = @_;
  no integer;
  my $it = 4 / $divisor;
  for (my $i = $dots, my $adj = $it/2; $i; $i -= 1, $adj /= 2) {
    $it += $adj;
  }
  return $it;
}

my $duration_re = q((?:(\s*\x{5c}longa|\s*\x{5c}breve|\d+)(\.+)?));	# NOTE: 2 captures: divisor, dots
sub interpret_melody ($) {
  my($s0) = @_;
  my $it;
  my $typesettable_version;
  no integer;

  state $rest_re = sprintf('(?:r)');
  state $percussion_instrument_re = sprintf('(?:%s)', join('|', keys %percussion_note_to_midi_number));
  state $pitch_re = q(([a-g](?:[ei]s)?)?(?:(,*)|('*)));				# NOTE: 3 captures: base pitch, commas, apostrophes
  state $pitch_re_no_captures = ($pitch_re =~ s/\x28(?!\?)/\x28?:/sgr);
  state $expressive_mark_re = sprintf("(?:%s)", join('|', keys %expressive_mark_to_midi_velocity));
  state $end_re = q((?=[-\s\x{7d}\x{5e}~()\[\]]|$));				# - or space or braceright or caret or tilde or ()[] or eof

  my $state = new Interpret_Melody_State;
  my($last_pitch, $percussive_instrument);
  my $main_instrument = 'Carillon';
  my($tie_p);
  my($note, $divisor, $dots, $volume) = (undef, 4, 0, $expressive_mark_to_midi_velocity{'mf'});
  my($def_key, $def_value, $def_level, %def);
  my($current_position, $position_at_end_of_last_recording);
  my $grace_note_type;
  my $voice;
  for (my($s, @stack) = ($s0); $s =~ /\S/s; ) {
    unless (defined $def_key) {
      $s =~ s/^\s*//s;
      $typesettable_version .= $&;
    }
    if ($s =~ /^\\([A-Za-z]+)\b/s && defined $def{$1}) {	# expand variables
      my($key) = $1;						# we MUST store this in a variable for the substitution to work
      $s =~ s/^\\$key/$def{$key}/s;
    }
    my $lhs;
    my $directive;
    log_debug sprintf 's=%s', Debug::cvs($s) if $debug > 2;
    if ($s =~ s/^\%[^\n]*\n*//s) {		# percent - comment to always discard
      ;
    } elsif (!defined $def_key && $s =~ s/^([A-Za-z]+)\s*=\s*//s) {
      ($def_key, $def_value, $def_level) = ($1);
    } elsif (defined $def_key) {
      if ($s =~ s/^(\s+)//s) {
	$def_value .= ' ';
      } elsif ($s =~ s/^("[^""]*")//s) {
	$def_value .= $1;
      } elsif ($s =~ s/^((?:\x{7b}|<<))//s) {		# braceleft
	$def_value .= $1;
	$def_level += 1;
      } elsif ($s =~ s/^((?:\x{7d}|>>))//s) {		# braceright
	$def_value .= $1;
	$def_level -= 1;
	if ($def_level == 0) {
	  $def_value = $1 if $def_value =~ /^{\s*(.*?)\s*}$/s;
	  $def{$def_key} = $def_value;
	  ($def_key, $def_value, $def_level) = ();
	}
      } elsif ($s =~ s/^(\S)//s) {
	$def_value .= $1;
      } else {
	log_error "interpret_melody: defined \$def_key reached \"else\" case";
      }

    } elsif ($s =~ s/^\x{7b}\s*//s) {		# braceleft
      $typesettable_version .= $&;
      $state->gsave();

    } elsif ($s =~ s/^<>-\s*//s) {		# ignore empty containers for expressive marks
      $typesettable_version .= $&;

    } elsif ($s =~ s/^<<\s*//s) {		# FIXME
      $typesettable_version .= $&;
      $state->gsave();

    } elsif ($s =~ s/^>>\s*//s) {		# FIXME
      $typesettable_version .= $&;
      $state->grestore($s);

    } elsif ($s =~ s/^[\^_]\\markup\s+//s) {	# ignore markup
      $typesettable_version .= $&;
    } elsif ($s =~ s/^\\(?:halign\s+#\w+|markup|tiny)\s+//s) {	# ignore markup
      $typesettable_version .= $&;

    } elsif ($s =~ s/^#\(\s*play-recording\s+"([^""]+)"\s+(\d+(?:\.\d+)?)\s+(\d+(?:\.\d+)?)(?:\s+(\d+(?:\.\d+)?))?\s*\)\s+//s) { # pseudo-lisp 
      my($filename, $start, $end, $treat_as_this_many_beats) = ($1, $2, $3, $4);
      # Generate pseudo-note directly instead of setting $directive ($directive needs an existing note to act on)
      no integer;
      my $duration = $end - $start;
      my $unit = 4*$state->unit_beat();
      my $unit_beats = $duration/$unit;
      my $quantized_beats = int($unit_beats);
      my @quantized_beats = (1) x $quantized_beats;
      my $remainder = $unit_beats - $quantized_beats;
      for (my $divisor = 2; $divisor < 32; $divisor *= 2) {
	my $adjustment = 1/$divisor;
	if (($remainder * $divisor) & 1) {
	  push @quantized_beats, $divisor;
	  $quantized_beats += $adjustment;
	  $remainder -= $adjustment;
	}
      }
      my $fake_duration = $quantized_beats*$unit;
      $fake_duration = $treat_as_this_many_beats*$state->unit_beat() if defined $treat_as_this_many_beats;
      my $fake_note = ['ua', $fake_duration, $volume, undef, {
	    'directive' => ['play', $filename, $start, $end],
	    'durations' => [@quantized_beats],
	  }];
      push @$voice, $fake_note;

      # Generate a typesettable score that makes actual sense. We basically have two options: set it as a one-line percussion staff
      # and show all the notes, or set it as a non-percussion staff (RhythmicStaff is perfect for this as it's one-line) and show
      # a cluster that's just one black line. The good thing about separate notes is we can attach start and end times to the correct
      # notes; we can't do this with clusters but separate notes are misleading given we're talking about recordings (no known notes).
      # If we use a non-percussion staff b' (absolute) will look about right, otherwise ua is a good placeholder with no MIDI meaning.
      #
      # If Lilypond sees two consecutive clusters, it will merge them even though they are two separate clusters. The only way to
      # prevent this is to insert a rest between them.
      #
      $typesettable_version .= sprintf('\set Staff.instrumentName = #"%s" \textLengthOn', $filename);
      state $last_note_used;
      my $use_clusters_p = !$state->drummode_p();
      my $fmt0 = '_\markup{ \halign #%s \tiny "%s" }';
      my($fmt1a, $fmt1b) = (sprintf($fmt0, 'LEFT', '%.2f'), sprintf($fmt0, 'RIGHT', '%.2f'));
      my $clash_p = $use_clusters_p && defined $position_at_end_of_last_recording && $position_at_end_of_last_recording == $current_position;
      my $note = !$use_clusters_p? 'da': !$clash_p? "c''": $last_note_used eq "c''"? "a'": "c''";
      my $markup = sprintf($fmt1a, $start);
      for my $pass (!$use_clusters_p? ('normal'): ('cluster', 'ghost')) {
	my $last_duration;
	my $tie = ' ';
	$typesettable_version .= "<<\n" if $pass eq 'cluster';
	$typesettable_version .= "\\\\\n" if $pass eq 'ghost';
	$typesettable_version .= '\makeClusters ' if $pass eq 'cluster';
	$typesettable_version .= "{\n\\absolute {\n" if $use_clusters_p;
	$typesettable_version .= '\voiceOne ' if $pass eq 'ghost';
	$typesettable_version .= sprintf("%s\n", join(' ', map {"\\hide $_"} ($pass eq 'ghost'? qw(NoteHead Rest Stem Dots Tie): qw(Rest))));
	my($gap, @effective_quantized_beats) = (undef, @quantized_beats);
	if ($pass eq 'cluster' && $clash_p) {
	  $gap = 128;
	  for (; $quantized_beats[$#quantized_beats] != $gap;) {
	    my $n = pop @quantized_beats;
	    $n *= 2;
	    push @quantized_beats, $n;
	    push @quantized_beats, $n unless $n == $gap;
	  }
	}
	$typesettable_version .= " r$gap" if defined $gap;
	for my $duration (@quantized_beats) {
	  if (!$duration) {
	    ;
	  } elsif (defined $last_duration && $last_duration == $duration/2) {
	    $typesettable_version .= '.';
	  } else {
	    $typesettable_version .= sprintf('%s%s%d', $tie, $note, $duration);
	    if ($pass ne 'cluster') {
	      $typesettable_version .= $markup;
	      $markup = undef;
	    }
	  }
	  $tie = '~';
	  $last_duration = $duration;
	}
	$typesettable_version .= $markup if $pass ne 'cluster' && defined $markup;
	$typesettable_version .= sprintf($fmt1b, $end) if $pass ne 'cluster';
	$typesettable_version .= "}\n" if $use_clusters_p;	# close \absolute
	$typesettable_version .= "}\n" if $use_clusters_p;
      }
      $typesettable_version .= ">>\n" if $use_clusters_p;
      $last_note_used = $note;

      # Update current position manually
      $current_position += $duration;
      $position_at_end_of_last_recording = $current_position;

    } elsif ($s =~ s/^"((?:\\"|[^"])*)"//s) {				# text
      $typesettable_version .= $&;
      my($s) = ($1);

    } elsif ($s =~ s/^\\(laisserVibrer)\s+//s) {			# ignore \laisserVibrer for now
      $typesettable_version .= $&;
      $directive = $1;

    } elsif ($s =~ s/^\\(acciaccatura)\s+//s) {				# ignore \acciaccatura for now
      $typesettable_version .= $&;
      $grace_note_type = $1;

    } elsif ($s =~ s/^\\key\s+$pitch_re\s+\\(?:major|minor)\s+//s) {	# ignore \key
      $typesettable_version .= $&;

    } elsif ($s =~ s/^\\partial\s+$duration_re\s+//s) {			# ignore \partial
      $typesettable_version .= $&;

    } elsif ($s =~ s/^\\mark\s+(?:\\default|#\d+|"[^""]+")\s+//s) {	# ignore \mark
      $typesettable_version .= $&;

    } elsif ($s =~ s/^\\set\s+Score\.markFormatter\s+=\s+#[-a-z]+\s+//s) {	# ignore set mark formatter
      $typesettable_version .= $&;

    } elsif ($s =~ s/^\\textLengthOn\s+//s) {				# ignore \textLengthOn
      $typesettable_version .= $&;

    } elsif ($s =~ s/^\\omit\s+[A-Z][A-Za-z]+(?:\.[A-Z][A-Za-z]+)+\s+//s) {	# ignore \omit
      $typesettable_version .= $&;

    } elsif ($s =~ s/^\\new\s+(?:(?:(Drum)|Rhythmic)?Staff|Voice)\s+(?:\\with \{[^\{}]+})?//s || $s =~ s/^\\\\\s*//s) {
      $typesettable_version .= $&;
      # FIXME - do we need to gsave?
      $state->drummode_p(1) if $1;
      push @$it, $voice if $voice;
      $voice = undef;

    } elsif ($s =~ s/^\\voice(?:One|Two|Three|Four)\s+//s) {
      $typesettable_version .= $&;

    } elsif ($s =~ s/^\\score\s+\x{7b}\s*//s) {
      $typesettable_version .= $&;
      $state->gsave();

    } elsif ($s =~ s/^\\(?:drums|drummode)\s*\x{7b}//s) {
      $typesettable_version .= $&;
      $state->gsave();
      $state->drummode_p(1);
      # FIXME - do we need to push voice?

    } elsif ($s =~ s/^\\absolute\s*\x{7b}//s) {
      $typesettable_version .= $&;
      $state->gsave();
      $state->relative_p(0);

    } elsif ($s =~ s/^\\relative\s*\x{7b}//s) {
      $typesettable_version .= $&;
      $state->gsave();
      $state->relative_p(1);
      $last_pitch = undef;

    } elsif ($s =~ s/^\\relative\s+($pitch_re)\s*\x{7b}//s) {
      $typesettable_version .= $&;
      $state->gsave();
      $state->relative_p(1);
      $last_pitch = interpret_absolute_pitch $1;

    } elsif ($s =~ s/^\\transpose\s+($pitch_re)\s+($pitch_re)\s*\x{7b}//s) {
      $typesettable_version .= $&;
      my($from, $to) = (interpret_absolute_pitch $1, interpret_absolute_pitch $5);
      $state->gsave();
      $state->relative_p(0);
      $state->transpose($state->transpose() + $to - $from);

    } elsif ($s =~ s/^\\repeat\s+(?:volta|unfold|percent)\s+(\d+)\s*\x{7b}//s) {
      $typesettable_version .= $&;
      my $n = $1 + 0;
      $state->gsave();
      $state->repeat_stacklevel($state->stacklevel());
      $state->repeat_count($n);
      $state->repeat_start(defined $voice? scalar @$voice: 0);

    } elsif ($s =~ s/^\x{7d}\s*//s) {		# braceright
      $typesettable_version .= $&;
      if (defined $state->repeat_stacklevel() && $state->repeat_stacklevel() == $state->stacklevel()) {
	my @A = @$voice;
	my $i = $state->repeat_start();
	my $n = $state->repeat_count();
	$voice = [@A[0 .. $i - 1], (@A[$i .. $#A]) x $n];
      }
      $state->grestore($s);
    } elsif ($s =~ s/^[\[\]]\s*//s) {		# ignore bracketleft/bracketright = beam on/beam off
      $typesettable_version .= $&;
    } elsif ($s =~ s/^\(\s*//s) {		# ignore parenleft = phrasing slur start
      $typesettable_version .= $&;
    } elsif ($s =~ s/^\)\s*//s) {		# ignore parenright = phrasing slur end
      $typesettable_version .= $&;
    } elsif ($s =~ s/^\|\s*//s) {		# ignore bar checks
      $typesettable_version .= $&;
    } elsif ($s =~ s/^\~\s*//s) {		# tie
      $typesettable_version .= $&;
      $tie_p = 1;
    } elsif ($s =~ s/^(?:\\accent\b|->)//s) {
      $typesettable_version .= $&;
      $directive = 'accent';
    } elsif ($s =~ s/^(?:\\staccato\b|-\.)//s) {
      $typesettable_version .= $&;
      $directive = 'staccato';
    } elsif ($s =~ s/^\x{5e}\s*\\(fermata)\b//s) {	# pause
      $typesettable_version .= $&;
      $directive = $1;
    } elsif ($s =~ s/^\\tempo(?:\s+"[^""]+")?\s+(\d+)\s+=\s+(\d+)\s+//s) {
      $typesettable_version .= $&;
      $state->tempo($1, $2);
    } elsif ($s =~ s/^\\time\s+\d+\/\d+\s+//s) {	# ignore time signature
      $typesettable_version .= $&;
    } elsif ($s =~ s/^\\clef\s+"[^""]+"\s*//s) {	# ignore clef change
      $typesettable_version .= $&;
    } elsif ($s =~ s/^\\breathe\s+//s) {	# ignore breath marks for now
      $typesettable_version .= $&;
    } elsif ($s =~ s/^\\tuplet\s+(\d+)\/(\d+)\s*\x{7b}//s) {
      $typesettable_version .= $&;
      $state->gsave();
      $state->unit_beat($state->unit_beat() * $2 / $1);
    } elsif ($s =~ s/^$duration_re$end_re//s) {
      $typesettable_version .= $&;
      ($divisor, $dots) = (interpret_divisor $1, length $2);
      log_debug "Duration \"$divisor$dots\" encountered before any rest, pitch, or percussion instrument" unless defined $note;
      $lhs = $note;

    } elsif ($s =~ s/^$rest_re(?:$duration_re)?$end_re//s) {
      $typesettable_version .= $&;
      my($new_divisor, $new_dots) = ($1, $2);
      ($divisor, $dots) = (interpret_divisor $new_divisor, length $new_dots) if defined $new_divisor;
      $lhs = 'r';

    } elsif ($s =~ s/^(?!$end_re)($pitch_re)(?:$duration_re)?$end_re//s		# make sure SOMETHING is matched ($pitch_re can match nothing)
	  || $s =~ s/^<\s*($pitch_re)(?:\s+$pitch_re_no_captures)+\s*>(?:$duration_re)?$end_re//s) {	# discard lower notes in chords

      my $what = $&;
      $typesettable_version .= $&;
      my($pitch_as_written, $base_pitch, $lower, $raise, $new_divisor, $new_dots)
	  = ($1, ($ly_notes{$2} + 12)%12, 0 + length $3, 0 + length $4, $5, $6);

      my $pitch;
      if ($state->relative_p()) {
	($last_pitch, $lower, $raise) = (interpret_absolute_pitch $pitch_as_written, undef, undef) if !defined $last_pitch;
	my $last_base_pitch = ($last_pitch + 12)%12;
	for (my $i = 0; $i < 8; $i += 1) {
	  for my $dir (-1, 1) {
	    my $candidate = $last_pitch + $dir*$i;
	    $pitch = $candidate if $candidate%12 == $base_pitch;
	  last if defined $pitch;
	  }
	last if defined $pitch;
	}
	$pitch += 12*($raise - $lower);
      } else {
	$pitch = interpret_absolute_pitch $pitch_as_written;
      }
      $pitch += $state->transpose() if defined $pitch;
      ($divisor, $dots) = (interpret_divisor $new_divisor, length $new_dots) if defined $new_divisor;
      $lhs = $midi_number_to_note[$pitch];
      die "interpret_melody error: note $pitch_as_written out of range\n" unless defined $lhs;
      $last_pitch = $pitch;

    } elsif ($s =~ s/^($percussion_instrument_re)(?:$duration_re)?$end_re//s) {
      $typesettable_version .= $&;
      ($percussive_instrument, my $new_divisor, my $new_dots) = ($1, $2, $3);
      ($divisor, $dots) = (interpret_divisor $new_divisor, length $new_dots) if defined $new_divisor;
      $lhs = $percussive_instrument;

    } elsif ($s =~ s/^\\($expressive_mark_re)\b//s) {
      $typesettable_version .= $&;
      $volume = $expressive_mark_to_midi_velocity{$1};

    } elsif ($s =~ s/^\\set\s+Staff\.instrumentName\s+=\s+#"([^""]+)"\s*//s) {
      $typesettable_version .= $&;
      $main_instrument = $1;

    } elsif ($s =~ s/^(\S+)//s) {
      $typesettable_version .= $&;
      log_debug sprintf('Unknown expression "%s" near "%s" discarded', $1, $');
    } else {
      $typesettable_version .= $&;
      log_debug "Internal error: \"else\" case reached in interpret_melody, s=($s)";
    }
    if (defined $lhs) {
      my $rhs = $state->unit_beat() * calculate_beat_length($divisor, $dots);
      if ($tie_p) {
	if (!defined $note) {
	  $tie_p = 0;
	  log_error "Tie ignored because there is no note to tie to";
	} elsif ($note ne $lhs) {
	  $tie_p = 0;
	  log_error "Tie ignored because $note and $lhs are different";
	} else {
	  $voice->[+scalar @$voice - 1][1] += $rhs;
	}
      }
      my $rest_p = $lhs eq 'r';
      my $instrument = ($lhs eq $percussive_instrument || $rest_p)? undef: $main_instrument; # FIXME
      my $node = [$lhs, $rhs, ($rest_p? undef: $volume), $instrument] unless $tie_p;
      if (defined $grace_note_type) {	# zero out the note's duration, in effect ignoring all grace notes for now
	$node->[1] = 0;
	$node->[4] = {'actual-duration' => $rhs};
      }
      push @$voice, $node if defined $node;
      $note = $lhs;
      $tie_p = 0;
      $grace_note_type = undef;
      no integer;
      $current_position += $rhs;
    } elsif (defined $directive) {
      my $verb = ref $directive? $directive->[0]: $directive;
      if (!defined $note) {
	log_error "Directive $verb ignored because there is no note before it";
      } elsif ($verb eq 'accent') {
	my $volume = $voice->[+scalar @$voice - 1]->[2];
	if (defined $volume) {
	  no integer;
	  $volume *= 1.44;
	  $volume = 127 if $volume > 127;
	  $voice->[+scalar @$voice - 1]->[2] = $volume;
	}
      } elsif ($verb eq 'staccato') {
	my $node = $voice->[+scalar @$voice - 1];
	no integer;
	$node->[4]->{'actual-duration'} = $node->[1]/4;
      } elsif ($verb eq 'fermata') {
	$voice->[+scalar @$voice - 1]->[1] *= 2;	# FIXME
      } elsif ($verb eq 'laisserVibrer') {
	my $node = $voice->[+scalar @$voice - 1];
	$node->[4]->{'laisser-vibrer'} = 1;
      } else {
	log_error "interpret_melody: Unknown directive \"$verb\"";
      }
    }
  }
  push @$it, $voice if $voice;
  log_debug sprintf "%s interpreted as %s", $s0,
      join(" \\\\ ", map { join(' ', map { $_->[0] } @$_) } @$it) if $debug > 2;
  return wantarray? ($it, $typesettable_version): $it;
}

sub event_id ($$;$) {
  my($mode, $event, $melody) = @_;
  return join('-', map { defined $_? s/[^\.\w]+/_/sgr: () } ($mode, $melody, $event));
}
sub define_event_internal_real ($$$$$$$%) {
  my($mode, $melody, $description, $composer, $year, $source, $shared_defs, %event_defs) = @_;
  my %it;
  my($t0, $thing) = (eval { no integer; Time::HiRes::time },
		    (defined $melody? $melody: join(' ', ($mode, sort keys %event_defs))) =~ s/^\s+//sr);

  log_comment "interpreting score for $thing" if $debug || $verbose_p;
  if (defined $melody && defined $description) {
    $melody_description{$melody} = {'description' => $description, 'source' => $source};
    $melody_description{$melody}->{'composer'} = $composer if defined $composer;
    $melody_description{$melody}->{'year'} = $year if defined $year;
  } elsif (defined $mode && defined $description) {
    $mode_description{$mode} = {'description' => $description, 'source' => $source};
    $mode_description{$mode}->{'composer'} = $composer if defined $composer;
    $mode_description{$mode}->{'year'} = $year if defined $year;
  }
  $shared_defs =~ s/(?:^|(?<=\n))\s+//sg;			# kill indents
  $shared_defs =~ s/\s+$//sg;					# trim
  $shared_defs .= "\n" if $shared_defs =~ /\S/s;		# force newline at end if nonempty
  for my $event (keys %event_defs) {
    my $tune = $event_defs{$event};
    $tune = sprintf('\\new Staff { %s }', $tune) unless $tune =~ /^\s*\\(?:drums|new\s+(?:Drum|Rhythmic)?Staff)\s+/;
    $tune = sprintf('%s\score { %s }', $shared_defs, $tune);
    $event = sprintf('q%d', $1/2) if $event =~ /^e[02468]$/;	# in case we got e2, e4 etc, convert them to q1, q2 etc.
    $event = "q0" if $event eq 'q4';				# in case we got q4
    if ($event =~ /^(?:h|halb)$/ && $tune =~ /\%[Il]/) {	# expand to h1..h12
      for (my $i = 1; $i <= 12; $i += 1) {
	my $edited_tune = $tune;
	$edited_tune =~ s/\%[Il]/$i/sg;
	$it{&event_id($mode, "$event$i", $melody)} = $edited_tune;
      }
    } else {
      $it{&event_id($mode, $event, $melody)} = $tune;
    }
  }
  for my $tune (values %it) {
    my($interpretation, $typesettable_version) = interpret_melody $tune;
    $interpretation{$tune} = $interpretation unless defined $interpretation{$tune};
    $typesettable_version{$tune} = $typesettable_version unless defined $typesettable_version{$tune};
  }
  log_comment sprintf "%s defined in %.2f s", $thing, Time::HiRes::time - $t0 if $debug || $verbose_p;
  return %it;
}
sub define_event_internal ($$$$$$$%) {
  my($specified_mode, $specified_melody, $description, $composer, $year, $source, $shared_defs, %event_defs) = @_;
  my %it;
  if (!defined $specified_mode || ($specified_mode eq $mode && ($mode ne MODE__CARILLON || $specified_melody eq $melody))) {
    %it = define_event_internal_real($specified_mode, $specified_melody, $description, $composer, $year, $source, $shared_defs, %event_defs);
  } else {
    log_debug sprintf "%s %s definition skipped", $specified_mode, $specified_melody if $debug;
  }
  return %it;
}
sub define_event ($$$$$$$%) {
  my($mode, $melody, $description, $composer, $year, $source, $shared_defs, %event_defs) = @_;
  my %it;
  if (ref $melody eq 'HASH') {
    for my $melody_i (keys %$melody) {
      my $description_i = defined $description? $description: $melody->{$melody_i}->{'title'};
      my $composer_i = defined $composer? $composer: $melody->{$melody_i}->{'composer'};
      my $year_i = defined $year? $year: $melody->{$melody_i}->{'year'};
      my $source_i = defined $source? $source: $melody->{$melody_i}->{'source'};
      die "$melody_i in melody (arg 2) not in event_defs (arg 8)" unless defined $event_defs{$melody_i};
      my %event_defs_i = %{$event_defs{$melody_i}};
      %it = (%it, define_event_internal($mode, $melody_i, $description_i, $composer_i, $year_i, $source_i, $shared_defs, %event_defs_i));
    }
  } else {
    %it = define_event_internal($mode, $melody, $description, $composer, $year, $source, $shared_defs, %event_defs);
  }
  return %it;
}
sub interpret_watch ($$$$$$) {
  my($watch, $subwatch, $volume1, $instrument1, $volume2, $instrument2) = @_;
  my $score;
  my($repeats, $pattern) = @{$watch_chime_pattern[$watch - 1]};
  my $gap = ($watch == 1? ' r2': ' r4.'); # FIXME
  no integer;
  my $previous_volume;
  my $beats;
  for (my $i = 0; $i < $repeats; $i += 1) {
    $beats = calculate_beat_length(interpret_divisor $1, length $2) if $i == 0 && $gap =~ /$duration_re$/;
    $score .= $gap if defined $score;
    my $previous_duration; # need to reset this after emitting r
    for my $length (map { $_ ne '.' } split(/\s+/, $pattern)) {
      $score .= ' ' if defined $score;
      my($instrument, $volume, $duration) = $length? ($instrument1, $volume1, '4.'): ($instrument2, $volume2, '8.');
      $score .= sprintf('<>-\%s ', $volume) if !defined $previous_volume || $previous_volume ne $volume;
      $score .= (!defined $previous_duration || $previous_duration ne $duration)? sprintf('%s%s', $instrument, $duration): $instrument;
      $previous_duration = $duration;
      $previous_volume = $volume;
      $beats += calculate_beat_length(interpret_divisor $1, length $2) if $i == 0 && $duration =~ /$duration_re$/;
    }
  }
  #printf STDERR "%s x%d interpreted as %s\n", $pattern, $repeats, $score;

  my($numerator, $denominator) = (8*$beats, 32);
  while ($numerator%2 == 0 && $denominator%2 == 0 && $denominator > 8) {
    $numerator /= 2;
    $denominator /= 2;
  }
  return sprintf('\drums { \tempo 4 = 60 \time %g/%g %s }', $numerator, $denominator, $score);
}
sub define_watches ($$$$$) {
  my($subwatch, $volume1, $instrument1, $volume2, $instrument2) = @_;
  my %defs;
  for (my $watch = 1; $watch <= 5; $watch += 1) {
    my $event_id = defined $subwatch? "w$watch.$subwatch": "w$watch";
    $defs{$event_id} = interpret_watch($watch, $subwatch, $volume1, $instrument1, $volume2, $instrument2);
  }
  return define_event(undef, undef, undef, undef, undef, undef, undef, %defs);
}


use vars qw( %chime );
sub define_chimes () {
  my $t0 = eval { no integer; Time::HiRes::time };
%chime = (
  define_watches(1,     'ff', 'cyms',  'ff', 'tamb'),
  define_watches(5,     'ff', 'cymch', 'ff', 'mar'),
  define_watches(undef, 'ff', 'cymch', 'ff', 'cl'),
  define_event(MODE__SYSLINE, undef, 'sysline mode', undef, undef, '4.2bsd', q(
	A = \relative { \set Staff.instrumentName = #"Sine Wave" ees''''8 r4. ~ r4 }
      ),
      'q2' => '\A',
      'q0' => '\A',
      'h' => '\A',
    ),
  define_event(MODE__CUCKOO, undef, 'cuckoo clock mode', undef, '2021', undef, q(
	x = { \tempo 1 = 35 }
	S = \absolute { c'1 }
	A = { #(play-recording "72699__benboncan__cuckoo" 0.05 1.15) }
	B = { #(play-recording "72699__benboncan__cuckoo" 0.05 3.75) }
	C = { #(play-recording "72699__benboncan__cuckoo" 0.05 5.50) }
	D = { #(play-recording "72699__benboncan__cuckoo" 0.05 7.15) }
	E = { #(play-recording "72699__benboncan__cuckoo" 0.05 8.90) }
	F = { #(play-recording "72699__benboncan__cuckoo" 0.05 10.65 24) }
      ),
      'halb'	=> '\new RhythmicStaff << \x \A \new Staff { <>-\ff \S } >>',
      'h1'	=> '\new RhythmicStaff << \x \A \new Staff { <>-\ff \S } >>',
      'h2'	=> '\new RhythmicStaff << \x \B \new Staff { <>-\ff \repeat unfold 2 { \S } } >>',
      'h3'	=> '\new RhythmicStaff << \x \C \new Staff { <>-\ff \repeat unfold 3 { \S } } >>',
      'h4'	=> '\new RhythmicStaff << \x \D \new Staff { <>-\ff \repeat unfold 4 { \S } } >>',
      'h5'	=> '\new RhythmicStaff << \x \E \new Staff { <>-\ff \repeat unfold 5 { \S } } >>',
      'h6'	=> '\new RhythmicStaff << \x \F \new Staff { <>-\ff \repeat unfold 6 { \S } } >>',
      'h7'	=> '\new RhythmicStaff << \x { \F \A } \new Staff { <>-\ff \repeat unfold 7 { \S } } >>',
      'h8'	=> '\new RhythmicStaff << \x { \F \B } \new Staff { <>-\ff \repeat unfold 8 { \S } } >>',
      'h9'	=> '\new RhythmicStaff << \x { \F \C } \new Staff { <>-\ff \repeat unfold 9 { \S } } >>',
      'h10'	=> '\new RhythmicStaff << \x { \F \D } \new Staff { <>-\ff \repeat unfold 10 { \S } } >>',
      'h11'	=> '\new RhythmicStaff << \x { \F \E } \new Staff { <>-\ff \repeat unfold 11 { \S } } >>',
      'h12'	=> '\new RhythmicStaff << \x { \F \F } \new Staff { <>-\ff \repeat unfold 12 { \S } } >>',
    ),
  # Experiment of adding melodies to cuckoo mode. Edelweiss would have been appropriate
  # but it turns out Edelweiss cannot be used because it's not a real folk song
  define_event(MODE__CUCKOO, 'study1', 'cuckoo clock mode study 1', undef, '2021', undef, q(
	x = { \tempo 1 = 35 }
	S = \absolute { c'1 }
	A = { #(play-recording "72699__benboncan__cuckoo" 0.05 1.15) }
	B = { #(play-recording "72699__benboncan__cuckoo" 0.05 3.75) }
	C = { #(play-recording "72699__benboncan__cuckoo" 0.05 5.50) }
	D = { #(play-recording "72699__benboncan__cuckoo" 0.05 7.15) }
	E = { #(play-recording "72699__benboncan__cuckoo" 0.05 8.90) }
	F = { #(play-recording "72699__benboncan__cuckoo" 0.05 10.65 24) }
	% Source: https://www.volksliederarchiv.de/des-morgens-in-der-fruehe/
	% Source: https://www.volksliederarchiv.de/kein-schoener-land-in-dieser-zeit/ (night)
	keinschoenerlandindieserzeitglobal = { \key a \major \time 3/4 }
	keinschoenerlandindieserzeitmelody = \transpose c c' { r2. | r4. % \partial 4.
	  <>-\mp
	  e8 e e | a4 cis' b8 a |
	  b4 r8 e e e | a4 cis' b8 a |
	  b4 r8 cis' a b | cis'8[e'] d' cis' b a |
	  b8[d'] cis'8 b a gis | a4 r8 cis' a b |
	  cis'8[e'] d' cis' b a | b[d'] cis' b a gis | a4 r8 }
	keinschoenerlandindieserzeitharmony = \transpose c c' { r2. | r4. % \partial 4.
	  e8 e e | cis4 a gis8 fis |
	  gis4 r8 e e e | cis4 a gis8 fis |
	  gis4 r8 a a gis | a8[cis'] b a gis a |
	  gis8[b] a gis a e | cis4 r8 a a gis |
	  a8[cis'] b a gis a | gis8[b] a e cis e | cis4 r8 }
	% Source: https://www.volksliederarchiv.de/ich-stund-an-einem-morgen/
      ),
      'halb'	=> '\new RhythmicStaff << \x \A \new Staff { <>-\ff \S } >>',
      'h1'	=> '\new RhythmicStaff << \x \A \new Staff { <>-\ff \S } >>',
      'h2'	=> '\new RhythmicStaff << \x \B \new Staff { <>-\ff \repeat unfold 2 { \S } } >>',
      'h3'	=> '\new RhythmicStaff << \x \C \new Staff { <>-\ff \repeat unfold 3 { \S } } >>',
      'h4'	=> '\new RhythmicStaff << \x \D \new Staff { <>-\ff \repeat unfold 4 { \S } } >>',
      'h5'	=> '\new RhythmicStaff << \x \E \new Staff { <>-\ff \repeat unfold 5 { \S } } >>',
      'h6'	=> '\new RhythmicStaff << \x \F \new Staff { <>-\ff \repeat unfold 6 { \S } } >>',
      'h7'	=> '\new RhythmicStaff << \x { \F \A } \new Staff { <>-\ff \repeat unfold 7 { \S } } >>',
      'h8'	=> '\new RhythmicStaff << \x { \F \B } \new Staff { <>-\ff \repeat unfold 8 { \S } } >>',
      'h9'	=> '\new RhythmicStaff << \x { \F \C } \new Staff { <>-\ff \repeat unfold 9 { \S } } >>',
      'h10'	=> '\new RhythmicStaff << \x { \F \D } \new Staff { <>-\ff \repeat unfold 10 { \S } } >>',
      'h11'	=> '\new RhythmicStaff << \x { \F \E } \new Staff { <>-\ff \repeat unfold 11 { \S } } >>',
      'h12'	=> '\new RhythmicStaff << \x { \F \F } \new Staff { <>-\ff \repeat unfold 12 { \S } } >>',
      'posth'	=> q(\keinschoenerlandindieserzeitglobal %\set Staff.instrumentName = #"Music Box"
	  << \voiceOne \keinschoenerlandindieserzeitmelody
	  \\\\ \voiceTwo \keinschoenerlandindieserzeitharmony >>),
    ),
  define_event(MODE__CARILLON, MELODY__ABBEY, 'Abbey chimes, Fort Augustus, NB', undef, '1880', 'Starmer, 1907, p. 13', q(
	x = { \tempo 1 = 68 }
	A = \relative { c''1 b d c }
	B = \relative { c''1 b d e }
	C = \relative { e''1 c d c }
	D = \relative { a'1(c) d c^\fermata }
	S = \relative { r1 g'1 }				% rest inserted
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \A \B',
      'q3' => '\x <>-\ff \A \B \C',
      'q0' => '\x <>-\ff \A \B \C \D',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__CAMBRIDGE, 'Cambridge Quarters', 'Jowett et al.', '1793–1794', 'Starmer, 1907, p. 7', q(
	x = { \tempo 4 = 64 }
	A = \relative c' { e'4 d c | g2. }
	B = \relative c' { c'4 e d | g,2. | c4 d e | c2. }
	C = \relative c' { e'4 c d | g,2. | g4 d' e | c2. | e4 d c | g2. }
	D = \relative c' { c'4 e d | g,2. | c4 d e | c2. | e4 c d | g,2. | g4 d' e | c2.^\fermata }
	S = \relative c' { c1 }
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \B',
      'q3' => '\x <>-\ff \C',
      'q0' => '\x <>-\ff \D',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__CAMBRIDGE_RCC, 'Chimes at R. C. Church, Cambridge', 'arr. Canon Scott', '1896', 'Starmer, 1907, p. 13', q(
	x = { \tempo 1 = 60 }
	A = \relative { d'1 g(a) b(g) a(g) }
	B = \relative { a'1 b a g e d }
	C = \relative { d'1 g a b g a g }
	D = \relative { c''1 a b g a g^\fermata }
	S = \relative { r1 d' }					% guessed
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \A \B',
      'q3' => '\x <>-\ff \A \B \C',
      'q0' => '\x <>-\ff \A \B \C \D',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__CANTERBURY, 'Canterbury Cathedral chimes', 'arr. F. J. O. Helmore', '1897', 'Starmer, 1907, p. 14', q(
	% The score given by Starmer is a Gregorian chant, so note lengths are meaningless. We need to interpret it or the music will sound dead
	A = \relative c' { g'8. a c4. }
	B = \relative c' { g'8. a c4. r4 d8. c b c2 }
	C = \relative c' { g'8. a c4. r4 d8. c b c2 r4 c8. b g4. }
	D = \relative c' { g'8. a c4. r4 d8. c b c2 r4 c8. b g4. r8 a8. c d c2 r4 }	% rest inserted
	S = \relative c' { cis1 }
      ),
      'q1' => '<>-\ff \A',
      'q2' => '<>-\ff \B',
      'q3' => '<>-\ff \C',
      'q0' => '<>-\ff \D',
      'h' => '<>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__GUILDFORD, 'Guildford chimes', 'George Wilkins', '1843', 'Starmer, 1907, p. 10', q(
	x = { \tempo 4 = 80 }
	A = \relative c' { c'2 e,4 a | g1 }
	B = \relative c' { e4 g c b | d, f a g | e1 }
	C = \relative c' { c'4 g a e | f d g e | a f g b | c1 }
	D = \relative c' { c4 g' e c' | b4. a8 g4 e | f a d, g | e2. f4 | g4 c b a | g e c c' | b g a e | g1 }
	S = \relative c' { c1 }
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \B',
      'q3' => '\x <>-\ff \C',
      'q0' => '\x <>-\ff \D',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__MAGDALEN, 'Magdalen chimes', undef, '1713', 'Starmer, 1907, p. 10', q(
	x = { \tempo 4 = 96 }
	A = \relative c' { b'4 c }
	B = \relative c' { b'4 c c, g' }
	C = \relative c' { g'4 a f e a d, }
	D = \relative c' { g'4 a f e a d, b' c | r2. }		% rest inserted
	S = \relative c' { c1 }
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \B',
      'q3' => '\x <>-\ff \C',
      'q0' => '\x <>-\ff \D',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__NEWCOLLEGE, 'New College chimes', undef, undef, 'Pearce, 1903; "Great Bells of the British Isles" (n.d.)', q(
	x = { \key d \major \omit Staff.TimeSignature }
	A = \relative c' { b'4 e, }
	B = \relative c' { d4 e b' a }
	C = \relative c' { b'4 g e a fis d }
	D = \relative c' { d4 fis e g b cis a d r1}	% rest inserted
	S = \relative c' { a1 }				% durations guessed
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \B',
      'q3' => '\x <>-\ff \C',
      'q0' => '\x <>-\ff \D',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__NORWICH, 'Norwich Cathedral chimes', 'E. S. Medley', '1876', 'Starmer, 1907, p. 11', q(
	x = { \tempo 1 = 75 }
	A = \relative c' { a'1 g f e d }
	B = \relative c' { d1 e a g f  | g d f e d }
	C = \relative c' { d1 e f a d, | f a g e f | d e g f d }
	D = \relative c' { a'1 e f g d | e f g e a | d, a' g f e | g f e d a' | r }
	S = \relative c' { r1. d1 }			% rest inserted to make it sound less rushed
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \B',
      'q3' => '\x <>-\ff \C',
      'q0' => '\x <>-\ff \D',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__TORONTO, 'Toronto Old City Hall chimes', undef, 'traditional', 'blog.ambroseli.ca/entry/2022.7.9.1', q(
	x = { \tempo 4 = 24 }
	A = \absolute { a'4 e' }
	B = \absolute { r1 }
	S = \absolute { e2 }
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \A \A',
      'q3' => '\x <>-\ff \A \A \A',
      'q0' => '\x <>-\ff \A \A \A \A \B',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__TINGTANG2A, 'Ting-tang (ding-dong) quarters on major second', undef, 'traditional', 'Starmer, 1907, p. 4', q(
	x = { \tempo 4 = 96 }
	A = \relative c' { c'4 b }
	B = \relative c' { r4 }
	S = \relative c' { f1 }
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \A \B \A',
      'q3' => '\x <>-\ff \A \B \A \B \A',
      'q0' => '\x <>-\ff \A \B \A \B \A \B \A \B',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__TINGTANG2B, 'Ting-tang (ding-dong) quarters on minor second', undef, 'traditional', 'Starmer, 1907, p. 4', q(
	x = { \tempo 4 = 96 }
	A = \relative c' { c'4 bes }
	B = \relative c' { r4 }
	S = \relative c' { f1 }
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \A \B \A',
      'q3' => '\x <>-\ff \A \B \A \B \A',
      'q0' => '\x <>-\ff \A \B \A \B \A \B \A \B',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__TINGTANG3A, 'Ting-tang (ding-dong) quarters on major third', undef, 'traditional', 'Starmer, 1907, p. 4', q(
	x = { \tempo 4 = 96 }
	A = \relative c' { c'4 a }
	B = \relative c' { r4 }
	S = \relative c' { f1 }
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \A \B \A',
      'q3' => '\x <>-\ff \A \B \A \B \A',
      'q0' => '\x <>-\ff \A \B \A \B \A \B \A \B',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__TINGTANG3B, 'Ting-tang (ding-dong) quarters on minor third', undef, 'traditional', 'Starmer, 1907, p. 4', q(
	x = { \tempo 4 = 96 }
	A = \relative c' { c'4 aes }
	B = \relative c' { r4 }
	S = \relative c' { f1 }
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \A \B \A',
      'q3' => '\x <>-\ff \A \B \A \B \A',
      'q0' => '\x <>-\ff \A \B \A \B \A \B \A \B',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__TINGTANG4, 'Ting-tang (ding-dong) quarters on perfect fourth', undef, 'traditional', 'Starmer, 1907, p. 4', q(
	x = { \tempo 4 = 96 }
	A = \relative c' { c'4 g }
	B = \relative c' { r4 }
	S = \relative c' { f1 } % or e1 or c1
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \A \B \A',
      'q3' => '\x <>-\ff \A \B \A \B \A',
      'q0' => '\x <>-\ff \A \B \A \B \A \B \A \B',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__TINGTANG5, 'Ting-tang (ding-dong) quarters on perfect fifth', undef, 'traditional', 'Starmer, 1907, p. 4', q(
	x = { \tempo 4 = 96 }
	A = \relative c' { c'4 f, }
	B = \relative c' { r4 }
	S = \relative c' { c1 }
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \A \B \A',
      'q3' => '\x <>-\ff \A \B \A \B \A',
      'q0' => '\x <>-\ff \A \B \A \B \A \B \A \B',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__WESTMINSTER, 'Westminster Quarters', 'Jowett et al.', '1793–1794', 'Wikipedia', q(
	A = \relative e' { gis4 fis e b2  }
	B = \relative e' { e4 gis fis b,2 }
	C = \relative e' { e4 fis gis e2  }
	D = \relative e' { gis4 e fis b,2 }
	E = \relative e' { b4 fis' gis e2 }
	S = \relative e' { e,2 }
	F = \relative e' { r1 }
      ),
      'q1' => '<>-\fff \A',
      'q2' => '<>-\fff \B \C',
      'q3' => '<>-\fff \D \E \A',
      'q0' => '<>-\fff \B \C \D \E \F',
      'h' => '<>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__WHITTINGTON, 'Whittington chimes on eight bells', undef, 'traditional', 'Starmer, 1907, p. 7', q(
	x = { \tempo 4 = 120 \key e \major }
	A = \transpose c e' { c'4 f b e a d g c2 }	% 2 cf George (2014)
	B = \transpose c e' { a4 g f e d b c' c2 }
	C = \transpose c e' { c'4 a f d b g e c2 }
	D = \transpose c e' { d4 f a c' b g e c2 }
	E = \transpose c e' { c'4 b a g f e d c2 }
	S = \transpose c e' { c1 }			% 1 cf George (2014)
	F = \transpose c e' { r2. r1 }
      ),
      'q1' => '<>-\f \x \E',
      'q2' => '<>-\f \x \A \B',
      'q3' => '<>-\f \x \C \D \E',
      'q0' => '<>-\f \x \A \B \C \D \F',
      'h' => '<>-\ff \x \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, {
      'whittington8xtoronto' => {
	title => "Whittington chimes on eight bells sync'd to Toronto Old City Hall chimes",
      },
      'whittington8-toronto' => {
	title => "Whittington chimes on eight bells plus Toronto Old City Hall chimes",
      },
    }, 'Whittington chimes on eight bells', undef, 'traditional', 'Wikipedia', q(
	x = { \tempo 4 = 24 \key e \major }
	A = \relative e' { e'16 fis, dis' gis, cis a b e, }
	B = \relative e' { e'16 cis a fis dis' b gis e }
	C = \relative e' { e'16 dis a gis cis b fis e }
	D = \relative e' { fis16 a cis e dis b gis e }
	E = \relative e' { e'16 dis cis b a gis fis e }
	S = \relative e' { e,2 }
	F = \relative e' { r1 }
	Whittington = { <>-\p \set Staff.instrumentName = #"Bell" }
	TO = { <>-\f \set Staff.instrumentName = #"Bell" }
	TOtingtang = \absolute { a'4 e' }
	TOgap = \absolute { r1 }
	TOstrike = \absolute { e2 }
      ),
      'whittington8xtoronto' => {
	'q1' => '\x \E',
	'q2' => '\x \A \B',
	'q3' => '\x \C \D \E',
	'q0' => '\x \A \B \C \D \F',
	'h' => '\x <>-\fff \repeat volta %I { \S }',
      },
      'whittington8-toronto' => {
	'q1' => q(<< { \Whittington \x \E }
	      \new Staff { \TO \x \absolute { \TOtingtang } }
	    >>),
	'q2' => q(<< { \Whittington \x \A \B }
	      \new Staff { \TO \x \absolute { \TOtingtang \TOtingtang } }
	    >>),
	'q3' => q(<< { \Whittington \x \C \D \E }
	      \new Staff { \TO \x \absolute { \TOtingtang \TOtingtang \TOtingtang } }
	    >>),
	'q0' => q(<< { \Whittington \x \A \B \C \D \F }
	      \new Staff { \TO \x \absolute { \TOtingtang \TOtingtang \TOtingtang \TOtingtang \TOgap } }
	    >>),
	'h1' => q(<< { \Whittington \x { \S } }
	      \new Staff { \TO \x \absolute { \TOstrike } }
	    >>),
	'h2' => q(<< { \Whittington \x { \S \S } }
	      \new Staff { \TO \x \absolute { \repeat unfold 1 { \TOstrike } \TOstrike } }
	    >>),
	'h3' => q(<< { \Whittington \x { \S \S \S } }
	      \new Staff { \TO \x \absolute { \repeat unfold 2 { \TOstrike } \TOstrike } }
	    >>),
	'h4' => q(<< { \Whittington \x { \S \S \S \S } }
	      \new Staff { \TO \x \absolute { \repeat unfold 3 { \TOstrike } \TOstrike } }
	    >>),
	'h5' => q(<< { \Whittington \x { \S \S \S \S \S } }
	      \new Staff { \TO \x \absolute { \repeat unfold 4 { \TOstrike } \TOstrike } }
	    >>),
	'h6' => q(<< { \Whittington \x { \S \S \S \S \S \S } }
	      \new Staff { \TO \x \absolute { \repeat unfold 5 { \TOstrike } \TOstrike } }
	    >>),
	'h7' => q(<< { \Whittington \x { \S \S \S \S \S \S \S } }
	      \new Staff { \TO \x \absolute { \repeat unfold 6 { \TOstrike } \TOstrike } }
	    >>),
	'h8' => q(<< { \Whittington \x { \S \S \S \S \S \S \S \S } }
	      \new Staff { \TO \x \absolute { \repeat unfold 7 { \TOstrike } \TOstrike } }
	    >>),
	'h9' => q(<< { \Whittington \x { \S \S \S \S \S \S \S \S \S } }
	      \new Staff { \TO \x \absolute { \repeat unfold 8 { \TOstrike } \TOstrike } }
	    >>),
	'h10' => q(<< { \Whittington \x { \S \S \S \S \S \S \S \S \S \S } }
	      \new Staff { \TO \x \absolute { \repeat unfold 9 { \TOstrike } \TOstrike } }
	    >>),
	'h11' => q(<< { \Whittington \x { \S \S \S \S \S \S \S \S \S \S \S } }
	      \new Staff { \TO \x \absolute { \repeat unfold 10 { \TOstrike } \TOstrike } }
	    >>),
	'h12' => q(<< { \Whittington \x { \S \S \S \S \S \S \S \S \S \S \S \S } }
	      \new Staff { \TO \x \absolute { \repeat unfold 11 { \TOstrike } \TOstrike } }
	    >>),
      },
    ),
  define_event(MODE__CARILLON, {
      &MELODY__WHITTINGTON11 => {
	title => 'Whittington chimes on eleven bells',
      },
      'whittington11study' => {
	title => 'Whittington chimes on eleven bells (arr. Ambrose Li)',
      },
      'whittington11xtoronto' => {
	title => "Whittington chimes on eleven bells sync'd to Toronto Old City Hall chimes",
      },
    }, 'Whittington chimes on eleven bells', 'Charles Villiers Stanford', '1905', 'Starmer, 1907, p. 5', q(
	s = { \key b \major \voiceOne \clef "treble" }
	t = { \key b \major \voiceThree \clef "bass" }
	b = { \key b \major \voiceFour \clef "bass" }
	w = { \tempo 4 = 90 }			% Cf Heath (2011)
	x = { \tempo 4 = 90 \time 3/4 }
	y = { \set Staff.instrumentName = #"Organ" }
	melodyonly = { <>-\ff }
	melodywaccomp = { <>-\ff \set Staff.instrumentName = #"Carillon" }
	quarteraccomp = { <>-\mp \y }
	halfaccomp = { <>-\mf \y }
	houraccomp = { <>-\f \y }
	houraccompfinal = { \y }

	melodywViolinStudyAcc = { <>-\ff \set Staff.instrumentName = #"Music Box" }
	ViolinStudyAccT = { \set Staff.instrumentName = #"Viola" }
	ViolinStudyAccB = { \set Staff.instrumentName = #"Cello" }
	quarterViolinStudyAcc = { <>-\mp \ViolinStudyAccT }
	halfViolinStudyAcc = { <>-\mf \ViolinStudyAccT }
	hourViolinStudyAcc = { <>-\f \ViolinStudyAccT }
	hourViolinStudyAccFinal = { <>-\mf }
	quarterViolinStudyAccB = { <>-\mp \ViolinStudyAccB }
	halfViolinStudyAccB = { <>-\mf \ViolinStudyAccB }
	hourViolinStudyAccB = { <>-\f \ViolinStudyAccB }
	hourViolinStudyAccFinalb = { <>-\mf }

	melodywOrganStudyAcc = { <>-\ff \set Staff.instrumentName = #"Organ" }
	OrganStudyAccT = { \set Staff.instrumentName = #"Bell" }
	OrganStudyAccB = { \set Staff.instrumentName = #"Bell" }
	quarterOrganStudyAcc = { <>-\mp \OrganStudyAccT }
	halfOrganStudyAcc = { <>-\mp \OrganStudyAccT }
	hourOrganStudyAcc = { <>-\mp \OrganStudyAccT }
	hourOrganStudyAccFinal = { <>-\mp }
	quarterOrganStudyAccB = { <>-\mp \OrganStudyAccB }
	halfOrganStudyAccB = { <>-\mp \OrganStudyAccB }
	hourOrganStudyAccB = { <>-\mp \OrganStudyAccB }
	hourOrganStudyAccFinalb = { <>-\mp }

	xTO = { \tempo 4 = 48 \time 3/4 }
	xW = { \tempo 4 = 36 \time 3/4 }
	xWq = { \tempo 4 = 48 \time 3/4 }
	wW = { \tempo 4 = 48 }
	wTO = { \tempo 4 = 48 }
	TOtingtang = \absolute { a'2 e' }
	TOgap = \absolute { r1 r1 }
	TOstrike = \absolute { e1 }
	melodywTOacc = { <>-\ff \set Staff.instrumentName = #"Music Box" }
	TOaccT = { \set Staff.instrumentName = #"Bell" }
	quarterTOacc = { <>-\f \TOaccT }
	halfTOacc = { <>-\f \TOaccT }
	hourTOacc = { <>-\f \TOaccT }
	hourTOaccFinal = { <>-\f }
	quarterTOaccB = { <>-\f \TOaccB }
	halfTOaccB = { <>-\f \TOaccB }
	hourTOaccB = { <>-\f \TOaccB }
	hourTOaccFinalb = {  }

	A = \transpose c b { c'4 g' f' e' }
	B = \transpose c b { c'4 g' f' e' g' d' }
	C = \transpose c b { a4 g f e g d' c' e' d' }
	D = \transpose c b { c'4 g' f' e' g' d' c' a f e g d1.. }	% cf Heath (2011; d4 per Starmer)
	S = \transpose c b { c2. }					% cf Heath (2011; c1 per Starmer)
      ),
      &MELODY__WHITTINGTON11 => {
	'q1' => '\x \melodyonly \partial 4 \A',
	'q2' => '\x \melodyonly \B',
	'q3' => '\x \melodyonly \C',
	'q0' => '\x \melodyonly \D',
	'h' => '\w \melodyonly \repeat volta %I { \S }',
      },
      # FIXME: Don't use chord notation. The proof will look right but sound will be wrong because the code to handle chords just isn't there
      'whittington11study' => {
	'q1' => q(<< { \s \x \melodywaccomp \partial 4 \A }
	      \new Staff { \t \x \quarteraccomp \transpose c b, { \partial 4 a1 } }
	      \new Staff { \b \x \quarteraccomp \transpose c b, { \partial 4 f1 } }
	    >>),
	'q2' => q(<< { \s \x \melodywaccomp \B }
	      \new Staff { \t \x \halfaccomp \transpose c b, { b2. a } }
	      \new Staff { \b \x \halfaccomp \transpose c b, { g2. f } }
	    >>),
	'q3' => q(<< { \s \x \melodywaccomp \C }
	      \new Staff { \t \x \quarteraccomp \transpose c b, { b2. c' d' } }
	      \new Staff { \b \x \quarteraccomp \transpose c b, { g2. a  b  } }
	    >>),
	'q0' => q(<< { \s \x \melodywaccomp \D }
	      \new Staff { \t \x \houraccomp \transpose c b, { g2. a b a1.. } }
	      \new Staff { \b \x \houraccomp \transpose c b, { e2. f g f1.. } }
	    >>),
	'h1' => q(<< { \s \w \melodywaccomp { \S } }
	      \new Staff { \t \w \houraccomp \transpose c b, { c2. } }
	      \new Staff { \b \w \houraccomp \transpose c b, { c,2. } }
	    >>),
	'h2' => q(<< { \s \w \melodywaccomp { \S \S } }
	      \new Staff { \t \w \houraccomp \transpose c b, { d2. \houraccompfinal c } }
	      \new Staff { \b \w \houraccomp \transpose c b, { c2. \houraccompfinal c, } }
	    >>),
	'h3' => q(<< { \s \w \melodywaccomp { \S \S \S } }
	      \new Staff { \t \w \houraccomp \transpose c b, { e2. e \houraccompfinal c } }
	      \new Staff { \b \w \houraccomp \transpose c b, { c2. c \houraccompfinal c, } }
	    >>),
	'h4' => q(<< { \s \w \melodywaccomp { \S \S \S \S } }
	      \new Staff { \t \w \houraccomp \transpose c b, { f2. f f \houraccompfinal c } }
	      \new Staff { \b \w \houraccomp \transpose c b, { c2. c c \houraccompfinal c, } }
	    >>),
	'h5' => q(<< { \s \w \melodywaccomp { \S \S \S \S \S } }
	      \new Staff { \t \w \houraccomp \transpose c b, { g2. g g g \houraccompfinal c } }
	      \new Staff { \b \w \houraccomp \transpose c b, { c2. c c c \houraccompfinal c, } }
	    >>),
	'h6' => q(<< { \s \w \melodywaccomp { \S \S \S \S \S \S } }
	      \new Staff { \t \w \houraccomp \transpose c b, { a2. a a a a \houraccompfinal c } }
	      \new Staff { \b \w \houraccomp \transpose c b, { c2. c c c c \houraccompfinal c, } }
	    >>),
	'h7' => q(<< { \s \w \melodywaccomp { \S \S \S \S \S \S \S } }
	      \new Staff { \t \w \houraccomp \transpose c b, { b2. b b b b b \houraccompfinal c } }
	      \new Staff { \b \w \houraccomp \transpose c b, { c2. c c c c c \houraccompfinal c, } }
	    >>),
	'h8' => q(<< { \s \w \melodywaccomp { \S \S \S \S \S \S \S \S } }
	      \new Staff { \t \w \houraccomp \transpose c b, { c2. c c c c c c \houraccompfinal c, } }
	      \new Staff { \b \w \houraccomp \transpose c b, { c,2. c, c, c, c, c, c, \houraccompfinal c, } }
	    >>),
	'h9' => q(<< { \s \w \melodywaccomp { \S \S \S \S \S \S \S \S \S } }
	      \new Staff { \t \w \houraccomp \transpose c b, { d2. d d d d d d d \houraccompfinal c, } }
	      \new Staff { \b \w \houraccomp \transpose c b, { c,2. c, c, c, c, c, c, c, \houraccompfinal c, } }
	    >>),
	'h10' => q(<< { \s \w \melodywaccomp { \S \S \S \S \S \S \S \S \S \S } }
	      \new Staff { \t \w \houraccomp \transpose c b, { e2. e e e e e e e e \houraccompfinal c, } }
	      \new Staff { \b \w \houraccomp \transpose c b, { c,2. c, c, c, c, c, c, c, c, \houraccompfinal c, } }
	    >>),
	'h11' => q(<< { \s \w \melodywaccomp { \S \S \S \S \S \S \S \S \S \S \S } }
	      \new Staff { \t \w \houraccomp \transpose c b, { f2. f f f f f f f f f \houraccompfinal c, } }
	      \new Staff { \b \w \houraccomp \transpose c b, { c,2. c, c, c, c, c, c, c, c, c, \houraccompfinal c, } }
	    >>),
	'h12' => q(<< { \s \w \melodywaccomp { \S \S \S \S \S \S \S \S \S \S \S \S } }
	      \new Staff { \t \w \houraccomp \transpose c b, { g2. g g g g g g g g g g \houraccompfinal c, } }
	      \new Staff { \b \w \houraccomp \transpose c b, { c,2. c, c, c, c, c, c, c, c, c, c, \houraccompfinal c, } }
	    >>),
      },
      # FIXME: Don't use chord notation. The proof will look right but sound will be wrong because the code to handle chords just isn't there
      'whittington11xtoronto' => {
	'q1' => q(<< { \s \xWq \melodywTOacc \partial 4 \A }
	      \new Staff { \b \xTO \quarterTOacc \transpose c b, { \partial 4 \TOtingtang } }
	    >>),
	'q2' => q(<< { \s \xW \melodywTOacc \B }
	      \new Staff { \b \xTO \halfTOacc \transpose c b, { \TOtingtang \TOtingtang } }
	    >>),
	'q3' => q(<< { \s \xW \melodywTOacc \C }
	      \new Staff { \b \xTO \quarterTOacc \transpose c b, { \TOtingtang \TOtingtang \TOtingtang } }
	    >>),
	'q0' => q(<< { \s \xW \melodywTOacc \D }
	      \new Staff { \b \xTO \hourTOacc \transpose c b, { \TOtingtang \TOtingtang \TOtingtang \TOtingtang \TOggap } }
	    >>),
	'h1' => q(<< { \s \wTO \melodywTOacc { \S } }
	      \new Staff { \b \wW \hourTOacc \transpose c b, { \TOstrike } }
	    >>),
	'h2' => q(<< { \s \wW \melodywTOacc { \S \S } }
	      \new Staff { \b \wTO \hourTOacc \transpose c b, { \TOstrike \hourTOaccFinal \TOstrike } }
	    >>),
	'h3' => q(<< { \s \wW \melodywTOacc { \S \S \S } }
	      \new Staff { \b \wTO \hourTOacc \transpose c b, { \TOstrike \TOstrike \hourTOaccFinal \TOstrike } }
	    >>),
	'h4' => q(<< { \s \wW \melodywTOacc { \S \S \S \S } }
	      \new Staff { \b \wTO \hourTOacc \transpose c b, { \TOstrike \TOstrike \TOstrike \hourTOaccFinal \TOstrike } }
	    >>),
	'h5' => q(<< { \s \wW \melodywTOacc { \S \S \S \S \S } }
	      \new Staff { \b \wTO \hourTOacc \transpose c b, { \TOstrike \TOstrike \TOstrike \TOstrike \hourTOaccFinal \TOstrike } }
	    >>),
	'h6' => q(<< { \s \wW \melodywTOacc { \S \S \S \S \S \S } }
	      \new Staff { \b \wTO \hourTOacc \transpose c b, { \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \hourTOaccFinal \TOstrike } }
	    >>),
	'h7' => q(<< { \s \wW \melodywTOacc { \S \S \S \S \S \S \S } }
	      \new Staff { \b \wTO \hourTOacc \transpose c b, { \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \hourTOaccFinal \TOstrike } }
	    >>),
	'h8' => q(<< { \s \wW \melodywTOacc { \S \S \S \S \S \S \S \S } }
	      \new Staff { \b \wTO \hourTOacc \transpose c b, { \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \hourTOaccFinal \TOstrike } }
	    >>),
	'h9' => q(<< { \s \wW \melodywTOacc { \S \S \S \S \S \S \S \S \S } }
	      \new Staff { \b \wTO \hourTOacc \transpose c b, { \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \hourTOaccFinal \TOstrike } }
	    >>),
	'h10' => q(<< { \s \wW \melodywTOacc { \S \S \S \S \S \S \S \S \S \S } }
	      \new Staff { \b \wTO \hourTOacc \transpose c b, { \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \hourTOaccFinal \TOstrike } }
	    >>),
	'h11' => q(<< { \s \wW \melodywTOacc { \S \S \S \S \S \S \S \S \S \S \S } }
	      \new Staff { \b \wTO \hourTOacc \transpose c b, { \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \hourTOaccFinal \TOstrike } }
	    >>),
	'h12' => q(<< { \s \wW \melodywTOacc { \S \S \S \S \S \S \S \S \S \S \S \S } }
	      \new Staff { \b \wTO \hourTOacc \transpose c b, { \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \TOstrike \hourTOaccFinal \TOstrike } }
	    >>),
      },
    ),
  define_event(MODE__CARILLON, 'study1', 'Study 1', undef, '2021', 'O Canada, God Save The Queen, Malines half-quarters; cf. Starmers, 1910, p. 97', q(
	% Calixa Lavallée, 1880 (source: https://laws-lois.justice.gc.ca/fra/lois/N-2/20180207/P1TT3xt3.html)
	x = { \tempo 4 = 96 } % allegro vivent would be 120-ish but even at 120 it's way too fast
	A = \relative c'' {
	  \time 4/4
	  a2 c4. c8 | f,2. g4 | a4 bes4 c4  d4 |
	  g,2. r4 | a2 b4. b8 | c2. d4 |
	  e4 e4 d4 d4 | c2. g8.[a16] | bes4. a8 g4 a8.[bes16] |
	  c4. bes8 a4 bes8.[c16] | d4 c4 bes4 a4 | g2. g8.[a16] |
	  bes4. a8 g4 a8.[bes16] | c4. bes8 a4 a4 | g4 c4 c8[b8] a8[b8] | c2 r2 |
	  a2 c4. c8 | f,2 r2 | bes4.~bes8 d4. d8 | g,2 r2 |
	  c2 cis4. cis8 | d4 bes4 a4 g4 | f2 g2 | a2. r4 |
	  c2 f4. f8 | d4 bes4 a4 g4 | c2 e,2 | f2. r4 |
	}
	% Source:  Weir, R. S., Lavallée, C. & Schaeffer, G. A. G. (1914). O Canada! The national song of the Dominion.
	% Retrieved from https://archive.org/details/CSM_01142/
	nationalanthemglobal = { \time 4/4 \key ees \major }
	nationalanthem = \relative { \nationalanthemglobal
	<<
	  \relative {
	    \voiceOne
	    g'2 bes4. bes8 | ees,2. f4 | g aes bes c | f,2. r4 |
	    % p.4
	    g2 a4. a8 | bes2. c4 | d d c c | bes2. f8.[ g16] |
	    aes4. g8 f4 g8.[ aes16] | bes4. aes8 g4 aes8.[ bes16] | c4 bes aes g | f2. f8.[ g16] |
	    aes4. g8 f4 g8.[ aes16] | bes4. aes8 g4 g | f bes bes8[ a] g[ a] | bes2 r |
	    % p.5
	    g2 bes4. bes8 | ees,2 r | aes2 c4. c8 | f,2 r |
	    bes2 b4. b8 | c4 aes g f | ees2 f | g2. r4 |
	    bes2 ees4. ees8 | c4 aes g f | bes2 d, | ees1 |
	  }
	  \new Voice \relative {
	    \voiceTwo
	    ees'2 d4. d8 | c2. d4 | ees4 ees ees ees | ees2( d4) r |
	    % p.4
	    ees2 f4. f8 | f2. g4 | f4 f a a | f2. d4 |
	    d4. d8 d4 d | ees4. ees8 ees4 ees | ees ees ees ees | d2. d4 |
	    d4. d8 d4 d | ees4. ees8 ees4 cis | d f f f | f2 r |
	    % p.5
	    ees2 f4. f8 | ees2 r | f2 f4. f8 | f2 r |
	    ees2 des4. des8 | c4 c ees c | bes2 d | ees2. r4 |
	    ees2 ees4. ees8 | ees4 f ees c | ees2 bes | bes1 |
	  }
	  \new Staff
	  \relative { \clef "bass" \nationalanthemglobal
	    \voiceFour
	    ees2 bes4. bes8 | c2. bes4 | ees f g aes | bes2. r4 |
	    % p.4
	    ees,2 c4. c8 | d2. ees4 | f f f f | bes2. aes8.[ g16] |
	    f4. g8 aes4 bes8.[ aes16] | g4. f8 ees4 f8.[ g16] | aes4 g aes a | bes2. bes,4 |
	    bes4. bes8 bes4 bes | ees4. ees8 ees4 e | f f f f | bes2 r |
	    % p.5
	    ees,2 d4. d8 | c2 r | f2 ees4. ees8 | d2 r |
	    ees2 ees4. ees8 | aes,4 f g aes | bes2 bes | ees2. r4 |
	    g2 g,4. g8 | aes4 f g aes | bes2 bes | ees1 |
	  }
	>>
	}
	excerptfromstart = \relative a' {
	<<
	  \relative { \nationalanthemglobal
	    \voiceOne
	    g'2 bes4. bes8 | ees,2. f4 | g aes bes c | f,2. r4 |
	  }
	  \new Voice \relative { \nationalanthemglobal
	    \voiceTwo
	    ees'2 d4. d8 | c2. d4 | ees4 ees ees ees | ees2( d4) r |
	  }
	  \new Staff
	  \relative { \clef "bass" \nationalanthemglobal
	    ees2 bes4. bes8 | c2. bes4 | ees f g aes | bes2. r4 |
	  }
	>>
	}
	excerptfromend = \relative a' {
	<<
	  \relative g' { \nationalanthemglobal
	    \voiceOne
	    g2 bes4. bes8 | ees,2 r | aes2 c4. c8 | f,2 r |
	  }
	  \new Voice \relative ees'' { \nationalanthemglobal
	    \voiceTwo
	    ees,2 d4. d8 | c2 r | f2 ees4. ees8 | d2 r |
	  }
	  \new Staff
	  \relative ees' { \clef "bass" \nationalanthemglobal
	    ees,2 d4. d8 | c2 r | f2 ees4. ees8 | d2 r |
	  }
	>>
	}
	% anonymous, 1745
	excerptfromroyalanthem = {
	<<
	  \time 3/4
	  \key g \major
	  \relative g' {
	  g4 g a | fis4. g8 a4 | b b c | b4. a8 g4 |
	  a g fis | g2. |
	  d'4 d d | d4. c8 b4 | c c c | c4. b8 a4 |
	  b c8[b] a[g] | b4. c8 d4 | e8[c] b4 a | g2.
	  }
	  \new Staff
	  \relative { \clef "bass" % source: https://en.wikipedia.org/wiki/File:Gstk.png
	  \key g \major
	    g4 g, g' | d4. e8 fis4 | g g a | fis4. fis8 g4 |
	    c, d d | g,2. |
	    b'4 b b | b4. a8 g4 | a a a | a4. g8 fis4 |
	    g a8[g] fis[e] | d4. c8 b4 | c d4. d8 | g,2.
	  }
	>>
	}
	S = \relative { c'1 }
	% Malines half quarters from Starmer (1910, p. 97)
	malinesi   = \relative { r16 f'''[e d] c[b a g] f[c a f] c[a f8] }
	malinesii  = \relative { r8 a16[c] f[a c f] g[a b c] d[e f8] }
	malinesiii = \relative { \time 4/16 f''16[d a' f] | \time 16/16 d'[a f d] b'[g e cis] d[a f a] \clef "bass" d,8[d,] }
	malinesiv  = \relative { \time 4/16 r16 d''[f a]  | \time 16/16 d[a b g] a[f g e] f[d e cis] d8[\clef "bass" d,,] }
      ),
      'q1' => '\x \excerptfromstart',
      'q2' => '\x <>-\f \excerptfromroyalanthem r2.',
      'q3' => '\x \excerptfromend',
      'q0' => '\x \nationalanthem r1',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
      # "continental" additions
      'halb' => q(\x <>-\f \repeat volta %I { \relative { c''1 } }),
      'e1' => q(\x \malinesi),
      'e3' => q(\x \malinesii),
      'e5' => q(\x \malinesiii),
      'e7' => q(\x \malinesiv),
    ),
  define_event(MODE__CARILLON, 'whittington8study', 'Whittington chimes on eight bells (chord study)', '2021', 'arr. Ambrose', 'Wikipedia', q(
	x = { \tempo 4 = 196 \key e \major }
	partA = \relative e' { e'4 fis, dis' gis, cis a b e, }
	partB = \relative e' { e'4 cis a fis dis' b gis e }
	partC = \relative e' { e'4 dis a gis cis b fis e }
	partD = \relative e' { fis4 a cis e dis b gis e }
	partE = \relative e' { e'4 dis cis b a gis fis e }
	A = { \mark "q1" \partE }
	B = { \mark "q2" \partA \partB }
	C = { \mark "q3" \partC \partD \partE }
	D = { \mark "q4" \partA \partB \partC \partD }
	S = \relative e' { e1 }

	Aa = \transpose c e	{ c'2 d' e'1 }
	Ba = \transpose c e	{ c'2 b a g | c'1 e' }
	Ca = \transpose c e	{ c'2 d' e1 | d'2 e' d'1 | c'2 d' b1 }
	Da = \transpose c e	{ c'1 d'2 b | e'1 d'2 b | c'1 e'2 d' | a1 g2 a }
	Sa = \transpose c e	{  }

	At = \transpose c e	{ a2 b g1 }
	Bt = \transpose c e	{ a2 g f e | a1 g }
	Ct = \transpose c e	{ a2 b c1 | b2 c' g1 | a2 b e1 }
	Dt = \transpose c e	{ a1 b2 g | c'1 b2 g | a1 c'2 b | f1 d2 e }
	St = \transpose c e	{ g,2. r4 }

	Ab = \transpose c e	{ f2 g c1 }
	Bb = \transpose c e	{ f2 e d c | f1 c }
	Cb = \transpose c e	{ f2 g a1 | g2 a b,1 | f2 g c1 }
	Db = \transpose c e	{ f1 g2 e | a1 g2 e | e1 a2 g | d1 b,2 c }
	Sb = \transpose c e	{ c,2. r4 }
      ),
      'q1' => '\x << \A \\\\ \Aa \\\\ \At \\\\ \Ab >>',
      'q2' => '\x << \B \\\\ \Ba \\\\ \Bt \\\\ \Bb >>',
      'q3' => '\x << \C \\\\ \Ca \\\\ \Ct \\\\ \Cb >>',
      'q4' => '\x << \D \\\\ \Da \\\\ \Dt \\\\ \Db >>',
      'h' => '\x r1 <>-\ff \repeat volta %I { << \S \\\\ \Sa \\\\ \St \\\\ \Sb >> }',
    ),
  define_event(MODE__CARILLON, {
	'study2' => { 'title' => 'Study 2',
		      'source' => 'Weir, Lavallée, and Schaeffer (1914); Starmers (1910, p. 97)',
		    },
	'study3' => { 'title' => 'Study 3',
		      'source' => 'Weir, Lavallée, and Schaeffer (1914); Stevenson (n.d.); Starmers (1910, p. 97)',
		    },
      }, undef, undef, '2021', undef, q(
	% Source:
	% - Weir, R. S., Lavallée, C. & Schaeffer, G. A. G. (1914). O Canada! The national song of the Dominion.
	%   Retrieved from https://archive.org/details/CSM_01142/
	nationalanthemglobal = { \time 4/4 \key ees \major \x }
	nationalanthemMelodyPartA = \transpose c c' { g2 bes4. bes8 | ees2. f4 | g aes bes c' | f2. r4 | }
	nationalanthemMelodyPartB = \transpose c c' { \mark "4p1" g2 a4. a8 | bes2. c'4 | d' d' c' c' | bes2. }
	nationalanthemMelodyPartC = \transpose c c' { f8.[ g16] |
	    \mark "4p2" aes4. g8 f4 g8.[ aes16] | bes4. aes8 g4 aes8.[ bes16] | c'4 bes aes g | f2. }
	nationalanthemMelodyPartD = \transpose c c' { f8.[ g16] |
	    \mark "4p3" aes4. g8 f4 g8.[ aes16] | bes4. aes8 g4 g | f bes bes8[ a] g[ a] | bes2 r | }
	nationalanthemMelodyPartE = \transpose c c' { \mark "5p1" g2 bes4. bes8 | ees2 r | aes2 c'4. c'8 | f2 r | }
	nationalanthemMelodyPartF = \transpose c c' { \mark "5p2" bes2 b4. b8 | c'4 aes g f | ees2 f | g2. r4 | }
	nationalanthemMelodyPartG = \transpose c c' { \mark "5p3" bes2 ees'4. ees'8 | c'4 aes g f | bes2 d | ees1 | }
	nationalanthemAltoPartA = \transpose c c' { ees2 d4. d8 | c2. d4 | ees4 ees ees ees | ees2( d4) r | }
	nationalanthemAltoPartB = \transpose c c' { \mark "4p1" ees2 f4. f8 | f2. g4 | f4 f a a | f2. }
	nationalanthemAltoPartC = \transpose c c' { d4 |
	    \mark "4p2" d4. d8 d4 d | ees4. ees8 ees4 ees | ees ees ees ees | d2. }
	nationalanthemAltoPartD = \transpose c c' { d4 |
	    \mark "4p3" d4. d8 d4 d | ees4. ees8 ees4 cis | d f f f | f2 r | }
	nationalanthemAltoPartE = \transpose c c' { \mark "5p1" ees2 f4. f8 | ees2 r | f2 f4. f8 | f2 r | }
	nationalanthemAltoPartF = \transpose c c' { \mark "5p2" ees2 des4. des8 | c4 c ees c | bes,2 d | ees2. r4 | }
	nationalanthemAltoPartG = \transpose c c' { \mark "5p3" ees2 ees4. ees8 | ees4 f ees c | ees2 bes, | bes,1 | }
	nationalanthemBassPartA = { ees2 bes,4. bes,8 | c2. bes,4 | ees f g aes | bes2. r4 | }
	nationalanthemBassPartB = { \mark "4p1" ees2 c4. c8 | d2. ees4 | f f f f | bes2. }
	nationalanthemBassPartC = { aes8.[ g16] |
	    \mark "4p2" f4. g8 aes4 bes8.[ aes16] | g4. f8 ees4 f8.[ g16] | aes4 g aes a | bes2. }
	nationalanthemBassPartD = { bes,4 |
	    \mark "4p3" bes,4. bes,8 bes,4 bes, | ees4. ees8 ees4 e | f f f f | bes2 r | }
	nationalanthemBassPartE = { \mark "5p1" ees2 d4. d8 | c2 r | f2 ees4. ees8 | d2 r | }
	nationalanthemBassPartF = { \mark "5p2" ees2 ees4. ees8 | aes,4 f, g, aes, | bes,2 bes, | ees2. r4 | }
	nationalanthemBassPartG = { \mark "5p3" g2 g,4. g,8 | aes,4 f, g, aes, | bes,2 bes, | ees1 | }
	nationalanthem = <<
	  { \voiceOne
	    \nationalanthemglobal
	    \nationalanthemMelodyPartA \nationalanthemMelodyPartB \nationalanthemMelodyPartC \nationalanthemMelodyPartD
	    \nationalanthemMelodyPartE \nationalanthemMelodyPartF \nationalanthemMelodyPartG
	  }
	  \new Voice { \voiceTwo
	    \nationalanthemglobal
	    \nationalanthemAltoPartA \nationalanthemAltoPartB \nationalanthemAltoPartC \nationalanthemAltoPartD
	    \nationalanthemAltoPartE \nationalanthemAltoPartF \nationalanthemAltoPartG
	  }
	  \new Staff { \voiceFour \clef "bass"
	    \nationalanthemglobal
	    \nationalanthemBassPartA \nationalanthemBassPartB \nationalanthemBassPartC \nationalanthemBassPartD
	    \nationalanthemBassPartE \nationalanthemBassPartF \nationalanthemBassPartG
	  }
	>>
	excerptfromstart = <<
	  { \voiceOne
	    \nationalanthemglobal
	    \nationalanthemMelodyPartB
	  }
	  \new Voice { \voiceTwo
	    \nationalanthemglobal
	    \nationalanthemAltoPartB
	  }
	  \new Staff { \voiceFour \clef "bass"
	    \nationalanthemglobal
	    \nationalanthemBassPartB
	  }
	>>
	excerptfrommiddle = <<
	  { \voiceOne
	    \nationalanthemglobal
	    \nationalanthemMelodyPartB \nationalanthemMelodyPartC \nationalanthemMelodyPartD
	  }
	  \new Voice { \voiceTwo
	    \nationalanthemglobal
	    \nationalanthemAltoPartB \nationalanthemAltoPartC \nationalanthemAltoPartD
	  }
	  \new Staff { \voiceFour \clef "bass"
	    \nationalanthemglobal
	    \nationalanthemBassPartB \nationalanthemBassPartC \nationalanthemBassPartD
	  }
	>>
	excerptfromend = <<
	  { \voiceOne
	    \nationalanthemglobal
	    \nationalanthemMelodyPartF
	  }
	  \new Voice { \voiceTwo
	    \nationalanthemglobal
	    \nationalanthemAltoPartF
	  }
	  \new Staff { \voiceFour \clef "bass"
	    \nationalanthemglobal
	    \nationalanthemBassPartF
	  }
	>>
	% Source:
	% - Stevenson, J. (n.d.). “God Save The King!” The National Anthem of England, with an additional stanza for our gracious Queen;
	%   arranged for one, two, or three voices (and chorus) with an accompanyment for the piano forte.
	%   In <cite>Collection of sheet music from the late 18th and 19th centuries</cite>, 27–34.
	%   Retrieved from https://archive.org/details/hartley00535542
	royalanthemglobal = { \time 3/4 \key bes \major \tempo 4 = 72 }
	% p.4 in the score is p.32 in the PDF
	royalanthemMelodyPartA = \transpose c c'' { \mark "4p3" bes,4 bes, c | a,4. bes,8 c4 | d d ees | d4. c8 bes,4 | c bes, a, | bes,2. | }
	royalanthemMelodyPartB = \transpose c c'' { \mark "5p2" f4 f f | f4. ees8 d4 | 
	    \mark "5p3" ees ees ees | ees4. d8 c4 | }
	royalanthemMelodyPartC = \transpose c c'' { d ees8[ d] c[ bes,] | d4. ees8 f4 | g8[ f16 ees] d4( c8.) bes,16 | bes,2. | }
	royalanthemAltoPartA = \transpose c c' { \mark "4p3" f4 g g | f4. ees8 f4 | f g8[ bes] a[ g] | f4 g8[ a] bes4 | g f f | f2. | }
	royalanthemAltoPartB = \transpose c c' { \mark "5p2" f4 f f | f4. a8 bes4 | 
	    \mark "5p3" a f f | f4. f8 f4 | }
	royalanthemAltoPartC = \transpose c c' { f bes bes | f4. a8 bes4 | g8[ c'] bes4( a8.) bes16 | bes2. | }
	royalanthemBassPartA = \absolute { \mark "4p3" bes4 g ees | f4. g8 a4 | bes4 g ees | f4. fis8 g4 | ees f f, | bes,2. | }
	royalanthemBassPartB = \absolute { \mark "5p2" bes,4 d f | bes8[ a16 g] f[ ees d c] bes,4 |
	    \mark "5p3" f4 a c' | f4. f8 f4 | }
	royalanthemBassPartC = \absolute { bes8[ a] g[ f] ees[ d] | bes,4. c8 d4 | ees f r8. f,16 | bes,2. | }
	royalanthem = <<
	  { \voiceOne
	    \royalanthemglobal
	    \royalanthemMelodyPartA \royalanthemMelodyPartB \royalanthemMelodyPartC
	  }
	  \new Voice { \voiceTwo
	    \royalanthemglobal
	    \royalanthemAltoPartA \royalanthemAltoPartB \royalanthemAltoPartC
	  }
	  \new Staff { \voiceFour \clef "bass"
	    \royalanthemglobal
	    \royalanthemBassPartA \royalanthemBassPartB \royalanthemBassPartC
	  }
	>>
	% hour strike on random note
	S = \relative { c'1 }
	% Malines half quarters from Starmer (1910, p. 97)
	malinesi   = \relative { r16 f'''[e d] c[b a g] f[c a f] c[a f8] }
	malinesii  = \relative { r8 a16[c] f[a c f] g[a b c] d[e f8] }
	malinesiii = \relative { \time 4/16 f''16[d a' f] | \time 16/16 d'[a f d] b'[g e cis] d[a f a] \clef "bass" d,8[d,] }
	malinesiv  = \relative { \time 4/16 r16 d''[f a]  | \time 16/16 d[a b g] a[f g e] f[d e cis] d8[\clef "bass" d,,] }
      ),
      'study2' => {
	'q1' => '\excerptfromstart',
	'q2' => '\excerptfrommiddle r2',
	'q3' => '\excerptfromend',
	'q0' => '\nationalanthem r1',
	'h' => '\x <>-\fff \repeat volta %I { \S }',
	# "continental" additions
	'halb' => q(\x <>-\f \repeat volta %I { \transpose c c' { \S } }),
	'e1' => q(\x \malinesi),
	'e3' => q(\x \malinesii),
	'e5' => q(\x \malinesiii),
	'e7' => q(\x \malinesiv),
      },
      'study3' => {
	'q1' => '\excerptfromstart',
	'q2' => '\royalanthem r2',
	'q3' => '\excerptfromend',
	'q0' => '\nationalanthem r1',
	'h' => '\x <>-\fff \repeat volta %I { \S }',
	# "continental" additions
	'halb' => q(\x <>-\f \repeat volta %I { \transpose c c' { \S } }),
	'e1' => q(\x \malinesi),
	'e3' => q(\x \malinesii),
	'e5' => q(\x \malinesiii),
	'e7' => q(\x \malinesiv),
      },
    ),
);
  log_info sprintf "%.2f s was spent interpreting scores for chime melodies", eval { no integer; Time::HiRes::time - $t0};
}

sub start_of_day ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  return mktime(0, 0, 0, $mday, $mon, $year);
}

sub yesterday ($) {
  my($t) = @_;
  return start_of_day(start_of_day($t) - 12*3600);
}

sub tomorrow ($) {
  my($t) = @_;
  return start_of_day(start_of_day($t) + 36*3600);
}

sub estimate_sunrise ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->start;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[0];
    $it = $tmp->strftime('%s');
  } else {
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunrise;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub estimate_sunset ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->end;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[1];
    $it = $tmp->strftime('%s');
  } else {
    # this should be the same as the else case in estimate_sunrise except the last line
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunset;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub trim ($) {
  my($s) = @_;
  $s =~ s/^\s+//;
  $s =~ s/\s+$//;
  return $s;
}

sub guess_city () {
  my $input = '/etc/localtime';
  my $det = readlink $input;
  die "$input: $!\n" unless defined $det;
  return $1 if $det =~ /([^\/]+)$/s;
}

sub guess_coordinates () {
  my $it;
  my $city = guess_city;
  log_comment "guessed city=($city)" if $debug;
  my @cmd = qw(hebcal cities);
  log_command @cmd if $debug;
  my $pid = open(INPUT, '-|');
  die "$0: guess_coordinates: $cmd[0]: fork: $!\n" unless defined $pid;
  if ($pid) {
    my $re = quotemeta $city;
    for (;;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp;
      if ($s =~ /^$re \((\d+)d(\d+)' ([NS]) lat, (\d+)d(\d+)' ([EW]) long/) {
	no integer;
	$it = {
	      'lat' => ($1 + $2/60)*($3 eq 'N'? 1: -1),
	      'lon' => ($4 + $5/60)*($6 eq 'E'? 1: -1),
	    };
      }
    last if defined $it;
    }
    close INPUT;
  } else {
    exec {$cmd[0]} @cmd;
    die "$0: guess_coordinates: $cmd[0]: exec: $!\n";
  }
  return $it;
}

# NOTE: modified to act like the current PHP version (root section goes to /, duplicate keys allowed and get stashed into an array)
sub read_ini ($) {
  my($input) = @_;
  my $it;
  local(*INPUT, $.);
  if (open(INPUT, '<:utf8', $input)) {
    for (my $section = '/';;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp $s;
      if ($s =~ /^\s*(?:[#\%;]|$)/) {
	;
      } elsif ($s =~ /^\s*\[\s*([^\[\]]+?)\s*\]\s*$/) {
	$section = $1;
      } elsif ($s =~ /^\s*([^=]+?)\s*=\s*(.*)/) {
	if (defined $section) {
	  $it->{$section}->{$1} = [] unless defined $it->{$section}->{$1};
	  push @{$it->{$section}->{$1}}, $2;
	} else {
	  $it->{$1} = [] unless defined $it->{$1};
	  push @{$it->{$1}}, $2;
	}
      } else {
	warn "$input:$.: Warning: Unknown input \"$s\"\n";
      }
    }
    close INPUT;
  }
  return $it;
}

use vars qw( $deciday_1_re $deciday_2_re $deciday_3_re $deciday_4_re $deciday_5_re );
use vars qw( $deciday_6_re $deciday_7_re $deciday_8_re $deciday_9_re $deciday_10_re );
use vars qw( $clocktime_re $deciday_re );
$clocktime_re = '(?:(?:0?\d|1\d|2[0-3]):[0-5]\d|24:00)';
$deciday_1_re = '\b(?:morning|ˈ?dziu)\b';
$deciday_2_re = '\b(?:forenoon|ˌ?jy)\b';
$deciday_3_re = '\b(?:midday|ˈ?dzuŋ)\b';
$deciday_4_re = '\b(?:afternoon|ˈbou)\b';
$deciday_5_re = '\b(?:evening|ˍdzik)\b';
$deciday_6_re = '\b(?:A|ˉ?gap)\b';
$deciday_7_re = '\b(?:B|ˍ?jyt)\b';
$deciday_8_re = '\b(?:C|ˊ?biŋ)\b';
$deciday_9_re = '\b(?:D|ˈ?diŋ)\b';
$deciday_10_re = '\b(?:E|ˍ?mou)\b';
$deciday_re = "(?:$deciday_1_re|$deciday_2_re|$deciday_3_re|$deciday_4_re|$deciday_5_re|$deciday_6_re|$deciday_7_re|$deciday_8_re|$deciday_9_re|$deciday_10_re)";

use vars qw( $sun_re $mon_re $tue_re $wed_re $thu_re $fri_re $sat_re $dow_re $dow_range_re );
$sun_re = '(?:\b(?:U|Sun(?:day)?)\b)';
$mon_re = '(?:\b(?:M|Mon(?:day)?)\b)';
$tue_re = '(?:\b(?:T|Tue(?:s(?:day)?)?)\b)';
$wed_re = '(?:\b(?:W|Wed(?:nes(?:day)?)?)\b)';
$thu_re = '(?:\b(?:R|Thu(?:r(?:s(?:day)?)?)?)\b)';
$fri_re = '(?:\b(?:F|Fri(?:day)?)\b)';
$sat_re = '(?:\b(?:S|Sat(?:urday)?)\b)';
$dow_re = "(?:$sun_re|$mon_re|$tue_re|$wed_re|$thu_re|$fri_re|$sat_re)";
$dow_range_re = "(?:[UMTWRFS]+|(?:$dow_re(?:\\s*[-,]\\s*$dow_re)*))";

sub parse_dow ($) {
  my($s) = @_;
  local($`, $&, $');
  return $s =~ /^$sun_re$/? 0:
	 $s =~ /^$mon_re$/? 1:
	 $s =~ /^$tue_re$/? 2:
	 $s =~ /^$wed_re$/? 3:
	 $s =~ /^$thu_re$/? 4:
	 $s =~ /^$fri_re$/? 5:
	 $s =~ /^$sat_re$/? 6: undef;
}


sub parse_clocktime ($) {
  my($s) = @_;
  local($`, $&, $', $1, $2);
  no integer;
  return $s =~ /^(?=$clocktime_re$)(\d+):(\d\d)/? $1 + $2/60: undef;
}

sub parse_named_deciday ($) {
  my($s) = @_;
  local($`, $&, $', $1, $2);
  no integer;
  return $s =~ /^$deciday_1_re$/? 1:
	 $s =~ /^$deciday_2_re$/? 2:
	 $s =~ /^$deciday_3_re$/? 3:
	 $s =~ /^$deciday_4_re$/? 4:
	 $s =~ /^$deciday_5_re$/? 5:
	 $s =~ /^$deciday_6_re$/? 6:
	 $s =~ /^$deciday_7_re$/? 7:
	 $s =~ /^$deciday_8_re$/? 8:
	 $s =~ /^$deciday_9_re$/? 9:
	 $s =~ /^$deciday_10_re$/? 10: undef
}

sub parse_dow_range ($) {
  my($s) = @_;
  my $it;
  if (defined $s) {
    local($`, $&, $', $1, $2);
    if ($s =~ /^[UMTWRFS]+$/) { # Waterloo style single-letter codes
      $it = join(',', map { parse_dow($_) } split(//, $s));
    } else {
      $it = join('', map { substr($_, 0, 1) =~ /[-,]/? (substr($_, 0, 1) . parse_dow(substr($_, 1))): parse_dow($_) } split(/(?=[-,]|$)/, $s));
      $it = 'ERROR' unless $it =~ /^\d+(?:[-,]\d+)*$/;

      # Handle looparounds like Fri-Sun or Sat-Tue
      $it =~ s/\b([1-6])-([1-6])\b/ $1 < $2? $&: "$1-6,0-$2" /ge;
      $it =~ s/\b(?<!-)([1-5])-0\b/\1-6,0/g;
      $it =~ s/\b(?<!-)(6)-0\b/\1,0/g;
    }
  }
  return $it;
}

sub parse_clocktime_range ($) {
  my($s) = @_;
  my $it;
  if (defined $s) {
    local($`, $&, $', $1, $2);
    $it = join('', map { substr($_, 0, 1) =~ /[-,]/? (substr($_, 0, 1) . parse_clocktime(substr($_, 1))): parse_clocktime($_) } split(/(?=[-,]|$)/, $s));
    $it = 'ERROR' unless $it =~ /^\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*$/;

    # Handle looparounds like 23:00-07:00
    no integer;
    $it =~ s/\b(\d+(?:.\d+)?)-(0)\b/ $1 < $2? $&: "$1-24" /ge;
    $it =~ s/\b(\d+(?:.\d+)?)-(\d+(?:.\d+)?)\b/ $1 < $2? $&: "$1-24,0-$2" /ge;
  }
  return $it;
}

sub parse_named_deciday_range ($) {
  my($s) = @_;
  my $it;
  if (defined $s) {
    local($`, $&, $', $1, $2);
    $it = join('', map { substr($_, 0, 1) =~ /[-,]/? (substr($_, 0, 1) . parse_named_deciday(substr($_, 1))): parse_named_deciday($_) } split(/(?=[-,]|$)/, $s));
    $it = 'ERROR' unless $it =~ /^\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*$/;

    # Handle looparounds like C-morning
    no integer;
    $it =~ s/\b(\d+)-(1)\b/ $1 < $2? $&: "$1-10,1" /ge;
    $it =~ s/\b(\d+)-(\d+)\b/ $1 < $2? $&: "$1-10,1-$2" /ge;
  }
  return $it;
}


# Quarters are weird. See https://zh.wikipedia.org/wiki/%E5%88%BB
#                     and http://yywz.snnu.edu.cn/show.aspx?id=697&cid=26
# Apparently the old Chinese system also used proportional hours... so we'll need to refactor things here at some point
# http://www.twword.com/wiki/%E5%B9%B2%E6%94%AF%E7%B4%80%E6%B3%95
sub determine_chinese_time ($) {
  my($t) = @_;
  my $it;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $midnight = start_of_day $t;
  my $deciday;
  my $slice; # size of proportional hour, needed to figure out when to sound the next chime
  # NOTE: according to one source (forgot which), the first hour (ˊdzi) spans [2300, 0100) but the new day still starts at 0000. Very odd :-/
  # therefore the old adjustment for [2300, 0000) has been deleted
  if (defined $coords) {
    my $today = start_of_day $t;
    my $yesterday = yesterday $t;
    my $tomorrow = tomorrow $t;
    my($daybreak, $slice_start, $slice_end, $starting_hour);
    # Proportional hour is used in a very early system (Spring and Autumn Period / Warring States),
    # but I don't even have an idea when the day starts (probably day before night) so we'll arbitrarily use sunrise as cutoff
    if ($t < estimate_sunrise($today)) {
      $daybreak = estimate_sunrise($yesterday);
      $slice_start = estimate_sunset($yesterday);
      $slice_end = estimate_sunrise($today);
      $starting_hour = 6;
    } elsif ($t < estimate_sunset($today)) {
      $daybreak = estimate_sunrise($today);
      $slice_start = $daybreak;
      $slice_end = estimate_sunset($today);
      $starting_hour = 1;
    } else {
      $daybreak = estimate_sunrise($today);
      $slice_start = estimate_sunset($today);
      $slice_end = estimate_sunrise($tomorrow);
      $starting_hour = 6;
    }
    if ($slice_start && $slice_end) {
      no integer;
      $slice = ($slice_end - $slice_start)/5;
      $deciday = $starting_hour + ($t - $slice_start)/$slice;
    }
  }
  my($greg_year, $greg_month, $greg_day) = ($year + 1900, $mon + 1, $mday);
  my $relative_chinese_hour = eval { no integer; fmod(($t - ($midnight - 3600))/7200, 12) };
  my $chinese_hour = $relative_chinese_hour + 1;
  my $quarter;
  my $centiday = eval { no integer; ($t - $midnight)/864 };
  if ($enable_qing_quarters) {
    $quarter = $min/15 + 1;
    $quarter += 4 if $hour%2 == 0;
  } else {
    # NOTE: traditionally these aren't quarters, but number of centiday marks past the beginning of the hour
    no integer;
    #
    # 0.5 hours maps exactly to 0 centidays. So to calculate the reporting origin, which is fractional.
    # Each hour is 86400/12 seconds, each centiday is 86400/100 seconds, so each hour is 100/12 centidays
    # In theory, each zero-based hour h begins exactly at ⌊h - 0.5⌋*100/12 centidays
    # However, when h ∈ [0, 0.5) this gives unexpected results because the formula will give a negative result
    # There's no easy way to fix this because reporting origins are hour-aligned, not half-hour aligned
    # (so we can't even change ⌊h - 0.5⌋ to (⌊h*2 - 1⌋%24)/2 because this breaks for h > 1.0)
    #
    my $reporting_origin = POSIX::floor(($relative_chinese_hour < 0.5? 11.5: (int($relative_chinese_hour) - 0.5)) * 100 / 12);
    log_debug "relative_chinese_hour=$relative_chinese_hour => reporting_origin=$reporting_origin" if $debug;
    $quarter = $centiday - int($reporting_origin);
  }
  $it = [undef, undef, undef, undef, $chinese_hour, $quarter, $centiday, $deciday,
      $wday, eval { no integer; $relative_chinese_hour < 0.5 }, $slice];
  return $it;
}

sub parse_chime_id ($) {
  my($id) = @_;
  my $it;
  if (ref $id) {
    die;
  } else {
    $it->{'id'} = $1 if $id =~ s/-([^-]+)$//s || $id =~ s/^(w\d+(?:\.\d+)?)$//s; # FIXME
  }
  die "parse_chime_id: id not found in \"$id\"" unless defined $it->{'id'};
  if ($id =~ /^([^-]+)-(.*)$/) {
    $it->{'mode'} = $1;
    $it->{'melody'} = $2;
  } elsif ($id =~ /\S/s) {
    $it->{'mode'} = $id;
  }
  return $it;
}

sub enumerate_event_types () {
  my %it;
  for my $id (keys %chime) {
    my $det = parse_chime_id $id;
    $it{$det->{'id'}} = 1;
  }
  return sort { Debug::lazy_sorter($a, $b) } keys %it;
}

sub enumerate_defined_events () {
  my @it;
  for my $event (enumerate_event_types) {
    my $id = determine_chime_id_for_event($event);
    push @it, $event if defined $id;
  }
  return @it;
}

sub determine_chime_id_for_event ($) {
  my($event_list_id) = @_;
  my $it = new Chime_Id;
  my($mode_prefix, $melody_prefix);
  for my $event (split(/,/, $event_list_id)) {
    my $segment_implementation;
    for (;;) {
      my $id1 = event_id($mode, $event, $melody);
      my $id2 = event_id($mode, $event);
      my $id3 = event_id(undef, $event);
      if (defined $chime{$id1}) {
	$segment_implementation = $id1;
	$mode_prefix = $mode unless defined $mode_prefix;
	$melody_prefix = $melody unless defined $melody_prefix;
      } elsif (defined $chime{$id2}) {
	$segment_implementation = $id2;
	$mode_prefix = $mode unless defined $mode_prefix;
      } elsif (defined $chime{$id3}) {
	$segment_implementation = $id3;
      }
    last if defined $segment_implementation;
      my $last_tried = $event;
      if ($event =~ /\./s) {
	$event =~ s/\.[^\.]+$//; # chop off subevent and try again
      } elsif ($event =~ /\d+$/s) {
	$event =~ s/\d+$//s;		# chop off number and try again
      }
    last unless $event ne $last_tried;	# nothing else to try
    }
    $it->append($segment_implementation) if defined $segment_implementation;
  }
  if (defined $mode_prefix && defined $melody_prefix) {
    $it->id("$mode_prefix-$melody_prefix-$event_list_id");
    $it->mode($mode);
    $it->melody($melody);
  } elsif (defined $mode_prefix) {
    $it->id("$mode_prefix-$event_list_id");
    $it->mode($mode);
  } else {
    $it->id($event_list_id);
  }
  log_debug sprintf "event %s has definition keyed to %s", $event_list_id, Debug::cvs($it) if $debug > 1;
  return $it;
}

sub determine_chime_duration ($$) {
  my($id, $default) = @_;
  my $it = $default;
  my $tune = $chime{$id};
  if (defined $tune) {
    $it = 0;
    for my $voice (@{$interpretation{$tune}}) {
      my $voice_duration = 0;
      for my $note (@$voice) {
	no integer;
	log_debug sprintf '%s %s', $note->[0], $note->[1] if $debug > 1;
	$voice_duration += $note->[1];
      }
      $it = $voice_duration if $voice_duration > $it;
    }
    log_debug "duration for chime $id is $it" if $debug;
  } elsif (defined $id) {
    $it = 0 if $method eq METHOD__SYNTH;
    log_debug "no chime defined for chime $id, using $it" if $debug;
  } else {
    log_debug "determine_chime_duration called, but no id was specified" if $debug;
  }
  return $it;
}

sub determine_event_duration ($$) {
  my($event, $default) = @_;
  my $event_list_id = determine_chime_id_for_event $event;
  my $it;
  for my $id (@{$event_list_id->implementation}) {
    if (defined $id) {
      $it += determine_chime_duration($id, $default) if defined $id;
      log_debug "event duration for event $event is $it" if $debug;
    } else {
      log_debug "event duration for event $event is undefined" if $debug;
    }
  }
  return $it;
}

sub determine_next_uncached_event (@) {
  my @event = @_;
  my $it;
  for my $event (@event) {
    my $event_id = $event->id;
    my $det = get_cache_pathname_for_event($event_id);
    $it = $event_id if defined $det && !-f $det;
  last if defined $it;
  }
  return $it;
}

sub determine_latency_key_from_event_id ($) {
  my($event_id) = @_;
  # We previously tried: using $event_id as-is, grouping them (watches, h/halb, posth, others)
  # The original groupings actually don't make a lot of sense and we're grouping q/h, q2/halb into Event_List's anyway
  my $it;
  if ($method eq METHOD__SYNTH && !$no_cache_p) {
    my $output = get_cache_pathname_for_event($event_id);
    no integer;
    $it = POSIX::ceil((-s $output)/65536) if defined $output;
  }
  $it = '*' unless defined $it;;
  return $it;
}

sub determine_next_event_with_unknown_latency (@) {
  my @event = @_;
  my $it;
  for my $event (@event) {
    my $event_id = $event->{'id'};
    my $latency_key = determine_latency_key_from_event_id $event_id;
    $it = $event_id if !defined $expected_latency{$latency_key};
  last if defined $it;
    $it = $event_id if defined $expected_latency{$latency_key} && !$expected_latency{$latency_key}->has_usable_measurements_p();
  last if defined $it;
  }
  return $it;
}

sub determine_events ($$$$$$$$$) {
  my($t0, $hour, $min, $sec, $chinese_hour, $quarter, $centiday, $deciday, $deciday_size) = @_;
  my @it;
  no integer;
  my $global_delay = $config->{'/'}->{'delay'}->[0] + 0 if defined $config->{'/'}->{'delay'};
  $global_delay = 0 unless defined $global_delay;

  # Western quarter-hour chime
  # Make absolutely sure we have a chime event, in case it gets thrown out because we're too close to the actual next quarter hour
  # Actually, make absolutely sure we have four quarter-hour chime events because we are now throwing nonexistent events out
  # and all quarter-hour chimes can get thrown out (e.g., sysline doesn't use q1 and q3, cuckoo mode doesn't use any of q1..q4)
  # so we need to make sure the entire next hour is covered
  my $seconds_since_hour_change = 60*$min + $sec;
  my $t_next_half_quarter_chime = int($t0) + (450 - $seconds_since_hour_change%450) + $global_delay;
  my $next_half_quarter = (int($seconds_since_hour_change / 450) + 1)%8;
  my $next_hour = (($next_half_quarter? $hour: $hour + 1) + 11)%12 + 1;
  my $half_quarter_chime_events_pushed = 0;
  my $quarter_chime_events_pushed = 0;
  for (my $i = 0;; $i += 1,
			  $t_next_half_quarter_chime += 450,
			  $next_half_quarter = ($next_half_quarter + 1)%8,
			  $next_hour += !$next_half_quarter, $next_hour = ($next_hour - 1)%12 + 1) {
    my $node = new Event_List;
    my $prechime_length;
    if ($next_half_quarter%4 == 0) {
      # Push the on-quarter chime if it exists - most clocks *don't* have these except hourly chimes (sysline being an exception)
      my $next_quarter = $next_half_quarter/2;
      my $on_quarter_chime = new Event::Quarter($t_next_half_quarter_chime, 0, $next_quarter);
      my $chime_length = determine_event_duration($on_quarter_chime->id, undef);
      $node->append($on_quarter_chime) if defined $chime_length;

      # Some clocks (for example cuckoos) do the melody after the hour/half-hour strikes - push that as posth/posthalb
      my $post_chime = new Event::Quarter($t_next_half_quarter_chime, $chime_length, $next_quarter) if defined $chime_length;
      my $post_chime_length = determine_event_duration($post_chime, undef) if defined $post_chime;
      $node->append($post_chime) if defined $post_chime_length;	# post-chime exists
    }
    if ($next_half_quarter == 0) {
      $prechime_length = determine_event_duration('q0', undef); # was: 25
    } elsif ($next_half_quarter == 1) {
      $prechime_length = determine_event_duration('e1', undef); # was: 5
    } elsif ($next_half_quarter == 2) {
      $prechime_length = determine_event_duration('q1', undef); # was: 5
    } elsif ($next_half_quarter == 3) {
      $prechime_length = determine_event_duration('e3', undef); # was: 5
    } elsif ($next_half_quarter == 4) {
      $prechime_length = determine_event_duration('q2', undef); # was: 10
    } elsif ($next_half_quarter == 5) {
      $prechime_length = determine_event_duration('e5', undef); # was: 5
    } elsif ($next_half_quarter == 6) {
      $prechime_length = determine_event_duration('q3', undef); # was: 15
    } elsif ($next_half_quarter == 7) {
      $prechime_length = determine_event_duration('e7', undef); # was: 5
    } else {
      ...
    }
    my $deferred;
    if (!defined $prechime_length) {	# event chime does not exist
      log_debug "precchime_length for next_half_quarter=$next_half_quarter is not defined" if $debug; # GOT HERE
    } elsif ($next_half_quarter % 2 == 0) {
      my $next_quarter = $next_half_quarter/2;
      $node->prepend(new Event::Quarter($t_next_half_quarter_chime, -$prechime_length, $next_quarter));
      $deferred = sub { $quarter_chime_events_pushed += 1; };
    } else {
      $node->prepend(new Event::Quarter::Half($t_next_half_quarter_chime, -$prechime_length, $next_half_quarter));
      $deferred = sub { $half_quarter_chime_events_pushed += 1; };
    }
    if ($node->count && $node->t >= $t0) {
      push @it, $node;
      &$deferred if defined $deferred;
    }
  last if $quarter_chime_events_pushed > 3 || $half_quarter_chime_events_pushed > 3;
  }

  # Spring-and-Autumn-era proportional-deciday-based night watch chimes
  # 1 watch is exactly 1 deciday, which is not actually 1/10 of a day but 1/5 of the current proportional moitie
  if ($deciday > 5 && $deciday < 6) { # 5 is the last deciday in the "day" moitie
    my $t_first_watch = $t0 + (6 - $deciday)*$deciday_size;
    push @it, Event_List->new->append(new Event::Watch($t_first_watch, 1, 1));
  } elsif ($deciday >= 6) {
    my $decidays_into_the_night = $deciday - 6;
    my $subwatches_into_the_night = 5*$decidays_into_the_night;
    my $zero_based_next_subwatch = (int($subwatches_into_the_night) + 1)%25;
    if ($zero_based_next_subwatch) {
      my $next_watch = int($zero_based_next_subwatch/5) + 1;
      my $next_subwatch = $zero_based_next_subwatch%5 + 1;
      my $t_next_subwatch = $t0 + (1 - fmod($subwatches_into_the_night, 1)) * ($deciday_size/5) + $global_delay;
      push @it, Event_List->new->append(new Event::Watch($t_next_subwatch, $next_watch, $next_subwatch));
    }
  }

  @it = sort { $a->t <=> $b->t } @it;
  return wantarray? @it: \@it;
}

sub in_range ($$) {
  my($n, $range_spec) = @_;
  my $it = 0;
  no integer;
  for my $subrange_spec (split(/\s*,\s*/, $range_spec)) {
    die "in_range: Malformed element \"$subrange_spec\" in \"$range_spec\"" unless $subrange_spec =~ /^(\d+(?:\.\d+)?)(?:-(\d+(?:\.\d+)?))?$/;
    if (defined $2) {
      $it = $1 <= $n && $n <= $2;
    } else {
      $it = $1 == $n;
    }
  last if $it;
  }
  return $it;
}

sub in_semi_closed_range ($$) {
  my($n, $range_spec) = @_;
  my $it = 0;
  no integer;
  for my $subrange_spec (split(/\s*,\s*/, $range_spec)) {
    die "in_range: Malformed element \"$subrange_spec\" in \"$range_spec\"" unless $subrange_spec =~ /^(\d+(?:\.\d+)?)(?:-(\d+(?:\.\d+)?))?$/;
    if (defined $2) {
      $it = $1 <= $n && $n < $2;
    } else {
      $it = $1 == $n;
    }
  last if $it;
  }
  return $it;
}

sub get_sink () {
  return $use_jack_p? 'jack': $ENV{'PULSE_SINK'};
}

sub get_alsa_control ($$) {
  my($key, $card) = @_;
  my @cmd = ('amixer', '-c', $card, 'controls');
  my $pid = open(INPUT, '-|');
  my $it;
  die "$0: get_alsa_control: $cmd[0]: fork: $!\n" unless defined $pid;
  if ($pid) {
    for (;;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp;
      log_input $s if $debug > 1;
      # NOTE: amixer output is designed for shell use; the single quotes aren't actually part of the id
      $it = $1 . $2 . $3 if $s =~ /^(.*?,name=)'($key)'(.*)/s;
    last if defined $it;
    }
    close INPUT;
  } else {
    POSIX::dup2(1, 2);	# redirect stderr to stdout
    exec {$cmd[0]} @cmd;
    die "$0: get_alsa_control: $cmd[0]: exec: $!\n";
  }
  return $it;
}

sub set_sink ($) {
  my($sink) = @_;
  $ENV{'PULSE_SINK'} = $sink if defined $sink;
}

sub set_test_params () {
  @sinks = @{$config->{'test'}->{'sink'}} if defined $config->{'test'}->{'sink'};
  $mode = $config->{'test'}->{'mode'}->[0] if defined $config->{'test'}->{'mode'};
  $method = $config->{'test'}->{'method'}->[0] if defined $config->{'test'}->{'method'};
  $melody = lc $config->{'test'}->{'melody'}->[0] if defined $config->{'test'}->{'melody'};
  $datadir = $config->{'test'}->{'datadir'}->[0] if defined $config->{'test'}->{'datadir'};
  log_debug sprintf "test params set at %.2f: mode=%s, method=%s, melody=%s", $boottime, $mode, $method, $melody if $verbose_p || $debug;
}

sub emulated_sink_volume (;$) {
  my($volume) = @_;
  state $emulated_volume = 1;
  if (defined $volume) {
    if ($volume >= 0 && $volume <= 65535) {	# we're dealing with PulseAudio style volumes here. Valid range is [0, 65535]
      $emulated_volume = $volume;
    } else {
      log_warning sprintf 'emulated_sink_volume: ignored invalid volume %s', $volume;
    }
  }
  return $emulated_volume;
}

sub emulated_sink_volume_as_fraction {
  no integer;
  my $it = emulated_sink_volume;
  $it /= 65535 if defined $it;
  return $it;
}

sub set_sink_volume_real ($$) {
  my($sink, $volume) = @_;
  my @cmd = ('pactl', '--client-name', $user_agent, 'set-sink-volume', $sink, int($volume));
  if ($sink && $sink =~ /^alsa\/.*CARD=(\w+)/) {	# lol... sigh
    my $card = $1;
    my $key = 'PCM Playback Volume';
    my $id = get_alsa_control($key, $card);
    no integer;
    @cmd = ('amixer', '-c', $card, '-M', 'cset', $id, sprintf('%d%%', $volume*100));
  }
  log_command @cmd if $debug;
  system { $cmd[0] } @cmd;
}

sub set_sink_volume ($$) {
  my($sink, $volume) = @_;
  if ($use_jack_p) {
    emulated_sink_volume $volume;
  } else {
    set_sink_volume_real $sink, $volume;
  }
}

sub interpret_time_parametrized_config_value ($$$$$$$$$) {
  my($thing_label, $thing_re, $thing_valid, $directive, $hour, $min, $sec, $deciday, $wday) = @_;
  my($target_dow, $target_times, $target_volume, $dow_in_range_p, $time_in_range_p);
  my($result, $error);
  die "interpret_time_parametrized_config_value : $thing_re: Unsupported regexp" if $thing_re =~ /(?<!\\)\x28(?!\?)/s;
  no integer;
  my $hours_past_midnight = $hour + $min/60 + $sec/3600;
  if ($directive =~ /^(?:($dow_range_re)\s+)?hours?\s+(\d+(?:[-,]\d+)*)\s*[:=]\s*($thing_re)$/) {		# integer to integer
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range($hour, $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?hours?\s+(\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*)\s*[:=]\s*($thing_re)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range($hours_past_midnight, $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?decidays?\s+(\d+(?:[-,]\d+)*)\s*[:=]\s*($thing_re)$/) {	# integer to integer
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range(int($deciday), $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?decidays?\s+(\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*)\s*[:=]\s*($thing_re)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range($deciday, $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?($clocktime_re-$clocktime_re)\s*[:=]\s*($thing_re)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_semi_closed_range($hours_past_midnight, parse_clocktime_range $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?($deciday_re(?:\s*-\s*$deciday_re)?)\s*[:=]\s*($thing_re)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range(int($deciday), parse_named_deciday_range $target_times);
  } elsif ($directive =~ /^$thing_re$/) {	# just the thing
    ($target_dow, $time_in_range_p, $target_volume) = (undef, 1, $directive);
  } else {
    $error = "unrecognized directive \"$directive\"";
  }
  $dow_in_range_p = !defined $target_dow || in_range($wday, parse_dow_range($target_dow)) if !defined $error;
  if (defined $error || !$dow_in_range_p || !defined $time_in_range_p || !$time_in_range_p) {
    ;
  } elsif (!defined $thing_valid || &$thing_valid($target_volume)) {
    $result = $target_volume;
  } else {
    $error = "out of range $thing_label $target_volume";
  }
  return wantarray? ($result, $error): [$result, $error];
}

sub get_time_parametrized_config ($$$$$$$$$;$) {
  my($section, $key, $thing_re, $thing_valid, $hour, $min, $sec, $deciday, $wday, $thing_label) = @_;
  my($adj, $error, $reason);
  $thing_label = $key unless defined $thing_label;
  for my $directive (map { split /\s*;\s*/ } @{$config->{$section}->{$key}}) {
    log_debug "considering directive: $directive" if $debug > 1;
    (my $candidate_adj, $error) = interpret_time_parametrized_config_value($thing_label, $thing_re, $thing_valid, $directive, $hour, $min, $sec, $deciday, $wday);
    ($adj, $reason) = ($candidate_adj, "because of $thing_label rule \"$directive\"") if defined $candidate_adj;
    log_error "CONFIG ERROR: $error in [$section] $key" if defined $error;
  last if defined $adj;
  }
  return wantarray? ($adj, $error, $reason): [$adj, $error, $reason];
}

sub determine_sink_volumes ($$$$$) {
  my($hour, $min, $sec, $deciday, $wday) = @_;
  my $it;
  for my $sink ($use_jack_p? ('jack'): @sinks) {
    no integer;
    my $adj;
    my $reason;
    if (defined $config->{$sink} && defined $config->{$sink}->{'volume'}) {
      ($adj, my $error, $reason) = get_time_parametrized_config($sink, 'volume', '\d+(?:\.\d+)?', sub {
	my($target_volume) = @_;
	no integer;
	$target_volume >= 0 && $target_volume <= 1;
      }, $hour, $min, $sec, $deciday, $wday);
      $adj = 1.0 unless defined $adj;
    } else {
      # Default adjustment for "night"
      $adj = 1.0;
      $adj *= 0.9 if $deciday < 1 || $deciday > 5;
      $adj *= 0.9 if $hour < 9 || $hour > 8;
    }
    $it->{$sink} = [$adj, $reason];
  }
  return $it;
}

sub set_sink_volumes ($$$$$) {
  my($hour, $min, $sec, $deciday, $wday) = @_;
  my $sink_volumes = determine_sink_volumes($hour, $min, $sec, $deciday, $wday);
  for my $sink (sort keys %$sink_volumes) {
    my $label = defined $config->{$sink} && defined $config->{$sink}->{'label'}? $config->{$sink}->{'label'}->[0]: "sink $sink";
    my($adj, $reason) = @{$sink_volumes->{$sink}};
    $reason = 'by default' if defined $adj && !defined $reason;
    log_info "Master volume adjusted to $adj for $label $reason" if $debug || $verbose_p;
    set_sink_volume $sink, 65535 * $adj;
  }
}

sub get_cache_pathname_for_event ($) {
  my($id) = @_;
  my $it;
  if (defined $id && $id ne 'test') {
    die "get_cache_pathname_for_event: Internal error: $mode: Illegal mode" unless $mode =~ /^[-\.\w]+$/s;
    die "get_cache_pathname_for_event: $id: Illegal event id" unless $id =~ /^(?:(?:^|,)[-\.\w]+)+$/s;
    my $basename;
    if ($id =~ /^tmp\d+$/) {
      $basename = $id;
    } else {
      my $chime_id = determine_chime_id_for_event $id;
      $basename = 'cache-' . $chime_id->id if defined $chime_id;
    }
    $it = sprintf('%s/%s.oga', $datadir, $basename) if defined $basename;
  }
  return $it;
}

sub send_midi_command ($) {
  my($cmd) = @_;
  log_output $cmd if $debug || $verbose_p;
  if (defined $synth) {
    $synth->send($cmd);
    $synth->{'.last-note'} = current_time if $cmd =~ /\bnoteon\b/; # XXX
  } else { # cached synth output disappeared
    log_error "trying to send midi command while synth is not connected";
  }
}

sub probe_synth_instruments ($) {
  my($soundfonts) = @_;
  my %instruments;
  for (my $i = 0; $i < @$soundfonts; $i += 1) {
    my $font = $i + 1;
    send_midi_command(sprintf('inst %d', $font));
    for my $s (split(/\r?\n/, $synth->before)) {
      if ($s =~ /^(\d+)-(\d+)\s+(.*?)\r?$/s) {
	if (!defined $instruments{$3}) {
	  $instruments{$3} = [$font, $1 + 0, $2 + 0, $soundfonts->[$i]->{'zero'}];
	  log_debug sprintf "instrument %s defined as %s", $3, Debug::cvs($instruments{$3}) if $debug > 1;
	} else {
	  log_debug sprintf "instrument %s from soundfont %d ignored", $3, $font if $debug > 1;
	}
	if (!defined $instruments{"$1-$2"}) {
	  $instruments{"$1-$2"} = $3;
	  log_debug sprintf "bank %s-%s from soundfont %s defined as alias for instrument %s", $1, $2, $font, $3 if $debug > 1;
	} else {
	  log_debug sprintf "alias %s-%s from soundfont %s ignored", $1, $2, $font if $debug > 1;
	}
      }
    }
  }
  return wantarray? %instruments: \%instruments;
}

sub find_synth_instrument ($$@) {
  my($instruments, $soundfonts, @preferences) = @_;
  my $it;
  for my $candidate (@preferences) {
    $it = $instruments->{$candidate} if defined $instruments->{$candidate};
    $it = $instruments->{$it} if defined $it && !ref $it && defined $instruments->{$it};
  last if defined $it;
  }
  return $it;
}

sub synth_instrument_name ($$) {
  my($instruments, $instrument) = @_;
  my $id = sprintf('%03d-%03d', $instrument->[0], $instrument->[1]);
  return $instruments->{$id};
}

sub canonical_instrument ($) {
  my($instrument) = @_;
  return defined $instrument && defined $alias_to_canonical_instrument{$instrument}? $alias_to_canonical_instrument{$instrument}: $instrument;
}

sub probe_score_instruments () {
  my %instruments;
  my @events_to_check = enumerate_defined_events;
  for (my $pass = 0; $pass < 2; $pass += 1) {
    for my $event (@events_to_check) {
      my $structured_chime_id = determine_chime_id_for_event $event;
      my $latency;
      die "probe_score_instruments: Internal error: $event: Enumerated event has no chime id" unless defined $structured_chime_id;
      for my $chime_id (@{$structured_chime_id->implementation}) {
	for my $voice (@{$interpretation{$chime{$chime_id}}}) {
	  for my $spec (@$voice) {
	    my($note, $time, $velocity, $instrument, $flags) = @$spec;
	    $instrument = canonical_instrument $instrument;
	    if (defined $instrument) {
	      $instruments{$instrument} = 1;
	    } elsif (defined $percussion_note_to_midi_number{$note}) {
	      $instruments{'drum kit'} = 1;
	    } elsif ($note ne 'r') {
	      die "probe_score_instruments: $note: Unknown note";
	    }
	  }
	}
      }
    }
  }
  return %instruments;
}

sub connect_synth ($) {
  my($id) = @_;
  my $output = get_cache_pathname_for_event($id);
  my($sf_path, $master_gain);
  my $immediate_p = $id eq 'test';
  if (!defined $synth && ($immediate_p || defined $output)) { # if we're connected don't try to create a second instance, it was disastrous
    my %need_instrument = probe_score_instruments;
    log_debug sprintf "needed instruments = %s", Debug::cvs [keys %need_instrument] if $debug;
    # Gong, Bell, Woodblock are used by legacy code; assume they are always needed; percussion isn't used unless detected
    if ($method ne METHOD__SYNTH) {
      $need_instrument{'Gong'} = 1;
      $need_instrument{'Bell'} = 1;
      $need_instrument{'Woodblock'} = 1;
      log_debug sprintf "needed instruments adjusted to %s", Debug::cvs [keys %need_instrument] if $debug;
    }

    # Figure out where our soundfont(s) is (are)
    my $soundfonts;
    if (defined $config->{'/'}->{'soundfont'}) {
      my $prio = 0;
      for my $input (@{$config->{'/'}->{'soundfont'}}) {
	if (open(INPUT, '<', $input)) {
	  require File::Format::RIFF;
	  my $sf =  new File::Format::RIFF;
	  $sf->read(*INPUT);
	  if ($sf->type eq 'sfbk') {
	    my $chunk = $sf->at(0);	# XXX assume first chunk is INFO
	    if ($chunk->type eq 'INFO') {
	      my($inam, $iprd);
	      for (my $j = 0; $j < $chunk->numChunks; $j += 1) {
		my $subchunk = $chunk->at($j);
		$inam = $subchunk->data if $subchunk->id eq 'INAM';
		$iprd = $subchunk->data if $subchunk->id eq 'IPRD';
	      }
	      my($type, $mf); # MIDI velocity that measures ~0 dB in japa when fluidsynth gain = 0.48 (MIDI velocity 64 supposedly = mf)
	      if ($iprd =~ /^Aegean Symphonic Orchestra\b/) {	# INAM identifies as Musescore_General
		($type, $mf) = ('Aegean Symphonic Orchestra', 64);
	      } elsif ($inam =~ /^Sonatina Symphonic Orchestra\b/) {
		($type, $mf) = ('Sonatina Symphonic Orchestra', 48);
	      } elsif ($inam =~ /^Timbres Of Heaven\b/) {
		($type, $mf) = ('Timbres Of Heaven', 32);
	      } elsif ($inam =~ /^Musescore_General\b/) {
		($type, $mf) = ('Musescore_General', 64);
	      } elsif ($inam =~ /^Fluid R\d+\b/) {
		($type, $mf) = ('Fluid', 64);
	      } else {
		$mf = 64;
		log_warning "$input: Unknown sf2 soundfont, assuming mf=$mf";
	      }
	      my $descriptor = {'path' => $input, 'priority' => $prio, 'mf' => $mf};
	      $descriptor->{'type'} = $type if defined $type;
	      push @$soundfonts, $descriptor;
	    } else {
	      log_warning "$input: INFO chunk not found at beginning of file";
	    }
	  } else {
	    log_warning "$input: Not an sf2 soundfont";
	  }
	  close INPUT;
	} else {
	  log_warning "$input: $!";
	}
	$prio += 1;
      }
    }
    die "No usable soundfont found\n" unless defined $soundfonts;
    $master_gain = 0.48; # measured ~0 dB with Aegean in japa

    log_comment sprintf('Connecting synth %s', $immediate_p? (@sinks? "to $sinks[0]": ''): "for write to $output") if $debug || $verbose_p;
    set_sink $sinks[0] if $immediate_p && @sinks;
    my @cmd = ('fluidsynth', '-g', $master_gain,
			     '--midi-channels', scalar(keys %need_instrument),
			     ($immediate_p?
				($use_jack_p? '-j': ('-a', 'pulseaudio')):
				('-a', 'file',
				 '-o', "audio.file.name=$output")),
			     map { $_->{'path'} } @$soundfonts);

    log_command @cmd if $debug;
    $synth = new Expect::Simple({
	'Cmd' => \@cmd,
	'Prompt' => "\n> ",
	'DisconnectCmd' => 'quit',
      });

    # Figure out what instruments to use
    my $instruments = probe_synth_instruments $soundfonts;
    %instrument_name_to_channel_number = ();	# need to reset this for each instance of fluidsynth
    $wood_note = undef;				# and this
    for my $instrument ('Gong', 'Bell', 'Woodblock', 'drum kit', sort keys %need_instrument) { # handle hard-coded values 0-3 first
      if (defined $need_instrument{$instrument} && !defined $instrument_name_to_channel_number{$instrument}) {
	my $midi_instrument_id = scalar keys %instrument_name_to_channel_number;
	my $spec;
	if ($instrument eq 'Gong') {
	  $spec = find_synth_instrument($instruments, $soundfonts, 'Gong!!!', 'Tubular Bells');
	} elsif ($instrument eq 'Bell') {
	  $spec = find_synth_instrument($instruments, $soundfonts, 'Carillon', 'Tubular Bells (damp)', 'Tubular Bells');
	} elsif ($instrument eq 'Church Bells') {
	  # NOTE: instruments in Sonatina only have a range of [48, 84], Chimes also doesn't sound nicer (though it's a single strike)
	  $spec = find_synth_instrument($instruments, $soundfonts, 'Church Bell', 'Church Bells', 'Chimes');
	} elsif ($instrument eq 'Woodblock') {
	  $spec = find_synth_instrument($instruments, $soundfonts, 'Woodblock'); # 000-115
	} elsif ($instrument eq 'drum kit') {
	  $spec = find_synth_instrument($instruments, $soundfonts, 'Jazz Drum Kit', 'Jazz', 'Orchestra Kit');
	} elsif ($instrument eq 'Sine Wave') {
	  $spec = find_synth_instrument($instruments, $soundfonts, 'Sine Wave', '1 kHz Test', '000-008'); # fallback to any celesta
	} elsif ($instrument eq 'Music Box') {
	  # Glockenspiel from Sonatina sounds the most realistic
	  $spec = find_synth_instrument($instruments, $soundfonts, 'Glockenspiel', 'Music Box', '000-010');
	} elsif ($instrument eq 'Organ') {
	  # FIXME: Pipe Organ (Aegean) sounds a lot softer than Church Organ (Tibres of Heaven). Volume is still not equalized
	  $spec = find_synth_instrument($instruments, $soundfonts, 'Pipe Organ', 'Church Organ');	# sonatina 0-19 is not an organ
	} elsif ($instrument eq 'Piano') {
	  # NOTE: These are all 000-000 but they sound very different so there's a preferred order
	  $spec = find_synth_instrument($instruments, $soundfonts, 'Grand Piano C5', 'Concert Grand', 'Grand Piano', '000-000');
	} elsif ($instrument eq 'Glockenspiel') {
	  $spec = find_synth_instrument($instruments, $soundfonts, '000-009');	# glockenspiel
	} elsif ($instrument eq 'Flute') {
	  $spec = find_synth_instrument($instruments, $soundfonts, '000-073');	# flute
	} elsif ($instrument eq 'Recorder') {
	  $spec = find_synth_instrument($instruments, $soundfonts, '000-074');	# recorder
	} elsif ($instrument eq 'Violin') {
	  $spec = find_synth_instrument($instruments, $soundfonts, '000-040');	# violin
	} elsif ($instrument eq 'Viola') {
	  $spec = find_synth_instrument($instruments, $soundfonts, '000-041');	# viola
	} elsif ($instrument eq 'Cello') {
	  $spec = find_synth_instrument($instruments, $soundfonts, '000-042');	# cello
	} elsif ($instrument eq 'Guitar') {
	  $spec = find_synth_instrument($instruments, $soundfonts, '000-026');	# jazz guitar
	} elsif ($instrument eq 'Bass Guitar') {
	  $spec = find_synth_instrument($instruments, $soundfonts, '000-032');	# bass guitar
	} elsif ($instrument eq 'Harp') {
	  $spec = find_synth_instrument($instruments, $soundfonts, 'Concert Harp', 'Harp (sustain)', 'Clavinova Harp', 'Harp');
	} elsif ($instrument eq 'Harpsichord') {
	  $spec = find_synth_instrument($instruments, $soundfonts, 'Harpsichord', "Don's Harpsichord");
	} elsif ($instrument eq 'Guzheng') {
	  $spec = find_synth_instrument($instruments, $soundfonts, 'Guzheng Harp');	# this is unrealistic; this is in reality a really quiet instrument
	} else {
	  die "$instrument: Unhandled instrument\n";
	}
	die "$instrument: Instrument not found\n" unless defined $spec;
	# XXX You can't compensate for gain. First, there is no formula. Second, even if you can find one,
	# XXX a loud note with low gain sounds different from a soft note with high gain,
	# XXX probably because loud and soft notes use different samples
	my($font, $bank, $inst, $zero) = @$spec;
	if ($instrument eq 'Woodblock') {
	  $wood_note = (synth_instrument_name($instruments, $spec) =~ / Kit\b/ || $bank == 128)? 31: $note_to_midi_number{'d#5'};
	}
	send_midi_command "select $midi_instrument_id $font $bank $inst";
	$instrument_name_to_channel_number{$instrument} = $midi_instrument_id;
	$instrument_name_to_mf_velocity{$instrument} = $zero;
	log_debug "instrument $instrument mapped to $midi_instrument_id" if $debug;
      }
    }

    # Set reverb, based on advice from
    # - mrbumpy409. (2012, December 19). The fluidsynth reverb, while not as good as the old Live!/Audigy hardware reverbs (which were 
    #   quite good), can still sound decent [Reply to forum post]. Retrieved from https://forums.scummvm.org/viewtopic.php?t=11632
    send_midi_command "rev_setroomsize 0.61";
    send_midi_command "rev_setdamp 0.23";
    send_midi_command "rev_setwidth 0.76";
    send_midi_command "rev_setlevel 0.57";
    send_midi_command "cho_set_nr 3";
    send_midi_command "cho_set_level 1.2";
    send_midi_command "cho_set_speed 0.3";
    send_midi_command "cho_set_depth 8";
    send_midi_command "reverb on";
    send_midi_command "chorus on";
  }
  return;
}

sub disconnect_synth () {
  if (defined $synth) {
    sleep SECONDS_BEFORE_DISCONNECT if defined $synth && defined $synth->{'.last-note'}; # wait a bit for things to stabilize if we sent anything
    $synth = undef;
    log_debug 'synth disconnected' if $debug;
  }
}
END { disconnect_synth }

sub create_chime_interpretation ($) {
  my($chime_id) = @_;
  die Debug::cvs($chime_id) unless ref $chime_id; #FIXME
  my @it;
  my @t;
  my $t_max;
  for my $chime_id (@{$chime_id->implementation}) {
    no integer;
    # FIXME too much magic
    # each actual defined interpretation is an array of voices, in turn an array of specs where [1] is "time" (note duration)
    my $i = 0;
    for my $voice (@{$interpretation{$chime{$chime_id}}}) {
      $it[$i] = [] unless defined $it[$i];
      if (defined $t_max && defined $t[$i] && $t[$i] < $t_max) {
	my $dt = $t[$i] - $t_max;
	push @{$it[$i]}, ['r', $dt, undef, undef];
	$t[$i] = $t_max;
      }
      for my $note (@$voice) {
	$t[$i] += $note->[1];
	push @{$it[$i]}, $note;
      }
      $i += 1;
    }
    for (my $i = 0; $i < @it; $i += 1) {
      $t_max = $t[$i] if $t_max < $t[$i];
    }
  }
  return @it;
}

sub generate_sound_clip_for_event ($) {
  my($event_id) = @_;
  my $dummy_id = "tmp$$";
  my $temp = get_cache_pathname_for_event($dummy_id);
  my $output = get_cache_pathname_for_event($event_id);
  log_debug sprintf "Event %s has cache pathname %s, using temp file %s", $event_id, $output, $temp if $debug;
  if (!-f $output) {
    log_info "Generating audio for event $event_id";
    local @sinks;
    connect_synth $dummy_id;
    my %leftovers = strike_tune_real(1, create_chime_interpretation(determine_chime_id_for_event($event_id)));
    disconnect_synth;
    my $ok = 0;
    if (!%leftovers) {
      $ok = rename $temp, $output;
      log_error "$output: $!" unless $ok;
    } else {										# see ffmpeg.md for comments
      my @cmd = ('ffmpeg', '-nostdin', '-hide_banner', '-y');				# global options
      push @cmd, ('-loglevel', 0) unless $debug;
      push @cmd, map { ('-i', $_) } ($temp, @{$leftovers{'files'}});			# input files
      push @cmd, ('-filter_complex', $leftovers{'filter-graph'});
      push @cmd, $output;								# output files
      log_command @cmd if $debug;
      local $SIG{'CHLD'} = 'DEFAULT'; # need this to check exit status
      my $st = system { $cmd[0] } @cmd;
      $ok = !$st;
      log_error "$output: $cmd[0] returned status $st" if !$ok;
    }
    log_info "Audio for event $event_id generated" if $ok;
    unlink $temp if -f $temp;
  }
}

sub generate_sound_clips () {
  log_debug "Generating audio files" if $debug;
  disconnect_synth;
  # because of the new composite events (e.g., q0,h4) we can't use enmerate_defined_events any more.
  # instead, we'll call determine_events over 24 hours
  # but because of how night watches work we need to step in less than 3600-second increments or we'll miss some
  my %event;
  for (my $i = 0; $i < 86400; $i += 300) {
    my $t0 = $i + current_time;
    my $c = determine_chinese_time $t0;
    ($_, $_, $_, $_, my $chinese_hour, my $quarter, my $centiday, my $deciday, $_, $_, my $deciday_size) = @$c;
    (my $sec, my $min, my $hour, $_, $_, $_, my $wday) = localtime $t0;
    for my $event (determine_events($t0, $hour, $min, $sec, $chinese_hour, $quarter, $centiday, $deciday, $deciday_size)) {
      $event{+$event->id} = 1;
    }
  }
  log_debug sprintf 'events to generate are: %s', Debug::cvs([sort keys %event]);
  for my $event_id (sort keys %event) {
    generate_sound_clip_for_event $event_id;
  }
}

sub latency_measurable_p () {
  return @sinks < 2;
}

sub play_sound_file_real ($;$$$) {
  my($input, $volume, $start, $end) = @_;
  my $sink = get_sink;
  state $exts = ['wav', 'mp3', 'ogg', 'oga', 'flac'];
  state $ext_re = sprintf('(?:%s)', join('|', @$exts));
  no integer;

  # Find a playable file
  for my $ext (@$exts) {
  last if -f $input;
    $input = "$1.ext" if !-f $input && $input =~ /^(.*?)\.$ext_re$/ && -f "$1.ext";
  }

  # Fork and play it in the background
  my $close_stdin_p = 1;
  my $use_paplay_p = 0;
  my $measure_latency_p = latency_measurable_p;
  my $latency;
  my $expected_output;
  my $t0 = Time::HiRes::time;
  my @cmd;
  if ($use_jack_p) {	# JACK has no concept of sink volume, so need to compensate
    my $effective_volume = $volume * emulated_sink_volume_as_fraction;	# does not need to be an integer at this point
    if ($effective_volume != $volume) {
      log_debug sprintf 'effective volume adjusted from %g to %g', $volume, $effective_volume if $verbose_p || $debug;
      $volume = $effective_volume;
    }
  }
  if ($use_paplay_p && $volume == 100 && !defined $start && !defined $end && $input =~ /\.(?:oga|wav)$/s) {
    @cmd = ('paplay', '-n', $user_agent);
    push @cmd, ('-v') if $measure_latency_p;
    push @cmd, ('-d', $sink) if $sink;
    #push @cmd, ('--volume', 65536*$volume / 100) if $volume != 100;
    $expected_output = 'Stream started.';
    $close_stdin_p = 0; # otherwise paplay craps out
  } else {
    # Ubuntu's mpv accepts --input-terminal no but the Pi only accepts --input-terminal=no (otherwise it thinks "no" is an input file)
    # New mpv on new osmc (2022-09) doesn't understand --volume x, only --volume=x
    @cmd = ('mpv', "--audio-client-name=$user_agent", '--no-video', '--input-terminal=no', "--volume=$volume");
    push @cmd, ($measure_latency_p? '--quiet': '--really-quiet');
    push @cmd, ("--start=$start") if defined $start;
    push @cmd, ("--end=$end") if defined $end;

    # Ubuntu's mpv accepts --ao=pulse::$sink but the Pi says ao doesn't accept sub-options
    # The Pi's mpv is newer so why this happens is a mystery
    # The Pi's system (Debian Buster) has a lot of strange problems, it's newer but lots of things don't work
    if ($sink && $sink =~ /^alsa\//) {	# lol... sigh
      push @cmd, ("--ao=alsa", "--audio-device=$sink");
    } elsif ($use_jack_p) {
      push @cmd, ("--ao=jack");
    } else {
      push @cmd, ("--ao=pulse") if $sink;
    }
    set_sink $sink;
    $expected_output = 'AO: '; # should be 'Playing', but the mpv on the new osmc no longer emits 'Playing' (!)
  }
  push @cmd, $input;
  log_command @cmd if $verbose_p || $debug;
  my $fh = gensym;
  no strict 'refs';
  my $h = $measure_latency_p? open($fh, '-|'): fork;
  use strict;
  die "$cmd[0]: fork: $!\n" unless defined $h;
  if ($h == 0) {
    my $sink = get_sink;
    my $dt = $config->{$sink}->{'delay'}->[0] + 0 if defined $config->{$sink} && defined $config->{$sink}->{'delay'};
    log_debug sprintf "delay %s (interpreted as %f) for %s", $config->{$sink}->{'delay'}->[0], $dt, $sink if $debug || ($verbose_p && $dt);
    Time::HiRes::sleep $dt if defined $dt && $dt > 0;
    POSIX::close(0) if $close_stdin_p;
    exec { $cmd[0] } @cmd;
    die "$cmd[0]: exec: $!\n";
  }
  if ($measure_latency_p) {
    for (;;) {
      no strict 'refs';
      my $s = scalar <$fh>;
      use strict;
    last unless defined $s;
      if (!defined $latency && $s =~ /^$expected_output/) {
	$latency = Time::HiRes::time - $t0;
	log_debug sprintf 'Latency for %s measured at %g', $input, $latency if $debug;
      }
    last if defined $latency; # XXX must exit or we won't until we get past the 10s silence at the end; hopefully nothing more will be output
    }
  }
  $children{$h} = $fh;
  return $latency;
}

sub interpret_volume ($;$) {
  my($volume, $default) = @_;
  if (ref $volume eq 'ARRAY') {
      my($base, $hour, $min, $sec, $deciday, $wday) = @$volume;
      if (defined $wday) {
	no integer;
	my $sink = get_sink();
	my $label = defined $config->{$sink} && defined $config->{$sink}->{'label'}? $config->{$sink}->{'label'}->[0]: "sink $sink";
	my($adj, $error, $reason) = get_time_parametrized_config($sink, 'clock volume', '\d+(?:\.\d+)?', sub {
	    my($target_volume) = @_;
	    no integer;
	    $target_volume >= 0 && $target_volume <= 1;
	  }, $hour, $min, $sec, $deciday, $wday);
	($adj, $reason) = (1, "because no clock volume is defined for sink $sink") unless defined $adj;
	log_info "Clock volume adjusted to $adj for $label $reason" if $debug || $verbose_p;
	$volume = $base * $adj;
      }
  }
  $volume = $default if !defined $volume && defined $default;
  return $volume;
}

sub play_sound_file ($;$$$) {
  my($input, $volume, $start, $end) = @_;
  my $latency;
  if (@sinks) {
    for my $sink (@sinks) {
      log_debug "set sink $sink" if $debug;
      set_sink $sink;
      $latency = play_sound_file_real($input, interpret_volume($volume, 50), $start, $end);
    }
  } else {
    $latency = play_sound_file_real($input, interpret_volume($volume, 50), $start, $end);
  }
  return $latency;
}

sub strike_gong (;$) {
  my($note) = @_;
  if ($note ne 'r') {
    if ($method eq METHOD__SYNTH) {
      send_midi_command sprintf('noteon 0 %d %s', $note_to_midi_number{$note}, $expressive_mark_to_midi_velocity{'ffff'});
    } else {
      $note = 'a#5' if !defined $note || !defined $gong_scale{$note};
      play_sound_file sprintf('%s/%s', $datadir, $gong_scale{$note}), 50;
    }
  }
}

sub strike_bell ($) {
  my($note) = @_;
  if ($note ne 'r') {
    if ($method eq METHOD__SYNTH) {
      send_midi_command sprintf('noteon 1 %d %s', $note_to_midi_number{$note}, $expressive_mark_to_midi_velocity{'fff'});
    } else {
      $note = 'd#5' if !defined $note || !defined $chime_scale{$note};
      play_sound_file sprintf('%s/%s', $datadir, $chime_scale{$note}), 100;
    }
  }
}

sub strike_stick () {
  if ($method eq METHOD__SYNTH) {
    send_midi_command sprintf('noteon 2 %d %s', $wood_note, $expressive_mark_to_midi_velocity{'f'});
  } else {
    #play_sound_file sprintf('%s/269735__theriavirra__drumsticks-stagg-maple-sm5a-powerclick-no4a.wav', $datadir), 70;
    play_sound_file sprintf('%s/claves_ff.mp3', $datadir), 90;
  }
}

sub transpose_note ($;$) {
  my($note, $shift) = @_;
  my $it = $midi_number_to_note[$note_to_midi_number{$note} + $shift] if $note ne 'r';
  return defined $it? $it: $note;
}

sub strike_tune_real ($@) {
  my($construct_filter_graph_p, @tune) = @_;
  my %leftovers;
  my($last_volume_used, @intermediate_input_labels);
  log_debug sprintf "Flag %d, striking %s", $construct_filter_graph_p, join(" \\\\ ", map { join(' ', map { $_->[0] } @$_) } @tune) if $debug || $verbose_p;
  no integer;
  my $semitones = 8;
  my @midi_commands;
  my $percussion_channel = $instrument_name_to_channel_number{'drum kit'};
  my $percussion_mf = $instrument_name_to_mf_velocity{'drum kit'};
  for my $voice (@tune) {
    my $elapsed = 0;
    my $t0 = current_time;
    for my $spec (@$voice) {
      my($note, $time, $velocity, $instrument, $flags) = @$spec;
      $velocity = 127 unless defined $velocity; # NOTE backward compatibility
      $instrument = canonical_instrument $instrument;
      my $velocity_adjustment = defined $instrument_name_to_mf_velocity{$instrument}? $instrument_name_to_mf_velocity{$instrument}/64: 1;
      my $t_i = current_time;
      my $actual_time = $flags->{'actual-duration'};
      my $note_length = $time * $beat_length;
      my $effective_note_length = defined $actual_time? $actual_time * $beat_length: $note_length;
      if (defined $flags && defined $flags->{'directive'}) {
	push @midi_commands, [$elapsed, $flags->{'directive'}, $velocity * $velocity_adjustment];
      } elsif (defined $percussion_note_to_midi_number{$note}) {
	push @midi_commands, [$elapsed, sprintf 'noteon %d %d %d', $percussion_channel, $percussion_note_to_midi_number{$note}, $velocity * $velocity_adjustment];
      } elsif (exists $percussion_note_to_midi_number{$note}) {	# valid percussion note but no MIDI equivalent
	log_debug "percussion note $note has no MIDI equivalent";	# XXX
      } elsif (defined $note_to_midi_number{$note}) {
	my $channel = (defined $instrument_name_to_channel_number{$instrument})? $instrument_name_to_channel_number{$instrument}: 1;
	my $note_number = $note_to_midi_number{$note};
	my $laisser_vibrer_p = 1 if (defined $flags && defined $flags->{'laisser-vibrer'}) || (defined $laisser_vibrer_p{$instrument} && !defined $actual_time);
	push @midi_commands, [$elapsed, sprintf 'noteon %d %d %d', $channel, $note_number, $velocity * $velocity_adjustment];
	push @midi_commands, [$elapsed + $effective_note_length, sprintf 'noteoff %d %d', $channel, $note_number] unless $laisser_vibrer_p;
      } elsif ($note ne 'r') {
	log_debug "strike_tune: $note: \"else\" case reached";
      }
      # Instead of sleeping on the actual note length, we keep track of where we're supposed to be in relation to t0,
      # our initial time. Then calculate how much time we need to sleep to hit the next note at the expected time.
      $elapsed += $note_length;
    }
  }
  if (@midi_commands) { # sort batched-up MIDI commands (to take care of noteoffs) and execute them in order, noteoff must come before noteon
    @midi_commands = sort { $a->[0] <=> $b->[0] || $a->[1] cmp $b->[1] } @midi_commands;
    map { log_debug "schedule: " . Debug::cvs($_) } @midi_commands if $debug > 1;
    my $t0 = current_time; # reset start time
    for (my $i = 0;; $i += 1) {
      my($t, $midi_command, $non_midi_extra) = @{$midi_commands[$i]};
      if (ref $midi_command) {
	my($directive, @args) = @$midi_command;
	if ($directive eq 'play') {
	  my($volume, $filename, $start, $end) = ($non_midi_extra, @args);
	  my $pathname = sprintf('%s/%s.wav', $datadir, $filename);
	  no integer;
	  if ($construct_filter_graph_p) {				# construct ffmpeg filter graph - see ffmpeg.md for comments
	    my $intermediate_input_label = gensym;
	    push @{$leftovers{'files'}}, $pathname;
	    push @intermediate_input_labels, $intermediate_input_label;
	    my @cmd;
	    push @cmd, sprintf('volume=127/%d', $last_volume_used) if defined $last_volume_used;
	    push @cmd, sprintf('volume=%d/127', $volume);
	    push @cmd, sprintf('atrim=%f:%f', $start, $end);
	    push @cmd, sprintf('adelay=%d', 1000*$t) if $t;
	    log_debug sprintf 'intermediate file %s has label %s', $pathname, $intermediate_input_label if $debug;
	    $leftovers{'filter-graph'} .= sprintf('[%d]%s[%s];', scalar @{$leftovers{'files'}}, join(',', @cmd), $intermediate_input_label);
	    $last_volume_used = $volume;
	  } else {
	    play_sound_file $pathname, 100*$volume/127, $start, $end;
	  }
	} else {
	  log_error "strike_tune: Unknown directive \"$directive\"";
	}
      } elsif ($method eq METHOD__SYNTH) {
	send_midi_command $midi_command;
      } elsif (defined $percussion_channel && $midi_command =~ /^noteon $percussion_channel (\d+) (\d+)/) {		# percussion
	my($instrument, $volume) = ($1, $2);
	if ($instrument == $percussion_note_to_midi_number{'cyms'}
	  || $instrument == $percussion_note_to_midi_number{'cymch'}) {
	  strike_gong;
	} else {
	  strike_stick;
	}
      } elsif ($midi_command =~ /^noteon (\d+) (\d+) (\d+)/) {		# pitched
	my($channel, $pitch, $volume) = ($1, $2, $3);
	my $note = $midi_number_to_note[$pitch];
	# The gongs have a range of [c4, g5], or [48, 67]; the Westminster chimes require a range of [b3, g#4] or [47, 56]
	# for just the melody, or [e3, g#4], or [40, 56], if we count also the strikes that count the hours
	# If we just deal with the melody, we therefore need to transpose everything up by 1 to 11 semitones
	# (and be content that the hourly strikes will sound a random note); otherwise we need to transpose it up by 8 to 11 semitones.
	# The VCSL chimes have a slightly narrower range of [c4, f5] or [48, 65] so we'll need to transpose it up by 8 to 9 semitones.
	#strike_gong transpose_note $note, $semitones;
	strike_bell transpose_note $note, $semitones;
      } else {
	log_debug "strike_tune: samples mode reached \"else\" case (midi command was \"$midi_command\")";
      }
    last if $i == $#midi_commands;
      my $dt = $midi_commands[$i + 1]->[0] - $t;
      Time::HiRes::sleep $dt if $dt > 0;
    }
  }
  if (%leftovers) {
    $leftovers{'filter-graph'} .= sprintf('[0]%samix=inputs=%d',
	join('', map { "[$_]" } @intermediate_input_labels),
	@intermediate_input_labels + 1);

    log_debug sprintf('strike_tune_real: returning leftovers=%s', Debug::cvs(\%leftovers)) if $debug;
  }
  return %leftovers;
}

sub strike_tune (@) {
  my @tune = @_;
  log_debug sprintf "Striking %s", join(" \\\\ ", map { join(' ', map { $_->[0] } @$_) } @tune) if $debug || $verbose_p;
  return strike_tune_real 0, @tune;
}

sub update_latency_for_event ($$) {
  my($id, $latency) = @_;
  if (defined $id && defined $latency) {
    my $latency_key = determine_latency_key_from_event_id $id;
    if (defined $expected_latency{$latency_key}) {
      $expected_latency{$latency_key}->remember($latency, $id);
      log_debug sprintf 'measured latency %g for event %s, state updated (currently %s)', $latency, $id, Debug::cvs($expected_latency{$latency_key}) if $debug || $verbose_p;
    } else {
      $expected_latency{$latency_key} = Latency->new($latency, $id);
      $expected_latency{$latency_key}->tag($latency_key);
      log_debug sprintf 'measured latency %g for event %s, state initialized (currently %s)', $latency, $id, Debug::cvs($expected_latency{$latency_key}) if $debug || $verbose_p;
    }
  }
}

sub measure_latency_for_event ($) {
  my($id) = @_;
  my $output = get_cache_pathname_for_event($id);
  my $chime_id = determine_chime_id_for_event $id;
  my $latency;
  if (defined $chime_id && $method eq METHOD__SYNTH && -f $output && !$no_cache_p) {
    $latency = play_sound_file $output, 0;
    update_latency_for_event $id, $latency;
  }
}

sub do_event ($;$$$$$) {
  my($id, $hour, $min, $sec, $deciday, $wday) = @_;
  my $output = get_cache_pathname_for_event($id);
  my $chime_id = determine_chime_id_for_event $id;
  my $latency;
  # TODO XXX id=(q0,h7) -> chime_id=<</id (carillon-whittington11study-q0,h7) /implementation [(carillon-whittington11study-q0) (carillon-whittington11study-h7)] /melody (whittington11study) /mode (carillon)>> /Chime_Id bless
  if (!defined $chime_id) {
    log_debug sprintf "Event %s does not exist for the current mode/melody", $id if $debug;
  } else {
    log_debug sprintf "Cache for event %s (%s) %s", $id, $output, (!-f $output? 'does not exist': $no_cache_p? 'exists but ignored by request': 'exists') if $debug;
    if ($method eq METHOD__SYNTH && -f $output && !$no_cache_p) {
      $latency = play_sound_file $output, (defined $wday? [100, $hour, $min, $sec, $deciday, $wday]: 100);
      update_latency_for_event $id, $latency;
    } else {
      strike_tune create_chime_interpretation($chime_id);
    }
  }
  return $latency;
}

sub restart_script_real () {	# NOTE: this function exists only to silence the "Statement unlikely to be reached" warning
  for my $pid (keys %children) {
    log_info "killing synth $pid" if $debug;
    kill 'TERM', $pid;
  }
  my @cmd = @restart_cmd;
  log_warning 'restarting: '. join(' ', @cmd) if $verbose_p || $debug;
  exec { $cmd[0] } @cmd;
}

sub restart_script () {
  restart_script_real;
  log_warning "restart failed: $!";
}

sub safe_to_restart_p () {
  my @cmd = ('perl', '-cw', $restart_cmd[0]);
  log_command @cmd if $debug;
  local $SIG{'CHLD'} = 'DEFAULT'; # need this to check exit status
  return 0 == system { $cmd[0] } @cmd;
}

sub generate_proofsheet () {
  my @events_to_check = enumerate_defined_events;
  my @events_found;
  my($title, $source, $composer, $year);
  for (my $pass = 0; $pass < 2; $pass += 1) {
    for my $event (@events_to_check) {
      my $id = determine_chime_id_for_event($event);
      if (defined $id) {
	push @events_found, $id if $pass == 0;
	if (!defined $title) {
	  my $description = $pass == 0? \%melody_description: \%mode_description;
	  if (($pass == 0? $id =~ /^carillon-(.*?)-$event$/: $id =~ /^(.*?)-$event$/) && defined $description->{$1}) {
	    $title = $description->{$1}->{'description'};
	    $source = $description->{$1}->{'source'};
	    $composer = $description->{$1}->{'composer'};
	    $year = $description->{$1}->{'year'};
	  }
	}
      }
    }
  last if defined $title;
  }
  my($proportional, $monospaced) = ('Lato', 'Fira Mono');
  print "\\version \"2.18.2\"\n";
  print "\\paper { ";
  print "#(define fonts (make-pango-font-tree \"$proportional\" \"$proportional\" \"$monospaced\" 1))\n";
  print "left-margin = 144\\pt\n";
  print "right-margin = 48\\pt\n";
  print "top-margin = 24\\pt\n";
  print "bottom-margin = 24\\pt\n";
  print "}\n";
  if (defined $title) {
    print "\\header {\n";
    print "title = \\markup {Proof sheet for $title}\n";
    print "subtitle = \\markup {(Source: $source)}\n" if defined $source;
    print "composer = \\markup {$composer}\n" if defined $composer;
    print "}\n\\markup { \\vspace #1 }\n\n";
  }
  for my $id (@events_found) {
    my $tune = $chime{$id};
    my $tune_to_typeset = defined $typesettable_version{$tune}? $typesettable_version{$tune}: $tune;
    my $attr = parse_chime_id $id;
    my $duration = determine_chime_duration $id, undef;
    $tune_to_typeset =~ s/\s*\|\s*/\|\n/sg;	# make barcheck warnings more understandable
    print "\\markup{\\column{\n";
    print "\\vspace #1\n";
    print "\\line{\\bold \"$id\"}\n";
    print "\\line{\\tiny \"", Debug::cvs($attr), "\"}\n";
    printf "\\line{\\tiny \"%.2f s\"}\n", $duration if defined $duration;
    print "\\vspace #0.4\n";
    print "}}\n";
    print "\\noPageBreak\n";
    print "$tune_to_typeset\n\n";
    print "\\markup{Note: melody was defined but not converted}\n" unless $interpretation{$tune};
  }
  print "\\layout { \\context { \\RemoveEmptyStaffContext } }\n";
}

sub usage (;$) {
  my($st) = @_;
  my $h = $st? *STDERR: *STDOUT;
  print $h <<EOF;
Usage: $0 [OPTION]...
Chime on the quarter hour and on the start of every fifth of a night watch.

  -d, --sink SINK             Use the specified SINK for audio
      --nonproportional-watches (NOT IMPLEMENTED)
                              Use watches that are aligned to duodecimal hours
  -j                          Use JACK instead of PulseAudio
  -l, --list                  Display available carillon melodies and exit
  -Q, --qing                  Same as --nonproportional-watches --qing-quarters
      --qing-quarters         Use the Qing quarters system (identical to modern
                              quarters) instead of the ancient centiday system
      --query-deciday         Display the current deciday, followed by "day" or
                              "night", then the hour number or letter, then an
                              equal sign, then the equivalent watch number
                              (if applicable)
  -v, --verbose               Explain what is being done
  -z, --create-cache          Create missing cache files first
      --help                  Display this help and exit
EOF
  print $h <<EOF unless $debug;
                              (--debug --help to show debugging options)
EOF
  print $h <<EOF if $debug;

Options for debugging:

      --debug                 Produce debugging output
      --dump-defs             Dump source chime definitions, then exit
      --dump-notes            Dump compiled chime definitions, then exit
      --melody=MELODY         Use the specified MELODY (overrides config file)
      --method=METHOD         Use the specified METHOD (overrides config file)
      --mode=MODE             Use the specified MODE (overrides config file)
      --no-cache              Ignore any pregenerated audio
      --proofsheet            Generate proofsheet on standard output, then exit
  -q, --quit                  Do not start the main loop
      --test                  Continue with test parameters
      --test-event ID[,ID...] Fire event identified by ID, then exit
      --test-scale            Play the major scale from c4 to c5, if possible
  -W, --what-if=TIME          Continue as if current time were TIME
EOF
  print $h <<EOF;

Night watches are determined according to the proportional decimal time
system in use c. 7-2 century BC in ancient China. For details please see
https://github.com/acli/new_clock/blob/master/doc/Night_watches.md
EOF
  exit $st;
}

###############################################################################

sub normal_shutdown_handler () {
  my $eol = -t STDERR? "\n\n": '';
  log_info sprintf "chimer shut down at real time %.2f%s", time, $eol
	if $verbose_p || $debug || !-t STDERR;

  disconnect_synth;
  exit(0);
}

sub set_shutdown_handler () {
  for my $sig (qw( TERM INT HUP )) {
    $SIG{$sig} = \&normal_shutdown_handler;
  }
}

sub set_die_handler () {
  $SIG{__DIE__} = sub {
      my($sig) = @_;
      for (my $i = 0; caller $i; $i += 1) {
	printf STDERR "\n%s%d: %s", (' ' x $i), $i, join(' ', caller $i);
      }
      disconnect_synth;
      die "\n$sig";
    };
}

sub do_setup () {
  state $setup_done_p = 0;
  set_die_handler;		# Force __DIE__ handler to be re-set here because GetOptions will force it to DEFAULT, which is wrong
  set_shutdown_handler;		# there's reason to believe this was also touched
  if (!$setup_done_p) {
    log_info sprintf "chimer (using %s%s) booted at real time %.2f (time shifted %+.2f) in %s mode%s using %s",
	  $sunrise_module,
	  ($sunrise_module_version? " $sunrise_module_version": ''),
	  $boottime, $time_displacement, $mode, ($mode eq MODE__CARILLON? " (using $melody melody)": ''), $method
	if $verbose_p || $debug || !-t STDERR;

    if (defined $config->{'/'}->{'group'}) {
      my $group = $config->{'/'}->{'group'}->[0];
      if ($group !~ /^\d+$/) {
	my $gid = (getgrnam $group)[2];
	if (defined $gid) {
	  $group = $gid;
	} else {
	  log_error("group $group not found");
	  $group = undef;
	}
      }
      if (defined $group) {
	$) = $group;
	log_error("setgid $group failed: $!") if $!;
      }
    }

    set_test_params if $test_p;
    define_chimes;
    if (defined $melody) {
      my $melody_exists_p = 0;
      for my $event_id (enumerate_defined_events) {
	my $chime_id = determine_chime_id_for_event($event_id);
	my $det = $chime_id;	# new function returns structured object
	$melody_exists_p = 1 if defined $det->{'melody'};
      last if $melody_exists_p;
      }
      if (!$melody_exists_p) {
	log_warning "There is no melody \"$melody\" for mode \"$mode\", melody will be ignored";
	$melody = undef;
      }
    }
    if ($method eq METHOD__SYNTH && $no_cache_p) {
      connect_synth 'test';
    }
    $setup_done_p = 1;
  }
}

sub do_test_setup () {
  set_test_params;
  do_setup;
  connect_synth('test') if $method eq METHOD__SYNTH && $no_cache_p;
}

sub display_info () {
  my $t0 = current_time;
  my $c = determine_chinese_time $t0;
  ($_, $_, $_, $_, my $chinese_hour, my $quarter, my $centiday, my $deciday, $_, $_, my $deciday_size) = @$c;
  printf "current time %d deciday %s%s\n", $t0, $deciday, ($deciday >= 6? sprintf(' (%s)', qw(A B C D E)[$deciday - 6]): '');
}

sub show_scaled_volume_then_exit ($$$) {
  my($k, $v, $f) = @_;
  die "Invalid scale factor $v for --$k\n" if $v < 1;
  my $fmt = $v == 1? '%g': '%d';
  my $t0 = current_time;
  my $c = determine_chinese_time $t0;
  ($_, $_, $_, $_, my $chinese_hour, my $quarter, my $centiday, my $deciday, $_, $_, my $deciday_size) = @$c;
  (my $sec, my $min, my $hour, $_, $_, $_, my $wday) = localtime $t0;
  my $det = &$f($hour, $min, $sec, $deciday, $wday);
  if (ref $det) {
    for my $sink (sort keys %$det) {
      my($adj, $reason) = @{$det->{$sink}};
      printf $fmt, $v * $adj;
      printf " (%s)", $sink if keys %$det > 1;
      print "\n";
    }
  } else {
    printf "$fmt\n", $v * $det;
  }
  exit;
}

sub parse_command_line_arguments () {
  my $what_if;

  select((select(STDERR), $| = 1)[0]); # I don't know why this is needed for STDERR

  # SIGCHLD handler must be IGNORE, otherwise Time::HiRes::sleep will fail randomly
  $SIG{CHLD} = 'IGNORE';

  # Handle config file
  $config = read_ini("$ENV{HOME}/.chimerrc");
  @sinks = @{$config->{'/'}->{'sink'}} if defined $config->{'/'}->{'sink'};
  $mode = $config->{'/'}->{'mode'}->[0] if defined $config->{'/'}->{'mode'};
  $method = $config->{'/'}->{'method'}->[0] if defined $config->{'/'}->{'method'};
  $melody = lc $config->{'/'}->{'melody'}->[0] if defined $config->{'/'}->{'melody'};
  $coords = {'lon' => $config->{'/'}->{'longitude'}->[0], 'lat' => $config->{'/'}->{'latitude'}->[0]}
      if defined $config->{'/'}->{'longitude'} && defined $config->{'/'}->{'latitude'};
  #FIXME die "Melody \"$melody\" is not known\n" unless defined $melody{$melody};
  $datadir = $config->{'/'}->{'datadir'}->[0] if defined $config->{'/'}->{'datadir'};

  # Guess location if not specified in config file
  $coords = guess_coordinates unless defined $coords;
  ($lat, $lon) = ($coords->{'lat'}, $coords->{'lon'}) unless defined $lat;
  die "$0: Can't determine coordinates\n" unless defined $coords;

  # Check command-line arguments
  Getopt::Long::config('bundling');
  GetOptions(
    'D|debug' => sub { $debug += 1; },
    'd|sink=s' => sub { @sinks = $_[1]; },
    'dump-defs' => sub { $latent_action = sub { printf "%s\n", Debug::cvs \%chime; exit disconnect_synth }},
    'dump-notes' => sub { $latent_action = sub { for my $key (sort { Debug::lazy_sorter($a, $b) } keys %chime) {
	    printf "%s => %s\n", $key, Debug::cvs $interpretation{$chime{$key}}
	  };
	exit disconnect_synth }},
    'enable-nonproportional-watches|nonproportional-watches' => \$enable_nonproportional_watches,
    'enable-qing-quarters|qing-quarters' => \$enable_qing_quarters,
    'info' => sub { exit display_info },
    'j' => \$use_jack_p,
    'l|list' => sub { $latent_action = sub { my %a = map { /^carillon-(.*?)-[qh]\d*$/? ($1 => 1): () } keys %chime; # FIXME
	print join('', map { defined $melody_description{$_}?
	      sprintf("%-24s%s%s\n", $_, $melody_description{$_}->{'description'},
		      ($verbose_p? sprintf(' (source: %s)', $melody_description{$_}->{'source'}): '')):
	      "$_\n" } sort keys %a);
	exit disconnect_synth }},
    'melody=s' => \$melody,
    'method=s' => \$method,
    'mode=s' => \$mode,
    'no-cache' => \$no_cache_p,
    'Q|qing' => sub { ($enable_nonproportional_watches, $enable_qing_quarters) = (1, 1); },
    'q|quit' => \$quit_p,
    'query-clock-volume=i' => sub {
	my($k, $v) = @_;
	show_scaled_volume_then_exit($k, $v, sub {
	      my($hour, $min, $sec, $deciday, $wday) = @_;
	      my %it = map { set_sink $_; ( $_ => [ interpret_volume([1, $hour, $min, $sec, $deciday, $wday], 50) ]) } @sinks;
	      return \%it;
	    });
      },
    'query-deciday' => sub {
	my $t0 = current_time;
	my $c = determine_chinese_time $t0;
	($_, $_, $_, $_, my $chinese_hour, my $quarter, my $centiday, my $deciday, $_, $_, my $deciday_size) = @$c;
	printf "%g %s %s%s\n", $deciday, (qw(day night))[int(($deciday - 1)/5)], (qw(1 2 3 4 5 A B C D E))[$deciday - 1],
	    ($deciday > 5? sprintf(' = w%d.%d', $deciday - 5, 5 * ($deciday - int($deciday)) + 1): '');
	exit;
      },
    'query-volume=i' => sub {
	my($k, $v) = @_;
	show_scaled_volume_then_exit($k, $v, sub {
	      my($hour, $min, $sec, $deciday, $wday) = @_;
	      return determine_sink_volumes($hour, $min, $sec, $deciday, $wday);
	    });
      },
    'query-watches' => sub {
	# FIXME: brute force for now
	my $t0 = current_time;
	for (my $t = $t0;; $t += 1) {
	  my $c = determine_chinese_time $t;
	  ($_, $_, $_, $_, my $chinese_hour, my $quarter, my $centiday, my $deciday, $_, $_, my $deciday_size) = @$c;
	last if $t - 86400 > $t0;
	  my $k = $deciday < 6? 1: 5;
	  if (abs($k*$deciday - int($k*$deciday)) < 1e-3) {
	    (my $sec, my $min, my $hour, $_, $_, $_, my $wday) = localtime $t;
	    printf "%d %02d:%02d:%02d %d # %s%s (%.1f)\n", $t, $hour, $min, $sec, $wday,
		    (qw(1 2 3 4 5 A B C D E))[$deciday - 1],
		    ($deciday < 6? '': sprintf(' w%d.%d', int($deciday - 5), (5*$deciday)%5 + 1)),
		    $deciday;
	  }
	  $t += $deciday_size * (1/$k - ($k*$deciday - int($k*$deciday))/$k);
	}
	exit;
      },
    'proofsheet' => sub { do_setup; generate_proofsheet; exit },
    'test' => \$test_p,
    'test-event=s' => sub { do_test_setup; for my $e (split(/,\s*/, $_[1])) {
	    my $t0 = Time::HiRes::time;
	    my $latency = do_event $e;
	    my $dt = determine_event_duration($e, undef) - (Time::HiRes::time - ($t0 + $latency));
	    log_debug "event duration compensation $dt";
	    sleep $dt if $dt > 0 }
	exit },
    'test-scale' => sub { do_test_setup; strike_tune(map {[$_, 1]} @midi_number_to_note[48, 50, 52, 53, 55, 57, 59, 60]);
	exit },
    'test-tune=s' => sub { do_test_setup; strike_tune @{interpret_melody $_[1]};
	exit },
    'v|verbose' => \$verbose_p,
    'W|what-if=s' => \$what_if,
    'z|create-cache' => \$create_cache_p,
    'help' => \&usage,
  ) || exit(1);

  if (defined $what_if) {
    no integer;
    if ($what_if =~ /^[-+]\d+(?:\.\d+)?$/) {
      $time_displacement = $what_if + 0;
    } elsif ($what_if =~ /^\d+(?:\.\d+)?$/) {
      $time_displacement = $what_if - Time::HiRes::time;

      # update the restart command
      my $found_p = 0;
      for (my $i = 0; $i < @restart_cmd; $i += 1) {
	log_debug $restart_cmd[$i];
	if ($i && $restart_cmd[$i - 1] =~ /^(?:-W|--what-if)$/ && $restart_cmd[$i] eq $what_if) {
	  $restart_cmd[$i] = sprintf('%+f', $time_displacement);
	  $found_p = 1;
	} elsif ($restart_cmd[$i] =~ /^(--what-if)=$what_if$/) {
	  $restart_cmd[$i] = sprintf('%s=%+f', $1, $time_displacement);
	  $found_p = 1;
	}
      last if $found_p;
      }
      die "$0: Internal error: Could not update restart command\n" unless $found_p;
    } else {
      die "$0: $what_if: Time displacement must be specified as either absolute Unix time or as +seconds / -seconds\n";
    }
  }
}

sub wait_for_calibration_if_needed () {
  my $det = $config->{'/'}->{'calibrate'};
  # If calibrate is defined, wait until time looks reasonable (e.g., if this is a Pi)
  # We can't really request a calibration (hopefully we're not root!) so this assumes ntpd is running
  if (defined $det) {
    my @cmd = ('ntpdate', '-q', '-u', @$det);
    for (;;) {
      my($server, $delta, $error);
      log_command @cmd if $debug;
      my $pid = open(INPUT, '-|');
      die "$0: wait_for_calibration_if_needed: $cmd[0]: fork: $!\n" unless defined $pid;
      if ($pid) {
	for (;;) {
	  my $s = scalar <INPUT>;
	last unless defined $s;
	  chomp;
	  log_input $s if $debug > 1;
	  if ($s =~ /(?:adjust|step) time server (\S+) offset ([-\+]?\d+\.\d+) sec/s) {	# the Acer says "adjust", the Pi says "step"
	    no integer;
	    ($server, $delta) = ($1, $2 + 0);
	  } elsif ($s =~ /, stratum \d+, offset /s) {	# debugging output from -q
	    ;
	  } else {
	    log_error "Unexpected input: $s";
	  }
	last if defined $server;
	}
	close INPUT;
      } else {
	POSIX::dup2(1, 2);	# redirect stderr to stdout
	exec {$cmd[0]} @cmd;
	die "$0: wait_for_calibration_if_needed: $cmd[0]: exec: $!\n";
      }
      no integer;
      log_info "server $server reports delta $delta" if defined $server;
    last if defined $server && abs($delta) < 1;
      sleep 15;
    }
  }
}

sub do_main_loop () {
  for (my $countdown = COUNTDOWN, my $last_prediction_error, my $t_last_prediction, my %pending_events, my %completed_events;;) {
    my $t0 = current_time;
    my $c = determine_chinese_time $t0;
    ($_, $_, $_, $_, my $chinese_hour, my $quarter, my $centiday, my $deciday, $_, $_, my $deciday_size) = @$c;
    (my $sec, my $min, my $hour, $_, $_, $_, my $wday) = localtime $t0;

    my $max_sleep_time;

    # Detect terminated child processes
    for my $pid (keys %children) {
      if (!kill 0, $pid || waitpid($pid, WNOHANG) == $pid) {
	log_debug "child process $pid has exited" if $debug;
	close $children{$pid} if $children{$pid} =~ /\D/s;
	delete $children{$pid};
      }
    }

    # Determine what should happen next
    # The revised algorithm should have already guaranteed all the events we get are defined in the current personality
    no integer;
    my @event = determine_events($t0, $hour, $min, $sec, $chinese_hour, $quarter, $centiday, $deciday, $deciday_size);
    my $next_event;
    log_debug "Upcoming events determined to be " . Debug::cvs($debug? \@event: [map {$_->id} @event]) if $debug || $verbose_p;
    for my $event (@event) {
      # Don't trust floating point calculations - don't use t as key, use id instead
      $pending_events{+$event->id} = $event;
    }
    # delay night watches and post-hour chimes if they clash with other, more important chimes
    for my $id (sort { $pending_events{$a}->t + $pending_events{$a}->delay <=> $pending_events{$b}->t + $pending_events{$b}->delay } grep { $pending_events{$_}->type =~ /^(?:watch|post-quarter)$/ } keys %pending_events) {
      for my $id2 (sort { $pending_events{$a}->t + $pending_events{$a}->delay <=> $pending_events{$b}->t + $pending_events{$b}->delay } grep { $_ ne $id } keys %pending_events) {
	my $t1_start = $pending_events{$id}->t + $pending_events{$id}->delay;
	my $t2_start = $pending_events{$id2}->t + $pending_events{$id2}->delay;
	my $d1 = determine_event_duration($id, 30);
	my $d2 = determine_event_duration($id2, 30);
	my $t1_end = $t1_start + $d1;
	my $t2_end = $t2_start + $d2;
	if ($t2_start <= $t1_start && $t1_start <= $t2_end) {
	  my $delay = $t2_end - $t1_start + 5;
	  $pending_events{$id}->{'delay'} += $delay;
	  log_debug "$id start time $t1_start delayed by $delay s because it falls within $id2 [$t2_start, $t2_end]";
	} elsif ($t2_start <= $t1_end && $t1_end <= $t2_end) {
	  my $delay = $t2_end - $t1_end + $d1 + 5;
	  $pending_events{$id}->{'delay'} += $delay;
	  log_debug "$id end time $t1_start delayed by $delay s because it falls within $id2 [$t2_start, $t2_end]";
	}
      }
    }
    # remove events that we somehow missed
    for my $id (keys %pending_events) {
      my $e = $pending_events{$id};
      my $t = $e->t;
      $t += $e->delay if defined $e->delay;
      if ($t0 - $t > 60) { # just do it if we missed it by just a fraction of a second, actually it's fine even if it's a whole minute
	log_info sprintf "EVENT %s (%d) MISSED at %d (%.2f too late)", $id, $t, $t0, $t0 - $t;
	delete $pending_events{$id};
      }
    }
    # reconstitute the @event array
    @event = sort { $a->t + $a->delay <=> $b->t + $b->delay } map { $pending_events{$_} } keys %pending_events;

    # Determine when we should wake up; try to make some effort to align it to a second boundary
    my $t1 = current_time;
    my $dt0 = $event[0]->t - $t1;
    my $latency_key0 = determine_latency_key_from_event_id $event[0]->id;
    $dt0 -= $expected_latency{$latency_key0}->predict() if defined $expected_latency{$latency_key0};
    my $t_next = ($countdown && $dt0 > 1)? (int($t0) + 1): ($t1 + $dt0/2);
    my $dt = $t_next - $t1;
    $dt = 0 if $dt < 0;

    # If we have time to generate some sound clips, do it
    if ($dt0 > 90 && $method eq METHOD__SYNTH && !$no_cache_p) {
      my $event = determine_next_uncached_event @event;
      if (defined $event) {
	$max_sleep_time = determine_event_duration($event, 60) + SECONDS_BEFORE_DISCONNECT + 15;
	if ($dt0 > $max_sleep_time) {
	  generate_sound_clip_for_event $event;
	}
	$countdown = 0; # force a re-countdown
      }
    }

    # Ditto for latencies, if it is possible to measure them
    if (latency_measurable_p) {
      my $t1 = current_time;
      my $dt0 = $event[0]->t - $t1;
      if ($dt0 > 90 && $method eq METHOD__SYNTH && !$no_cache_p) {
	my $event = determine_next_event_with_unknown_latency @event;
	measure_latency_for_event $event if defined $event;
      }
    }

    # Debug message
    log_comment sprintf "%10.2f=%02d+%2.2f=%2.2f=%2.2f (Δt=%2.2f) > %s",
	$t0, $chinese_hour, $quarter, $centiday, $deciday, $dt,
	join(', ', map { sprintf(($debug? '%.2f (%+.1f) %s': '%3$s%2$+.1f'), $_->t, ($_->t - $t0), $_->id) } @event) if $verbose_p;

    my $t2 = current_time;
    $dt = $max_sleep_time if defined $max_sleep_time && $dt > $max_sleep_time;
    Time::HiRes::sleep $dt;

    # Check if any event should be fired
    my $now = current_time;
    my $dt_actual = $now - $t2;
    log_warning sprintf "tried to sleep for %.2f s but slept for %.2f s\n", $dt, $dt_actual if $dt_actual > $dt + 1;
    for my $id (sort { $pending_events{$a}->t <=> $pending_events{$b}->t } keys %pending_events) {
      my $e = $pending_events{$id};
      my $t = $e->t;
      my $latency_key = determine_latency_key_from_event_id $id;
      my($effective_latency, $prediction_method) = $expected_latency{$latency_key}->predict() if defined $expected_latency{$latency_key};
      $t += $e->delay if defined $e->delay;
      $t -= $effective_latency if defined $effective_latency;
      $t += $last_prediction_error if defined $last_prediction_error && $last_prediction_error > 0 && $t_last_prediction >= $now - 15; # XXX
      if ($now < $t) {
	;
      } elsif (defined $completed_events{$id} && $now - $completed_events{$id} < 15) { # This should never happen (but it does)
	log_error sprintf "EVENT %s (%.2f) already fired at %.2f (%.2f s ago)\n", $id, $t, $completed_events{$id}, $now - $completed_events{$id} if $debug;
	delete $pending_events{$id};
      } else {
	my $dt = $now - $t;
	log_info sprintf "EVENT %s (%.2f) fired at %.2f (%s)%s", $id, $t, $now, ($dt < 0.01? 'on time': sprintf('%.2f s late', $dt)),
	      (defined $effective_latency? sprintf(' (%.2f latency predicted by %s)', $effective_latency, $prediction_method):
					  ' (unable to predict latency)');
	set_sink_volumes($hour, $min, $sec, $deciday, $wday);
	my $actual_latency = do_event($id, $hour, $min, $sec, $deciday, $wday);

	# Remember prediction error
	my $epsilon = 0.005;
	my $duration = determine_event_duration($id, undef);
	$last_prediction_error = defined $actual_latency && defined $effective_latency? $actual_latency - $effective_latency: undef;
	$t_last_prediction = $now + $duration;
	log_info sprintf 'Latency for %s ending %.2f was %s', $id, $t_last_prediction,
		sprintf((abs($last_prediction_error) < $epsilon? 'perfect':
			$last_prediction_error > 0? 'underestimated by %.2f': 'overestimated by %.2f'), $last_prediction_error),
	    if defined $last_prediction_error;

	$countdown = 0; # force a re-countdown
	$completed_events{$id} = $now;
	delete $pending_events{$id};
      }
    }

    $countdown -= 1;
    $countdown = COUNTDOWN if $countdown < 0;
  }
}

if (!caller) {
  set_die_handler;
  set_shutdown_handler;
  parse_command_line_arguments;
  wait_for_calibration_if_needed;
  do_setup;
  if ($create_cache_p) {
    generate_sound_clips;
    do_setup;
  }
  &$latent_action if defined $latent_action;
  do_main_loop unless $quit_p;
  disconnect_synth;
}

=pod

=head1 HISTORY

Concept from the Javascript chiming clocks:
"Copyright © 2018 by Ambrose Li :-)"

Mostly based on the genmon script for Chinese/Hebrew dates:
"Copyright 2016-2018, 2021 by Ambrose Li <ambrose.li@gmail.com>
The primary purpose of this script is to figure out the year number in the Chinese system
so that I can name my CV's without having to look up two web pages.
Everything else is just for kicks =P"

=cut

1;
