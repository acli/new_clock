#!/usr/bin/perl
# vi:set sw=2 ai sm:
# Copyright © 2021 by Ambrose Li

=pod

=encoding utf8

=head1 NAME

chimer – Re-implementation of the Javascript chiming clocks in Perl

=head1 DESCRIPTION

The primary purpose of this script is to avoid running the two chiming clock pages as Firefox tabs,
because Firefox (and Chromium-based browsers) are now unfriendly to pages that primarily use audio for UI.
Firefox also leaks memory really fast so it's best to not keep Firefox running for long periods of time.

Eventually this script might provide a way to make the genmon script less CPU intensive.

=head1 INTERNALS

=cut

# see https://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default for these crazy hacks
# THERE ARE MORE CRAZY HACKS THERE FOR MORE COMPLEX PROJECTS!!
use v5.12; # minimal for unicode string feature
use v5.14; # //u modifier
use utf8;
open qw( :encoding(UTF-8) :std );
use charnames qw( :full :short );
use feature "unicode_strings";

use warnings qw( FATAL utf8 );
use Encode qw( encode decode );
#@ARGV = map { decode("UTF-8", $_) } @ARGV if grep /\P{ASCII}/ => @ARGV;

binmode STDIN, ':utf8';
binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';



use strict;
use integer;


package Chimer;

use POSIX;
use POSIX ":sys_wait_h"; # for nonblocking read
use DateTime;
use Time::HiRes; # overrides (qw) do not seem to work
use Expect::Simple;

use Exporter;
require Exporter;
use vars qw( @ISA @EXPORT @EXPORT_OK );
@ISA = qw(Exporter);
@EXPORT_OK = qw( $dow_re $dow_range_re %expressive_mark_to_midi_velocity );

use vars qw( @restart_cmd );
@restart_cmd = ($0, @ARGV); # save this because GetOpt will clear @ARGV

use vars qw( $use_datetime_event_sunrise );
use vars qw( $use_datetime_astro_sunrise );
use vars qw( $use_astro_sunrise );
BEGIN {
  if (eval { require DateTime::Event::Sunrise; }) {
    $use_datetime_event_sunrise = 1;
  } elsif (eval { require DateTime::Astro::Sunrise; }) {
    $use_datetime_astro_sunrise = 1;
  } elsif (eval { require Astro::Sunrise; }) {
    $use_astro_sunrise = 1;
  } else {
    die "Cannot find a usable Sunrise package";
  }
}

use Getopt::Long;
use Data::Dumper;

use vars qw( $config );
use vars qw( $debug );
use vars qw( $verbose_p );
use vars qw( $quit_p );
use vars qw( $enable_nonproportional_watches );
use vars qw( $enable_qing_quarters );

use vars qw( $coords );
use vars qw( $lat $lon );
use vars qw( @sinks );
use vars qw( $synth );
use vars qw( %children );

use vars qw( $gong_bank $gong_inst $bell_bank $bell_inst $wood_bank $wood_inst $wood_note $perc_bank $perc_inst $beep_bank $beep_inst );
use vars qw( %instrument_name_to_channel_number );
use vars qw( $fluidR3 );
$fluidR3 = '/usr/share/sounds/sf2/FluidR3_GM.sf2';

use vars qw( $beat_length );
$beat_length = 1;

use vars qw( $boottime );
$boottime = Time::HiRes::time;

use vars qw( $basedir $datadir );
$basedir = $1 if $0 =~ /^(.*?)\/+[^\/]+$/;
$basedir =~ s/(?:^|\/+)bin$//;
$basedir = '.' if $basedir eq '';
$datadir = "$basedir/data";

# number of times we try sleeping for 1 second until we sleep until the target event
sub COUNTDOWN () { 5 } # things stablize after 2-3 times, we do 5 just in case (10 is overkill)

sub MODE__SYSLINE   () { 'sysline' }
sub MODE__CUCKOO    () { 'cuckoo' }
sub MODE__CARILLON  () { 'carillon' }
sub METHOD__SAMPLES () { 'samples' }
sub METHOD__SYNTH   () { 'synth' }

sub MELODY__CANTERBURY    () { 'canterbury' }
sub MELODY__GUILDFORD     () { 'guildford' }
sub MELODY__MAGDALEN      () { 'magdalen' }
sub MELODY__NORWICH       () { 'norwich' }
sub MELODY__TINGTANG      () { 'tingtang' }
sub MELODY__WESTMINSTER   () { 'westminster' }
sub MELODY__WHITTINGTON   () { 'whittington' }
sub MELODY__WHITTINGTON12 () { 'whittington12' }

use vars qw( $mode $method $melody );
$mode   = MODE__CARILLON;
$method = METHOD__SAMPLES;
$melody = MELODY__WESTMINSTER;

# night watch chime patterns
sub LONG_STRIKE  () { 1.5 }
sub SHORT_STRIKE () { 0.5 }
sub GAP          () { 2.5 }
# watch chime patterns: repetitions, pattern
# gap needs to be long enough to hear it, but short enough to not mistake it for a long strike. This is HARD
# but note that w5 is -.... x 5 should fit within 30s of time, so we must have (long + short x 4 + gap) ≤ 6
use vars qw( @watch_chime_pattern );
@watch_chime_pattern = ( # v. https://zh.wikipedia.org/wiki/打更 (q.v.)
   [3, '— .'		],
   [2, '. .'		],
   [3, '— . .'		],
   [4, '— . . .'	],
   [5, '— . . . .'	],
);

use vars qw( @midi_number_to_note %note_to_midi_number );
@midi_number_to_note = (
  'c0', 'c#0', 'd0', 'd#0', 'e0', 'f0', 'f#0', 'g0', 'g#0', 'a0', 'a#0', 'b0',
  'c1', 'c#1', 'd1', 'd#1', 'e1', 'f1', 'f#1', 'g1', 'g#1', 'a1', 'a#1', 'b1',
  'c2', 'c#2', 'd2', 'd#2', 'e2', 'f2', 'f#2', 'g2', 'g#2', 'a2', 'a#2', 'b2',
  'c3', 'c#3', 'd3', 'd#3', 'e3', 'f3', 'f#3', 'g3', 'g#3', 'a3', 'a#3', 'b3',
  'c4', 'c#4', 'd4', 'd#4', 'e4', 'f4', 'f#4', 'g4', 'g#4', 'a4', 'a#4', 'b4',
  'c5', 'c#5', 'd5', 'd#5', 'e5', 'f5', 'f#5', 'g5', 'g#5', 'a5', 'a#5', 'b5',
  'c6', 'c#6', 'd6', 'd#6', 'e6', 'f6', 'f#6', 'g6', 'g#6', 'a6', 'a#6', 'b6',
  'c7', 'c#7', 'd7', 'd#7', 'e7', 'f7', 'f#7', 'g7', 'g#7', 'a7', 'a#7', 'b7',
  'c8', 'c#8', 'd8', 'd#8', 'e8', 'f8', 'f#8', 'g8', 'g#8', 'a8', 'a#8', 'b8',
  'c9', 'c#9', 'd9', 'd#9', 'e9', 'f9', 'f#9', 'g9', 'g#9', 'a9', 'a#9', 'b9',
);
%note_to_midi_number = map { $midi_number_to_note[$_] => $_ } 0..$#midi_number_to_note;

use vars qw( %gong_scale %chime_scale );
%gong_scale = (
  'c4'	=> '582141__strangehorizon__g01-c-4-gong.wav',
  'c#4'	=> '582140__strangehorizon__g02-c-4-gong.wav',
  'd4'	=> '582139__strangehorizon__g03-d-4-gong.wav',
  'd#4'	=> '582138__strangehorizon__g04-d-4-gong.wav',
  'e4'	=> '582145__strangehorizon__g05-e-4-gong.wav',
  'f4'	=> '582144__strangehorizon__g06-f-4-gong.wav',
  'f#4'	=> '582143__strangehorizon__g07-f-4-gong.wav',
  'g4'	=> '582142__strangehorizon__g08-g-4-gong.wav',
  'g#4'	=> '582147__strangehorizon__g09-g-4-gong.wav',
  'a4'	=> '582146__strangehorizon__g10-a-4-gong.wav',
  'a#4'	=> '582156__strangehorizon__g11-a-4-gong.wav',
  'b4'	=> '582155__strangehorizon__g12-b-4-gong.wav',
  'c5'	=> '582154__strangehorizon__g13-c-5-gong.wav',
  'c#5'	=> '582153__strangehorizon__g14-c-5-gong.wav',
  'd5'	=> '582160__strangehorizon__g15-d-5-gong.wav',
  'd#5'	=> '582159__strangehorizon__g16-d-5-gong.wav',
  'e5'	=> '582158__strangehorizon__g17-e-5-gong.wav',
  'f5'	=> '582157__strangehorizon__g18-f-5-gong.wav',
  'f#5'	=> '582162__strangehorizon__g19-f-5-gong.wav',
  'g5'	=> '582161__strangehorizon__g20-g-5-gong.wav',
);
%chime_scale = (
  'c4'	=> 'chimes_C1.ogg',
  'c#4'	=> 'chimes_C#1.ogg',
  'd4'	=> 'chimes_D1.ogg',
  'd#4'	=> 'chimes_D#1.ogg',
  'e4'	=> 'chimes_E1.ogg',
  'f4'	=> 'chimes_F1.ogg',
  'f#4'	=> 'chimes_F#1.ogg',
  'g4'	=> 'chimes_G1.ogg',
  'g#4'	=> 'chimes_G#1.ogg',
  'a4'	=> 'chimes_A1.ogg',
  'a#4'	=> 'chimes_A#1.ogg',
  'b4'	=> 'chimes_B1.ogg',
  'c5'	=> 'chimes_C2.ogg',
  'c#5'	=> 'chimes_C#2.ogg',
  'd5'	=> 'chimes_D2.ogg',
  'd#5'	=> 'chimes_D#2.ogg',
  'e5'	=> 'chimes_E2.ogg',
  'f5'	=> 'chimes_F2.ogg',
);

use vars qw( $last_logged );
sub log_internal ($$;$$$) {
  my($flag, $s, $prefix, $newline_p, $keep_p) = @_;
  $newline_p = 1 if $s =~ s/^\n+//s;
  $newline_p = 0 unless defined $last_logged;
  $newline_p = 1 if defined $last_logged && $last_logged->{'keep'};
  $keep_p = 1 if $debug;
  $prefix .= ': ' if defined $prefix && $prefix =~ /\S/s && $prefix !~ /: $/s;
  chomp $s;
  printf STDERR "%s%10.2f%s\t%s%s%s%s", ($newline_p? "\n": ''),
      Time::HiRes::time, $flag, $prefix, $s, ($newline_p? '': "\033[K"), "\r";

  $last_logged->{'keep'} = $keep_p + 0;
}

sub log_output  ($) { log_internal '>', $_[0] }
sub log_comment ($) { log_internal '#', $_[0] }
sub log_debug   ($) { log_internal '#', $_[0], 'DEBUG', 1, 1 }
sub log_info    ($) { log_internal '#', $_[0], undef,   0, 1 }
sub log_error   ($) { log_internal '#', $_[0], 'ERROR', 1, 1 }
sub log_warning ($) { log_internal '#', $_[0], 'WARNING', 1, 1 }
sub log_command (@) { log_debug 'running: '. join(' ', map { s/([\\"])/\\\1/sg if /\s/; /\s|^$/? "\"$_\"": $_ } @_) }


=pod

=head2 Chime melodies

Each chime melody is internally represented as an array of
B<[>I<midi note name>, I<time in seconds>, I<percentage volume>, I<instrument>B<]> entries
(I<instrument> can be undef),
but written as calls to I<interpret_quarters> which takes 6 parameters:
the length of a beat in seconds, first quarter, second quarter, third quarter, fourth quarter,
definitions for the quarters.

As many definitions as needed can be included, but each definition I<must> be of the form of either of

=over

I<var> = B<\relative> I<pitch> B<{> I<melody> B<}>

I<var> = B<\drums> B<{> I<melody> B<}>

=back

I<melody> is written in LilyPond notation
(in either relative pitch or drum mode, optionally including note lengths and basic expressive marks),
described in

=over

Relative Octave Entry. (n.d.). In I<LilyPond — Notation Reference v2.22.1 (stable-branch)>.
Retrieved August 18, 2021, from http://lilypond.org/doc/v2.22/Documentation/notation/writing-pitches#relative-octave-entry

Percussion notes. (n.d.). In I<LilyPond — Notation Reference v2.22.1 (stable-branch)>.
Retrieved August 20, 2021, from http://lilypond.org/doc/v2.22/Documentation/notation/percussion-notes

=back

I<interpret_quarters> calls I<interpret_melody> to convert this notation into the internal representation described above,
but this conversion is just a simple pattern match and therefore can produce incorrect results.
If results are incorrect but the notation typesets correctly in LilyPond, the bug is in I<interpret_melody>.

The mapping between Lilypond expressive marks and MIDI velocities is based on

=over

Yamaha. (n.d.). I<Everything You've Ever Wanted to Know About Using MIDI with a Disklavier>.
Yamaha Disklavier Education Network.
Retrieved August 19, 2021, from https://www.yamahaden.com/easyblog/entry/everything-you-ve-ever-wanted-to-know-about-using-midi-with-a-disklavier

Vandenneucker, D.Z<Dominique> (2012). MIDI tutorial.
Retrieved September 5, 2021, from http://www.music-software-development.com/midi-tutorial.html

=back

The mapping between Lilypond percussion notes and MIDI percussion notes is based on

=over

General MIDI instrument codes. (n.d.).
Retrieved August 20, 2021, from http://www.ccarh.org/courses/253/handout/gminstruments/

=back

=cut

use vars qw( %ly_notes );
%ly_notes = (
  'ces' => -1, 'c' => 0, 'cis' => 1,
  'des' => 1, 'd' => 2, 'dis' => 3,
  'ees' => 3, 'e' => 4, 'eis' => 5,
  'fes' => 4, 'f' => 5, 'fis' => 6,
  'ges' => 6, 'g' => 7, 'gis' => 8,
  'aes' => 8, 'a' => 9, 'ais' => 10,
  'bes' => 10, 'b' => 11, 'bis' => 12,
);
use vars qw( %percussion_note_to_midi_number );
%percussion_note_to_midi_number = (
  'bassdrum'		=> 36,		'bd'	=> 36,
  'acousticbassdrum'	=> 35,		'bda'	=> 35,
  'snare'		=> 38,		'sn'	=> 38,		# arbitrarily map to sna
  'acousticsnare'	=> 38,		'sna'	=> 38,
  'electricsnare'	=> 40,		'sne'	=> 40,
  'lowfloortom'		=> 41,		'tomfl'	=> 41,
  'highfloortom'	=> 43,		'tomfh'	=> 43,
  'lowtom'		=> 45,		'toml'	=> 45,
  'hightom'		=> 50,		'tomh'	=> 50,
  'lowmidtom'		=> 47,		'tomml'	=> 47,
  'himidtom'		=> 48,		'tommh'	=> 48,
  'highhat'		=> 44,		'hh'	=> 44,		# arbitrarily map to hhp
  'closedhighhat'	=> 42,		'hhc'	=> 42,
  'openhighhat'		=> 46,		'hho'	=> 46,
  'halfopenhighhat'	=> undef,	'hhho'	=> undef,	# don't know how to map
  'pedalhighhat'	=> 44,		'hhp'	=> 44,
  'crashcymbal'		=> 49,		'cymc'	=> 49,		# arbitrarily map to cymca
  'crashcymbala'	=> 49,		'cymca'	=> 49,
  'crashcymbalb'	=> 57,		'cymcb'	=> 57,
  'ridecymbal'		=> 51,		'cymr'	=> 51,		# arbitrarily map to cymra
  'ridecymbala'		=> 51,		'cymra'	=> 51,
  'ridecymbalb'		=> 59,		'cymrb'	=> 59,
  'chinesecymbal'	=> 52,		'cymch'	=> 52,
  'splashcymbal'	=> 55,		'cyms'	=> 55,
  'ridebell'		=> 53,		'rb'	=> 53,
  'cowbell'		=> 56,		'cb'	=> 56,
  'hibongo'		=> 60,		'boh'	=> 60,
  'openhibongo'		=> undef,	'boho'	=> undef,	# don't know how to map
  'muteopenhibongo'	=> undef,	'bohm'	=> undef,	# don't know how to map
  'lobongo'		=> 61,		'bol'	=> 61,
  'openlobongo'		=> undef,	'bolo'	=> undef,	# don't know how to map
  'muteopenlobongo'	=> undef,	'bolm'	=> undef,	# don't know how to map
  'hiconga'		=> 63,		'cgh'	=> 63,		# arbitrarily map to cgho
  'openhiconga'		=> 63,		'cgho'	=> 63,
  'mutehiconga'		=> 62,		'cghm'	=> 62,
  'loconga'		=> 64,		'cgl'	=> 64,
  'openloconga'		=> undef,	'cglo'	=> undef,	# don't know how to map
  'muteloconga'		=> undef,	'cglm'	=> undef,	# don't know how to map
  'hitimbale'		=> 65,		'timh'	=> 65,
  'lotimbale'		=> 66,		'timl'	=> 66,
  'hiagogo'		=> 67,		'agh'	=> 67,
  'loagogo'		=> 68,		'agl'	=> 68,
  'sidestick'		=> 37,		'ss'	=> 37,
  'hisidestick'		=> undef,	'ssh'	=> undef,	# don't know how to map
  'losidestick'		=> undef,	'ssl'	=> undef,	# don't know how to map
  'guiro'		=> 73,		'gui'	=> 73,		# arbitrarily map to guis
  'shortguiro'		=> 73,		'guis'	=> 73,
  'longguiro'		=> 74,		'guil'	=> 74,
  'cabasa'		=> 69,		'cab'	=> 69,
  'maracas'		=> 70,		'mar'	=> 70,
  'shortwhistle'	=> 71,		'whs'	=> 71,
  'longwhistle'		=> 72,		'whl'	=> 72,
  'handclap'		=> 39,		'hc'	=> 39,
  'tambourine'		=> 54,		'tamb'	=> 54,
  'vibraslap'		=> 58,		'vibs'	=> 58,
  'tamtam'		=> undef,	'tt'	=> undef,	# no way to map this
  'claves'		=> 75,		'cl'	=> 75,
  'hiwoodblock'		=> 76,		'wbh'	=> 76,
  'lowoodblock'		=> 77,		'wbl'	=> 77,
  'opencuica'		=> 79,		'cuio'	=> 79,
  'mutecuica'		=> 78,		'cuim'	=> 78,
  'triangle'		=> 81,		'tri'	=> 81,		# arbitrarily map to trio
  'opentriangle'	=> 81,		'trio'	=> 81,
  'mutetriangle'	=> 80,		'trim'	=> 80,
  'oneup'		=> undef,	'ua'	=> undef,	# no idea what this is
  'twoup'		=> undef,	'ub'	=> undef,	# no idea what this is
  'threeup'		=> undef,	'uc'	=> undef,	# no idea what this is
  'fourup'		=> undef,	'ud'	=> undef,	# no idea what this is
  'fiveup'		=> undef,	'ue'	=> undef,	# no idea what this is
  'onedown'		=> undef,	'da'	=> undef,	# no idea what this is
  'twodown'		=> undef,	'db'	=> undef,	# no idea what this is
  'threedown'		=> undef,	'dc'	=> undef,	# no idea what this is
  'fourdown'		=> undef,	'dd'	=> undef,	# no idea what this is
  'fivedown'		=> undef,	'de'	=> undef,	# no idea what this is
);
use vars qw( %expressive_mark_to_midi_velocity );
%expressive_mark_to_midi_velocity = (
  'ppppp'	=> 4,
  'pppp'	=> 8,	# this should be 8 according to Vandenneucker (2012)
  'ppp'		=> 20,	# this should be close to 20 according to Yamaha (n.d.), exactly 20 according to Vandenneucker (2012)
  'pp'		=> 31,
  'p'		=> 42,
  'mp'		=> 53,
  'mf'		=> 64,
  'f'		=> 80,
  'ff'		=> 96,
  'fff'		=> 112,	# this should be close to 110 according to Yamaha (n.d.), exactly 112 according to Vandenneucker (2012)
  'ffff'	=> 119,	# this should be 127 according to Vandenneucker (2012)
  'fffff'	=> 127,
);

sub interpret_absolute_pitch ($) { # interpret c' as c4
  my($s) = @_;
  my $it;
  if ($s =~ /^(\w+)(?:(,*)|('*))$/) {
    $it = $ly_notes{$1} + 12*(3 - length($2) + length($3));
  } else {
    die "Can't interpret absolute pitch \"$s\"";
  }
  return $it;
}

sub interpret_divisor ($) {
  my($s) = @_;
  no integer;
  return !defined $s? $s: $s =~ /\x{5c}longa/? 0.25: $s =~ /\x{5c}breve/? 0.5: $s =~ /^\d+$/? $s + 0: $s; # XXX
}

sub interpret_melody ($$) {
  my($s0, $unit_beat) = @_;
  my $it;
  no integer;

  # NOTE: GetOpt hasn't been called yet so if you need $debug you need to set it here by hand
  my $rest_re = sprintf('(?:r)');
  my $percussion_instrument_re = sprintf('(?:%s)', join('|', keys %percussion_note_to_midi_number));
  my $pitch_re = q(([a-g](?:[ei]s)?)?(?:(,*)|('*)));			# NOTE: 3 captures: base pitch, commas, apostrophes
  my $duration_re = q((?:(\s*\x{5c}longa|\s*\x{5c}breve|\d+)(\.+)?));	# NOTE: 2 captures: divisor, dots
  my $expressive_mark_re = sprintf("(?:%s)", join('|', keys %expressive_mark_to_midi_velocity));
  my $end_re = q((?=\s|\x{7d}|$));					# space or braceright or eof

  my($relative_p, $last_pitch, $drummode_p, $percussive_instrument);
  my $main_instrument = 'Carillon';
  my($tie_p);
  my($note, $divisor, $dots, $volume) = (undef, 4, 0, $expressive_mark_to_midi_velocity{'mf'});
  for (my($s, @stack) = ($s0); $s =~ /\S/s; ) {
    my $gsave =    sub { push @stack,  [$unit_beat, $relative_p, $drummode_p] };
    my $grestore = sub { if (@stack) { ($unit_beat, $relative_p, $drummode_p) = @{ pop @stack }
			      } else { log_error "grestore called but stack is empty" } };
    $s =~ s/^\s*//s;
    my $lhs;
    if ($s =~ s/^\x{7b}\s*//s) {		# braceleft
      &$gsave;

    } elsif ($s =~ s/^\\(?:drums|drummode)\s*\x{7b}//s) {
      &$gsave;
      $drummode_p = 1;

    } elsif ($s =~ s/^\\relative\s*\x{7b}//s) {
      &$gsave;
      $relative_p = 1;

    } elsif ($s =~ s/^\\relative\s+($pitch_re)\s*\x{7b}//s) {
      &$gsave;
      $relative_p = 1;
      $last_pitch = interpret_absolute_pitch $1;

    } elsif ($s =~ s/^\x{7d}\s*//s) {		# braceright
      &$grestore;
    } elsif ($s =~ s/^[\[\]]\s*//s) {		# ignore bracketleft/bracketright = beam on/beam off
      ;
    } elsif ($s =~ s/^\(\s*//s) {		# ignore parenleft = phrasing slur start
      ;
    } elsif ($s =~ s/^\)\s*//s) {		# ignore parenright = phrasing slur end
      ;
    } elsif ($s =~ s/^\|\s*//s) {		# ignore bar checks
      ;
    } elsif ($s =~ s/^\~\s*//s) {		# tie
      $tie_p = 1;
    } elsif ($s =~ s/^\\tempo(?:\s+"[^""]+")?\s+(\d+)\s+=\s+(\d+)\s+//s) {
      $unit_beat = ($1*60)/(4*$2);
    } elsif ($s =~ s/^\\time\s+\d+\/\d+\s+//s) {	# ignore time signature
      ;
    } elsif ($s =~ s/^\\breathe\s+//s) {	# ignore breath marks for now
      ;
    } elsif ($s =~ s/^\\tuplet\s+(\d+)\/(\d+)\s+//s) {
      $unit_beat *= $2;
      $unit_beat /= $1;
    } elsif ($s =~ s/^$duration_re$end_re//s) {
      ($divisor, $dots) = (interpret_divisor $1, length $2);
      log_debug "Duration \"$divisor$dots\" encountered before any rest, pitch, or percussion instrument" unless defined $note;
      $lhs = $note;

    } elsif ($s =~ s/^$rest_re(?:$duration_re)?$end_re//s) {
      my($new_divisor, $new_dots) = ($1, $2);
      ($divisor, $dots) = (interpret_divisor $new_divisor, length $new_dots) if defined $new_divisor;
      $lhs = 'r';

    } elsif ($s =~ s/^($pitch_re)(?:$duration_re)?$end_re//s) {
      my($pitch_as_written, $base_pitch, $lower, $raise, $new_divisor, $new_dots)
	  = ($1, ($ly_notes{$2} + 12)%12, 0 + length $3, 0 + length $4, $5, $6);

      ($last_pitch, $lower, $raise) = (interpret_absolute_pitch $pitch_as_written, undef, undef) if $relative_p && !defined $last_pitch;
      my $last_base_pitch = ($last_pitch + 12)%12;
      ($divisor, $dots) = (interpret_divisor $new_divisor, length $new_dots) if defined $new_divisor;
      my $tentative;
      for (my $i = 0; $i < 8; $i += 1) {
	for my $dir (-1, 1) {
	  my $candidate = $last_pitch + $dir*$i;
	  $tentative = $candidate if $candidate%12 == $base_pitch;
	last if defined $tentative;
	}
      last if defined $tentative;
      }
      my $pitch = $tentative + 12*($raise - $lower);
      $lhs = $midi_number_to_note[$pitch];
      $last_pitch = $pitch;

    } elsif ($s =~ s/^($percussion_instrument_re)(?:$duration_re)?$end_re//s) {
      ($percussive_instrument, my $new_divisor, my $new_dots) = ($1, $2, $3);
      ($divisor, $dots) = (interpret_divisor $new_divisor, length $new_dots) if defined $new_divisor;
      $lhs = $percussive_instrument;

    } elsif ($s =~ s/^\\($expressive_mark_re)\b//s) {
      $volume = $expressive_mark_to_midi_velocity{$1};

    } elsif ($s =~ s/^\\set\s+Staff\.instrumentName\s+=\s+#"([^""]+)"\s*//s) {
      $main_instrument = $1;

    } elsif ($s =~ s/^(\S+)//s) {
      log_debug "Unknown expression \"$1\" discarded";
    } else {
      log_debug "Internal error: \"else\" case reached in interpret_melody, s=($s)";
    }
    if (defined $lhs) {
      my $rhs = $unit_beat * 4 / $divisor;
      for (my $i = $dots, my $adj = $rhs/2; $i; $i -= 1, $adj /= 2) {
	$rhs += $adj;
      }
      if ($tie_p) {
	if (!defined $note) {
	  $tie_p = 0;
	  log_error "Tie ignored because there is no note to tie to";
	} elsif ($note ne $lhs) {
	  $tie_p = 0;
	  log_error "Tie ignored because $note and $lhs are different";
	} else {
	  $it->[+scalar @$it - 1][1] += $rhs;
	}
      }
      my $instrument = ($lhs eq $percussive_instrument || $lhs eq 'r')? undef: $main_instrument; # FIXME
      push @$it, [$lhs, $rhs, $volume, $instrument] unless $tie_p;
      $note = $lhs;
      $tie_p = 0;
    }
  }
  log_debug sprintf "%s interpreted as %s", $s0,
      join(' ', map { $_->[0] . ($_->[1] == $unit_beat? '': sprintf('(%s)', $_->[1]/$unit_beat)) } @$it) if $debug;
  return $it;
}
sub interpret_quarters ($$$$$$@) {
  my($beat_length, $q1_spec, $q2_spec, $q3_spec, $q4_spec, $strike_spec, @elements) = @_;
  my $it;
  my %elements = map { /^\s*(\w+)\s*=\s*(.*)$/s? ($1 => interpret_melody $2, $beat_length): () } @elements;
  for my $spec ($q4_spec, $q1_spec, $q2_spec, $q3_spec, $strike_spec) {
    my @node;
    for my $ref (split(/\s*/, $spec)) {
      die "interpret_quarters: $spec: Unknown reference $ref\n" unless defined $elements{$ref};
      push @node, @{$elements{$ref}};
    }
    push @$it, [@node];
  }
  return $it;
}
sub interpret_watch ($$$$$) {
  my($watch, $volume1, $instrument1, $volume2, $instrument2) = @_;
  my $score;
  my $beat_length = 1;
  my($repeats, $pattern) = @{$watch_chime_pattern[$watch - 1]};
  no integer;
  for (my $i = 0; $i < $repeats; $i += 1) {
    my $previous_length;
    $score .= ($watch == 1? ' r2': ' r4.') if defined $score;
    for my $length (map { $_ ne '.' } split(/\s+/, $pattern)) {
      $score .= ' ' if defined $score;
      if ($length) {
	$score .= (!defined $previous_length || !$previous_length)? sprintf('\%s %s4.', $volume1, $instrument1): $instrument1;
      } else {
	$score .= (!defined $previous_length ||  $previous_length)? sprintf('\%s %s8.', $volume2, $instrument2): $instrument2;
      }
      $previous_length = $length;
    }
  }
  #printf STDERR "%s x%d interpreted as %s\n", $pattern, $repeats, $score;
  return interpret_melody sprintf('\drums { %s }', $score), $beat_length;
}

use vars qw( %melody );
%melody = (
  &MELODY__CANTERBURY => interpret_quarters(1, 'A', 'B', 'C', 'D', 'S',			# source: Starmer (1907, p. 14)
      q( A = \relative c' { \ff g'8. a c4. }),
      q( B = \relative c' { \ff g'8. a c4. r4 d8. c b c2 }),
      q( C = \relative c' { \ff g'8. a c4. r4 d8. c b c2 r4 c8. b g4. }),
      q( D = \relative c' { \ff g'8. a c4. r4 d8. c b c2 r4 c8. b g4. r8 a8. c d c2 }),
      q( S = \relative c' { \fff cis1 })),
  &MELODY__GUILDFORD => interpret_quarters(0.75, 'A', 'B', 'C', 'D', 'S',		# source: Starmer (1907, p. 10)
      q( A = \relative c' { \ff c'2 e,4 a | g1 }),
      q( B = \relative c' { \ff e4 g c b | d, f a g | e1 }),
      q( C = \relative c' { \ff c'4 g a e | f d g e | a f g b | c1 }),
      q( D = \relative c' { \ff c4 g' e c' | b4. a8 g4 e | f a d, g | e2. f4 | g4 c b a | g e c c' | b g a e | g1 }),
      q( S = \relative c' { \fff c1 })),
  &MELODY__MAGDALEN => interpret_quarters(0.625, 'A', 'B', 'C', 'D', 'S',		# source: Starmer (1907, p. 10)
      q( A = \relative c' { \ff b'4 c }),
      q( B = \relative c' { \ff b'4 c c, g' }),
      q( C = \relative c' { \ff g'4 a f e a d, }),
      q( D = \relative c' { \ff g'4 a f e a d, b' c }),
      q( S = \relative c' { \fff c1 })),
  &MELODY__TINGTANG => interpret_quarters(0.625, 'A', 'ABA', 'ABABA', 'ABABABABB', 'S',	# source: Starmer (1907, p. 4, option 3a)
      q( A = \relative c' { \ff c'4 a }),
      q( B = \relative c' { r4 }),
      q( S = \relative c' { \fff f1 })),
  &MELODY__NORWICH => interpret_quarters(0.20, 'A', 'B', 'C', 'D', 'S',			# source: Starmer (1907, p. 11)
      q( A = \relative c' { \ff a'1 g f e d }),
      q( B = \relative c' { \ff d1 e a g f  | g d f e d }),
      q( C = \relative c' { \ff d1 e f a d, | f a g e f | d e g f d }),
      q( D = \relative c' { \ff a'1 e f g d | e f g e a | d, a' g f e | g f e d a' }),
      q( S = \relative c' { \fff r1 d1 })),				# rest inserted to make it sound less rushed
  &MELODY__WESTMINSTER => interpret_quarters(1, 'A', 'BC', 'DEA', 'BCDE F', 'S',
      q( A = \relative e' { \fff gis4 fis e b2  }),
      q( B = \relative e' { \fff e4 gis fis b,2 }),
      q( C = \relative e' { \fff e4 fis gis e2  }),
      q( D = \relative e' { \fff gis4 e fis b,2 }),
      q( E = \relative e' { \fff b4 fis' gis e2 }),
      q( S = \relative e' { \fff e,2 }),
      q( F = \relative e' { r1 })),
  &MELODY__WHITTINGTON => interpret_quarters(0.625, 'E', 'AB', 'CDE', 'ABCD F', 'S',	# 0.5 sounds way to rushed, but 0.75 sounds too slow
      q( A = \relative e' { \ff e'8. fis, dis' gis,4 cis8. a b e,2..            }),
      q( B = \relative e' { \ff e'8. cis a fis4 dis'8. b gis e2..               }),
      q( C = \relative e' { \ff e'8. dis a gis4 cis8. b fis e2..                }),
      q( D = \relative e' { \ff fis8. a cis e4 dis8. b gis e2..                 }),
      q( E = \relative e' { \ff \tuplet 22/21 { e'8. dis cis b a gis fis } e2.. }),
      q( S = \relative e' { \fff e,2 }),
      q( F = \relative e' { r8 })),
  &MELODY__WHITTINGTON12 => interpret_quarters(0.625, 'A', 'B', 'C', 'D', 'S',		# source: Starmer (1907, p. 5)
      q( A = \relative c' { \ff c'4 g' f e }),
      q( B = \relative c' { \ff c'4 g' f e g d }),
      q( C = \relative c' { \ff a'4 g f e g d' c e d }),
      q( D = \relative c' { \ff c'4 g' f e g d c a f e g d r8 }),	# rest inserted to make the hour strike sound less abrupt
      q( S = \relative c' { \fff c1 })),
) unless caller;
unless (caller) {
  $melody{'cambridge'} = $melody{&MELODY__WESTMINSTER};
  $melody{'st mary'} = $melody{&MELODY__WHITTINGTON};
}

use vars qw( %chime );
%chime = (
  &MODE__SYSLINE => interpret_melody(q( \relative c' { \set Staff.instrumentName = #"Terminal Bell" \mf f''''8 r4. }), 1),
  'w1.1' => interpret_watch(1, 'ff', 'cyms', 'ff', 'tamb'),
  'w2.1' => interpret_watch(2, 'ff', 'cyms', 'ff', 'tamb'),
  'w3.1' => interpret_watch(3, 'ff', 'cyms', 'ff', 'tamb'),
  'w4.1' => interpret_watch(4, 'ff', 'cyms', 'ff', 'tamb'),
  'w5.1' => interpret_watch(5, 'ff', 'cyms', 'ff', 'tamb'),
  'w1'   => interpret_watch(1, 'ff', 'cymch', 'ff', 'cl'),
  'w2'   => interpret_watch(2, 'ff', 'cymch', 'ff', 'cl'),
  'w3'   => interpret_watch(3, 'ff', 'cymch', 'ff', 'cl'),
  'w4'   => interpret_watch(4, 'ff', 'cymch', 'ff', 'cl'),
  'w5'   => interpret_watch(5, 'ff', 'cymch', 'ff', 'cl'),
  'w1.5' => interpret_watch(1, 'ff', 'cymch', 'ff', 'mar'),
  'w2.5' => interpret_watch(2, 'ff', 'cymch', 'ff', 'mar'),
  'w3.5' => interpret_watch(3, 'ff', 'cymch', 'ff', 'mar'),
  'w4.5' => interpret_watch(4, 'ff', 'cymch', 'ff', 'mar'),
  'w5.5' => interpret_watch(5, 'ff', 'cymch', 'ff', 'mar'),
) unless caller;


sub start_of_day ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  return mktime(0, 0, 0, $mday, $mon, $year);
}

sub yesterday ($) {
  my($t) = @_;
  return start_of_day(start_of_day($t) - 12*3600);
}

sub tomorrow ($) {
  my($t) = @_;
  return start_of_day(start_of_day($t) + 36*3600);
}

sub estimate_sunrise ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->start;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[0];
    $it = $tmp->strftime('%s');
  } else {
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunrise;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub estimate_sunset ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->end;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[1];
    $it = $tmp->strftime('%s');
  } else {
    # this should be the same as the else case in estimate_sunrise except the last line
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunset;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub trim ($) {
  my($s) = @_;
  $s =~ s/^\s+//;
  $s =~ s/\s+$//;
  return $s;
}

sub guess_city () {
  my $input = '/etc/localtime';
  my $det = readlink $input;
  die "$input: $!\n" unless defined $det;
  return $1 if $det =~ /([^\/]+)$/s;
}

sub guess_coordinates () {
  my $it;
  my $city = guess_city;
  log_comment "guessed city=($city)" if $debug;
  my @cmd = qw(hebcal cities);
  log_command @cmd if $debug;
  my $pid = open(INPUT, '-|');
  die "$0: guess_coordinates: $cmd[0]: fork: $!\n" unless defined $pid;
  if ($pid) {
    my $re = quotemeta $city;
    for (;;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp;
      if ($s =~ /^$re \((\d+)d(\d+)' ([NS]) lat, (\d+)d(\d+)' ([EW]) long/) {
	no integer;
	$it = {
	      'lat' => ($1 + $2/60)*($3 eq 'N'? 1: -1),
	      'lon' => ($4 + $5/60)*($6 eq 'E'? 1: -1),
	    };
      }
    last if defined $it;
    }
    close INPUT;
  } else {
    exec {$cmd[0]} @cmd;
    die "$0: guess_coordinates: $cmd[0]: exec: $!\n";
  }
  return $it;
}

# NOTE: modified to act like the current PHP version (root section goes to /, duplicate keys allowed and get stashed into an array)
sub read_ini ($) {
  my($input) = @_;
  my $it;
  local(*INPUT, $.);
  if (open(INPUT, '<:utf8', $input)) {
    for (my $section = '/';;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp $s;
      if ($s =~ /^\s*(?:[#\%;]|$)/) {
	;
      } elsif ($s =~ /^\s*\[\s*([^\[\]]+?)\s*\]\s*$/) {
	$section = $1;
      } elsif ($s =~ /^\s*([^=]+?)\s*=\s*(.*)/) {
	if (defined $section) {
	  $it->{$section}->{$1} = [] unless defined $it->{$section}->{$1};
	  push @{$it->{$section}->{$1}}, $2;
	} else {
	  $it->{$1} = [] unless defined $it->{$1};
	  push @{$it->{$1}}, $2;
	}
      } else {
	warn "$input:$.: Warning: Unknown input \"$s\"\n";
      }
    }
    close INPUT;
  }
  return $it;
}

use vars qw( $deciday_1_re $deciday_2_re $deciday_3_re $deciday_4_re $deciday_5_re );
use vars qw( $deciday_6_re $deciday_7_re $deciday_8_re $deciday_9_re $deciday_10_re );
use vars qw( $clocktime_re $deciday_re );
$clocktime_re = '(?:(?:0?\d|1\d|2[0-3]):[0-5]\d|24:00)';
$deciday_1_re = '\b(?:morning|ˈ?dziu)\b';
$deciday_2_re = '\b(?:forenoon|ˌ?jy)\b';
$deciday_3_re = '\b(?:midday|ˈ?dzuŋ)\b';
$deciday_4_re = '\b(?:afternoon|ˈbou)\b';
$deciday_5_re = '\b(?:evening|ˍdzik)\b';
$deciday_6_re = '\b(?:A|ˉ?gap)\b';
$deciday_7_re = '\b(?:B|ˍ?jyt)\b';
$deciday_8_re = '\b(?:C|ˊ?biŋ)\b';
$deciday_9_re = '\b(?:D|ˈ?diŋ)\b';
$deciday_10_re = '\b(?:E|ˍ?mou)\b';
$deciday_re = "(?:$deciday_1_re|$deciday_2_re|$deciday_3_re|$deciday_4_re|$deciday_5_re|$deciday_6_re|$deciday_7_re|$deciday_8_re|$deciday_9_re|$deciday_10_re)";

use vars qw( $sun_re $mon_re $tue_re $wed_re $thu_re $fri_re $sat_re $dow_re $dow_range_re );
$sun_re = '(?:\b(?:U|Sun(?:day)?)\b)';
$mon_re = '(?:\b(?:M|Mon(?:day)?)\b)';
$tue_re = '(?:\b(?:T|Tue(?:s(?:day)?)?)\b)';
$wed_re = '(?:\b(?:W|Wed(?:nes(?:day)?)?)\b)';
$thu_re = '(?:\b(?:R|Thu(?:r(?:s(?:day)?)?)?)\b)';
$fri_re = '(?:\b(?:F|Fri(?:day)?)\b)';
$sat_re = '(?:\b(?:S|Sat(?:urday)?)\b)';
$dow_re = "(?:$sun_re|$mon_re|$tue_re|$wed_re|$thu_re|$fri_re|$sat_re)";
$dow_range_re = "(?:[UMTWRFS]+|(?:$dow_re(?:\\s*[-,]\\s*$dow_re)*))";

sub parse_dow ($) {
  my($s) = @_;
  local($`, $&, $');
  return $s =~ /^$sun_re$/? 0:
	 $s =~ /^$mon_re$/? 1:
	 $s =~ /^$tue_re$/? 2:
	 $s =~ /^$wed_re$/? 3:
	 $s =~ /^$thu_re$/? 4:
	 $s =~ /^$fri_re$/? 5:
	 $s =~ /^$sat_re$/? 6: undef;
}


sub parse_clocktime ($) {
  my($s) = @_;
  local($`, $&, $', $1, $2);
  no integer;
  return $s =~ /^(?=$clocktime_re$)(\d+):(\d\d)/? $1 + $2/60: undef;
}

sub parse_named_deciday ($) {
  my($s) = @_;
  local($`, $&, $', $1, $2);
  no integer;
  return $s =~ /^$deciday_1_re$/? 1:
	 $s =~ /^$deciday_2_re$/? 2:
	 $s =~ /^$deciday_3_re$/? 3:
	 $s =~ /^$deciday_4_re$/? 4:
	 $s =~ /^$deciday_5_re$/? 5:
	 $s =~ /^$deciday_6_re$/? 6:
	 $s =~ /^$deciday_7_re$/? 7:
	 $s =~ /^$deciday_8_re$/? 8:
	 $s =~ /^$deciday_9_re$/? 9:
	 $s =~ /^$deciday_10_re$/? 10: undef
}

sub parse_dow_range ($) {
  my($s) = @_;
  my $it;
  if (defined $s) {
    local($`, $&, $', $1, $2);
    if ($s =~ /^[UMTWRFS]+$/) { # Waterloo style single-letter codes
      $it = join(',', map { parse_dow($_) } split(//, $s));
    } else {
      $it = join('', map { substr($_, 0, 1) =~ /[-,]/? (substr($_, 0, 1) . parse_dow(substr($_, 1))): parse_dow($_) } split(/(?=[-,]|$)/, $s));
      $it = 'ERROR' unless $it =~ /^\d+(?:[-,]\d+)*$/;

      # Handle looparounds like Fri-Sun or Sat-Tue
      $it =~ s/\b([1-6])-([1-6])\b/ $1 < $2? $&: "$1-6,0-$2" /ge;
      $it =~ s/\b(?<!-)([1-5])-0\b/\1-6,0/g;
      $it =~ s/\b(?<!-)(6)-0\b/\1,0/g;
    }
  }
  return $it;
}

sub parse_clocktime_range ($) {
  my($s) = @_;
  my $it;
  if (defined $s) {
    local($`, $&, $', $1, $2);
    $it = join('', map { substr($_, 0, 1) =~ /[-,]/? (substr($_, 0, 1) . parse_clocktime(substr($_, 1))): parse_clocktime($_) } split(/(?=[-,]|$)/, $s));
    $it = 'ERROR' unless $it =~ /^\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*$/;

    # Handle looparounds like 23:00-07:00
    no integer;
    $it =~ s/\b(\d+(?:.\d+)?)-(0)\b/ $1 < $2? $&: "$1-24" /ge;
    $it =~ s/\b(\d+(?:.\d+)?)-(\d+(?:.\d+)?)\b/ $1 < $2? $&: "$1-24,0-$2" /ge;
  }
  return $it;
}

sub parse_named_deciday_range ($) {
  my($s) = @_;
  my $it;
  if (defined $s) {
    local($`, $&, $', $1, $2);
    $it = join('', map { substr($_, 0, 1) =~ /[-,]/? (substr($_, 0, 1) . parse_named_deciday(substr($_, 1))): parse_named_deciday($_) } split(/(?=[-,]|$)/, $s));
    $it = 'ERROR' unless $it =~ /^\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*$/;

    # Handle looparounds like C-morning
    no integer;
    $it =~ s/\b(\d+)-(1)\b/ $1 < $2? $&: "$1-10,1" /ge;
    $it =~ s/\b(\d+)-(\d+)\b/ $1 < $2? $&: "$1-10,1-$2" /ge;
  }
  return $it;
}


# Quarters are weird. See https://zh.wikipedia.org/wiki/%E5%88%BB
#                     and http://yywz.snnu.edu.cn/show.aspx?id=697&cid=26
# Apparently the old Chinese system also used proportional hours... so we'll need to refactor things here at some point
# http://www.twword.com/wiki/%E5%B9%B2%E6%94%AF%E7%B4%80%E6%B3%95
sub determine_chinese_time ($) {
  my($t) = @_;
  my $it;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $midnight = start_of_day $t;
  my $deciday;
  my $slice; # size of proportional hour, needed to figure out when to sound the next chime
  # NOTE: according to one source (forgot which), the first hour (ˊdzi) spans [2300, 0100) but the new day still starts at 0000. Very odd :-/
  # therefore the old adjustment for [2300, 0000) has been deleted
  if (defined $coords) {
    my $today = start_of_day $t;
    my $yesterday = yesterday $t;
    my $tomorrow = tomorrow $t;
    my($daybreak, $slice_start, $slice_end, $starting_hour);
    # Proportional hour is used in a very early system (Spring and Autumn Period / Warring States),
    # but I don't even have an idea when the day starts (probably day before night) so we'll arbitrarily use sunrise as cutoff
    if ($t < estimate_sunrise($today)) {
      $daybreak = estimate_sunrise($yesterday);
      $slice_start = estimate_sunset($yesterday);
      $slice_end = estimate_sunrise($today);
      $starting_hour = 6;
    } elsif ($t < estimate_sunset($today)) {
      $daybreak = estimate_sunrise($today);
      $slice_start = $daybreak;
      $slice_end = estimate_sunset($today);
      $starting_hour = 1;
    } else {
      $daybreak = estimate_sunrise($today);
      $slice_start = estimate_sunset($today);
      $slice_end = estimate_sunrise($tomorrow);
      $starting_hour = 6;
    }
    if ($slice_start && $slice_end) {
      no integer;
      $slice = ($slice_end - $slice_start)/5;
      $deciday = $starting_hour + ($t - $slice_start)/$slice;
    }
  }
  my($greg_year, $greg_month, $greg_day) = ($year + 1900, $mon + 1, $mday);
  my $relative_chinese_hour = eval { no integer; fmod(($t - ($midnight - 3600))/7200, 12) };
  my $chinese_hour = $relative_chinese_hour + 1;
  my $quarter;
  my $centiday = eval { no integer; ($t - $midnight)/864 };
  if ($enable_qing_quarters) {
    $quarter = $min/15 + 1;
    $quarter += 4 if $hour%2 == 0;
  } else {
    # NOTE: traditionally these aren't quarters, but number of centiday marks past the beginning of the hour
    no integer;
    #
    # 0.5 hours maps exactly to 0 centidays. So to calculate the reporting origin, which is fractional.
    # Each hour is 86400/12 seconds, each centiday is 86400/100 seconds, so each hour is 100/12 centidays
    # In theory, each zero-based hour h begins exactly at ⌊h - 0.5⌋*100/12 centidays
    # However, when h ∈ [0, 0.5) this gives unexpected results because the formula will give a negative result
    # There's no easy way to fix this because reporting origins are hour-aligned, not half-hour aligned
    # (so we can't even change ⌊h - 0.5⌋ to (⌊h*2 - 1⌋%24)/2 because this breaks for h > 1.0)
    #
    my $reporting_origin = POSIX::floor(($relative_chinese_hour < 0.5? 11.5: (int($relative_chinese_hour) - 0.5)) * 100 / 12);
    log_debug "relative_chinese_hour=$relative_chinese_hour => reporting_origin=$reporting_origin" if $debug;
    $quarter = $centiday - int($reporting_origin);
  }
  $it = [undef, undef, undef, undef, $chinese_hour, $quarter, $centiday, $deciday,
      $wday, eval { no integer; $relative_chinese_hour < 0.5 }, $slice];
  return $it;
}

sub determine_prechime_length ($$) {
  my($quarter, $default) = @_;
  my $it = $default;
  my $tune;
  if ($mode eq MODE__CARILLON && defined $melody{$melody}) {
    $tune = $melody{$melody}->[$quarter%4];
  } elsif (defined $chime{$mode}) {
    $tune = $chime{$mode};
  }
  if (defined $tune) {
    $it = 0;
    for my $note (@$tune) {
      no integer;
      $it += $note->[1];
    }
  }
  return $it;
}

sub determine_events ($$$$$$$$$) {
  my($t0, $hour, $min, $sec, $chinese_hour, $quarter, $centiday, $deciday, $deciday_size) = @_;
  my @it;
  no integer;
  my $global_delay = $config->{'/'}->{'delay'}->[0] + 0 if defined $config->{'/'}->{'delay'};
  $global_delay = 0 unless defined $global_delay;

  # Western quarter-hour chime
  # Make absolutely sure we have a chime event, in case it gets thrown out because we're too close to the actual next quarter hour
  my $seconds_since_hour_change = 60*$min + $sec;
  my $t_next_quarter_chime = int($t0) + (900 - $seconds_since_hour_change%900) + $global_delay;
  my $next_quarter = (int($seconds_since_hour_change / 900) + 1)%4;
  my $next_hour = (($next_quarter? $hour: $hour + 1) + 11)%12 + 1;
  my $quarter_chime_event_pushed_p = 0;
  die "Calculation error, next quarter $t_next_quarter_chime is in the past (t0=$t0)" if $t_next_quarter_chime < int($t0);
  die "Calculation error, next quarter $t_next_quarter_chime more than 15 minutes away (t0=$t0)" if $t_next_quarter_chime - $t0 > 900;
  for (my $i = 0; $i < 2; $i += 1,
			  $t_next_quarter_chime += 900,
			  $next_quarter = ($next_quarter + 1)%4,
			  $next_hour += !$next_quarter, $next_hour = ($next_hour - 1)%12 + 1) {
    my $prechime_length;
    if ($next_quarter == 0) {
      push @it, {
	't' => $t_next_quarter_chime,
	'id' => "h$next_hour",
	'type' => 'hour',
	'comment' => "hour $next_hour chime",
      };
      $prechime_length = determine_prechime_length(0, 25);
    } elsif ($next_quarter == 1) {
      $prechime_length = determine_prechime_length(1, 5);
    } elsif ($next_quarter == 2) {
      $prechime_length = determine_prechime_length(2, 10);
    } elsif ($next_quarter == 3) {
      $prechime_length = determine_prechime_length(3, 15);
    }
    if ($t_next_quarter_chime - $prechime_length >= $t0) {
      push @it, {
	't' => $t_next_quarter_chime - $prechime_length,
	'id' => "q$next_quarter",
	'type' => 'quarter',
	'comment' => "hour $next_hour quarter $next_quarter prechime",
	'anticipating' => $prechime_length,
      };
      $quarter_chime_event_pushed_p = 1;
    }
  last if $quarter_chime_event_pushed_p;
  }

  # Spring-and-Autumn-era proportional-deciday-based night watch chimes
  # 1 watch is exactly 1 deciday, which is not actually 1/10 of a day but 1/5 of the current proportional moitie
  if ($deciday > 5 && $deciday < 6) { # 5 is the last deciday in the "day" moitie
    my $t_first_watch = $t0 + (6 - $deciday)*$deciday_size;
    push @it, {
      't' => $t_first_watch,
      'id' => 'w1.1',
      'type' => 'watch',
      'comment' => 'watch 1',
    };
  } elsif ($deciday >= 6) {
    my $decidays_into_the_night = $deciday - 6;
    my $subwatches_into_the_night = 5*$decidays_into_the_night;
    my $zero_based_next_subwatch = (int($subwatches_into_the_night) + 1)%25;
    if ($zero_based_next_subwatch) {
      my $next_watch = int($zero_based_next_subwatch/5) + 1;
      my $next_subwatch = $zero_based_next_subwatch%5 + 1;
      my $t_next_subwatch = $t0 + (1 - fmod($subwatches_into_the_night, 1)) * ($deciday_size/5) + $global_delay;
      push @it, {
	't' => $t_next_subwatch,
	'id' => "w$next_watch.$next_subwatch",
	'type' => 'watch',
	'comment' => "watch $next_watch.$next_subwatch",
      };
      # Check if we should delay this because it would run into the middle of a quarter hour chime
      my $delay = 0;
      for my $event (@it) {
	my $t = $event->{'t'};
	if ($event->{'id'} =~ /^[qh]/ && (($t - 30 <= $t_next_subwatch + $delay && $t_next_subwatch + $delay <= $t)
				      || ($t <= $t_next_subwatch + $delay && $t_next_subwatch + $delay <= $t + 30))) {
	  $delay = ($t + 30) - $t_next_subwatch;
	  $it[$#it]->{'delay'} = $delay;
	}
      }
    }
  }

  @it = sort { $a->{'t'} <=> $b->{'t'} } @it;
  return wantarray? @it: \@it;
}

sub in_range ($$) {
  my($n, $range_spec) = @_;
  my $it = 0;
  no integer;
  for my $subrange_spec (split(/\s*,\s*/, $range_spec)) {
    die "in_range: Malformed element \"$subrange_spec\" in \"$range_spec\"" unless $subrange_spec =~ /^(\d+(?:\.\d+)?)(?:-(\d+(?:\.\d+)?))?$/;
    if (defined $2) {
      $it = $1 <= $n && $n <= $2;
    } else {
      $it = $1 == $n;
    }
  last if $it;
  }
  return $it;
}

sub in_semi_closed_range ($$) {
  my($n, $range_spec) = @_;
  my $it = 0;
  no integer;
  for my $subrange_spec (split(/\s*,\s*/, $range_spec)) {
    die "in_range: Malformed element \"$subrange_spec\" in \"$range_spec\"" unless $subrange_spec =~ /^(\d+(?:\.\d+)?)(?:-(\d+(?:\.\d+)?))?$/;
    if (defined $2) {
      $it = $1 <= $n && $n < $2;
    } else {
      $it = $1 == $n;
    }
  last if $it;
  }
  return $it;
}

sub get_sink () {
  return $ENV{'PULSE_SINK'};
}

sub set_sink ($) {
  my($sink) = @_;
  $ENV{'PULSE_SINK'} = $sink if defined $sink;
}

sub set_test_params () {
  @sinks = @{$config->{'test'}->{'sink'}} if defined $config->{'test'}->{'sink'};
  $mode = $config->{'test'}->{'mode'}->[0] if defined $config->{'test'}->{'mode'};
  $method = $config->{'test'}->{'method'}->[0] if defined $config->{'test'}->{'method'};
  $melody = lc $config->{'test'}->{'melody'}->[0] if defined $config->{'test'}->{'melody'};
  log_debug sprintf "test params set at %.2f: mode=%s, method=%s, melody=%s", $boottime, $mode, $method, $melody if $verbose_p || $debug;
}

sub set_sink_volume ($$) {
  my($sink, $volume) = @_;
  my @cmd = ('pactl', 'set-sink-volume', $sink, int($volume));
  log_command @cmd if $debug;
  system { $cmd[0] } @cmd;
}

sub determine_volume_from_directive_and_time ($$$$$$) {
  my($directive, $hour, $min, $sec, $deciday, $wday) = @_;
  my($target_dow, $target_times, $target_volume, $dow_in_range_p, $time_in_range_p);
  my($result, $error);
  no integer;
  my $hours_past_midnight = $hour + $min/60 + $sec/3600;
  if ($directive =~ /^(?:($dow_range_re)\s+)?hours?\s+(\d+(?:[-,]\d+)*)\s*[:=]\s*(\d+(?:\.\d+)?)$/) {		# integer to integer
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range($hour, $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?hours?\s+(\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*)\s*[:=]\s*(\d+(?:\.\d+)?)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range($hours_past_midnight, $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?decidays?\s+(\d+(?:[-,]\d+)*)\s*[:=]\s*(\d+(?:\.\d+)?)$/) {	# integer to integer
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range(int($deciday), $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?decidays?\s+(\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*)\s*[:=]\s*(\d+(?:\.\d+)?)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range($deciday, $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?($clocktime_re-$clocktime_re)\s*[:=]\s*(\d+(?:\.\d+)?)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_semi_closed_range($hours_past_midnight, parse_clocktime_range $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?($deciday_re(?:\s*-\s*$deciday_re)?)\s*[:=]\s*(\d+(?:\.\d+)?)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range(int($deciday), parse_named_deciday_range $target_times);
  } elsif ($directive =~ /^\d+(?:\.\d+)?$/) {	# just a number
    ($target_dow, $time_in_range_p, $target_volume) = (undef, 1, $directive);
  } else {
    $error = "unrecognized directive \"$directive\"";
  }
  $dow_in_range_p = !defined $target_dow || in_range($wday, parse_dow_range($target_dow)) if !defined $error;
  if (defined $error || !$dow_in_range_p || !defined $time_in_range_p || !$time_in_range_p) {
    ;
  } elsif ($target_volume >= 0 && $target_volume <= 1) {
    $result = $target_volume;
  } else {
    $error = "out of range volume $target_volume";
  }
  return wantarray? ($result, $error): [$result, $error];
}

sub set_sink_volumes ($$$$$) {
  my($hour, $min, $sec, $deciday, $wday) = @_;
  for my $sink (@sinks) {
    my $label = defined $config->{$sink} && defined $config->{$sink}->{'label'}? $config->{$sink}->{'label'}->[0]: "sink $sink";
    no integer;
    my $adj;
    my $reason;
    if (defined $config->{$sink} && defined $config->{$sink}->{'volume'}) {
      for my $directive (map { split /(?:^|(?<=\d))\s*,\s*/ } @{$config->{$sink}->{'volume'}}) {
	my($candidate_adj, $error) = determine_volume_from_directive_and_time($directive, $hour, $min, $sec, $deciday, $wday);
	($adj, $reason) = ($candidate_adj, "because of volume rule \"$directive\"") if defined $candidate_adj;
	log_error "CONFIG ERROR: $error in [$sink] volumes" if defined $error;
      last if defined $adj;
      }
      $adj = 1.0 unless defined $adj;
    } else {
      # Default adjustment for "night"
      $adj = 1.0;
      $adj *= 0.9 if $deciday < 1 || $deciday > 5;
      $adj *= 0.9 if $hour < 9 || $hour > 8;
    }
    $reason = 'by default' if defined $adj && !defined $reason;
    log_info "Volume adjusted to $adj for $label $reason" if $debug || $verbose_p;
    set_sink_volume $sink, 65535 * $adj;
  }
}

sub get_cache_pathname_for_event ($) {
  my($id) = @_;
  my $it = 'data/'; # FIXME
  if ($id ne 'test') {
    $it .= 'cache-';
    die "get_cache_pathname_for_event: Internal error: $mode: Illegal mode" unless $mode =~ /^[-\.\w]+$/s;
    die "get_cache_pathname_for_event: $id: Illegal event id" unless $id =~ /^[-\.\w]+$/s;
    $id =~ s/^(w\d)\.[1-4]$/\1/s unless defined $chime{$id}; # we don't really distinguish between most of the subwatches
    $id =~ s/^(h)\d+$/\1/sg if $mode eq MODE__SYSLINE; # we don't really distinguish between hours for sysline
    $it .= "$mode-" unless $id =~ /^w/;
    $it .= "\L$melody-" if $id =~ /^[qh]/ && $mode eq MODE__CARILLON;
  }
  $it .= "$id.oga";
  return $it;
}

sub send_midi_command ($) {
  my($cmd) = @_;
  log_output $cmd if $debug || $verbose_p;
  if (defined $synth) {
    $synth->send($cmd);
    $synth->{'.last-note'} = Time::HiRes::time if $cmd =~ /\bnoteon\b/; # XXX
  } else { # cached synth output disappeared
    log_error "trying to send midi command while synth is not connected";
  }
}

sub probe_synth_instruments () {
  send_midi_command('inst 1');
  my @instruments = $synth->before;
  my %instruments = map { /^(\d+)-(\d+)\s+(.*)$/s? ($3 => [$1 + 0, $2 + 0], "$1-$2" => $3): () } split(/\r?\n/, $synth->before);
  return wantarray? %instruments: \%instruments;
}

sub find_synth_instrument ($@) {
  my($instruments, @preferences) = @_;
  my $it;
  for my $candidate (@preferences) {
    $it = $instruments->{$candidate} if defined $instruments->{$candidate};
    $it = $instruments->{$it} if defined $it && !ref $it && defined $instruments->{$it};
  last if defined $it;
  }
  return $it;
}

sub synth_instrument_name ($$) {
  my($instruments, $instrument) = @_;
  my $id = sprintf('%03d-%03d', $instrument->[0], $instrument->[1]);
  return $instruments->{$id};
}

sub connect_synth ($) {
  my($id) = @_;
  my $output = get_cache_pathname_for_event($id);
  my($sf_path, $gain);
  if (!defined $synth) { # if we're connected don't try to create a second instance, we tried that before and it was disastrous
    my $immediate_p = $id eq 'test';

    # Figure out where our soundfont is
    for my $key ('Timbres Of Heaven', 'FluidR3') {
      if (defined $config->{'/'}->{$key}) {
	foreach my $candidate (@{$config->{'/'}->{$key}}) {
	  $sf_path = $candidate if -f $candidate;
	last if defined $sf_path;
	}
      }
      if (defined $sf_path && $key eq 'Timbres Of Heaven') {
	$gain = 0.2; # default gain
      }
    last if defined $sf_path;
    }
    $sf_path = $fluidR3 if !defined $sf_path; # hmm hope this works
    $gain = 1 if !defined $gain;

    log_comment sprintf('Connecting synth %s', $immediate_p? (@sinks? "to $sinks[0]": ''): "for write to $output") if $debug || $verbose_p;
    set_sink $sinks[0] if $immediate_p && @sinks;
    my @cmd = ('fluidsynth', '-g', $gain,
			     '--midi-channels', '5',
			     ($immediate_p?
				('-a', 'pulseaudio'):
				('-a', 'file',
				 '-o', "audio.file.name=$output")),
			     $sf_path);

    log_command @cmd if $debug;
    $synth = new Expect::Simple({
	'Cmd' => \@cmd,
	'Prompt' => "\n> ",
	'DisconnectCmd' => 'quit',
      });

    # Figure out what instruments to use
    my $instruments = probe_synth_instruments;
    my $gong = find_synth_instrument($instruments, 'Gong!!!', 'Tubular Bells');
    # XXX Chimes from Sonatina seems to sound nicer than Carillon, but Sonatina doesn't have standard percussion so we can't really use it
    my $bell = find_synth_instrument($instruments, 'Chimes', 'Carillon', 'Tubular Bells');
    my $wood = find_synth_instrument($instruments, 'Woodblock'); # 000-115
    my $perc = find_synth_instrument($instruments, 'Jazz Drum Kit', 'Jazz', 'Orchestra Kit');
    my $beep = find_synth_instrument($instruments, 'Sine Wave', '1 kHz Test', '000-008'); # fallback to any celesta
    ($gong_bank, $gong_inst) = @$gong;
    ($bell_bank, $bell_inst) = @$bell;
    ($wood_bank, $wood_inst) = @$wood;
    ($perc_bank, $perc_inst) = @$perc;
    ($beep_bank, $beep_inst) = @$beep;
    $wood_note = (synth_instrument_name($instruments, $wood) =~ / Kit\b/ || $wood_bank == 128)? 31: $note_to_midi_number{'d#5'};
    send_midi_command "select 0 1 $gong_bank $gong_inst";
    send_midi_command "select 1 1 $bell_bank $bell_inst";
    send_midi_command "select 2 1 $wood_bank $wood_inst";
    send_midi_command "select 3 1 $perc_bank $perc_inst";
    send_midi_command "select 4 1 $beep_bank $beep_inst";
    $instrument_name_to_channel_number{'Gong'} = 0;
    $instrument_name_to_channel_number{'Carillon'} = 1;
    $instrument_name_to_channel_number{'Woodblock'} = 2;
    $instrument_name_to_channel_number{'Terminal Bell'} = 4;

    # Set reverb, based on advice from
    # - mrbumpy409. (2012, December 19). The fluidsynth reverb, while not as good as the old Live!/Audigy hardware reverbs (which were 
    #   quite good), can still sound decent [Reply to forum post]. Retrieved from https://forums.scummvm.org/viewtopic.php?t=11632
    send_midi_command "rev_setroomsize 0.61";
    send_midi_command "rev_setdamp 0.23";
    send_midi_command "rev_setwidth 0.76";
    send_midi_command "rev_setlevel 0.57";
    send_midi_command "cho_set_nr 3";
    send_midi_command "cho_set_level 1.2";
    send_midi_command "cho_set_speed 0.3";
    send_midi_command "cho_set_depth 8";
    send_midi_command "reverb on";
    send_midi_command "chorus on";
  }
  return;
}

sub disconnect_synth () {
  sleep 6 if defined $synth && defined $synth->{'.last-note'};		# FIXME wait a bit for things to stabilize if we sent anything
  $synth = undef;
}

sub generate_sound_clip_for_event ($) {
  my($event_id) = @_;
  my $output = get_cache_pathname_for_event($event_id);
  if (!-f $output) {
    log_info "Generating audio for event $event_id";
    local @sinks;
    connect_synth $event_id;
    if ($event_id =~ /^h(\d+)$/) {
      announce_hour($1);
    } elsif ($event_id =~ /^q(\d+)$/) {
      announce_quarter_hour($1);
    } elsif ($event_id =~ /^w(\d+)\.(\d+)$/) {
      announce_night_watch($1, $2);
    } else {
      disconnect_synth;
      die "generate_sound_clips: $event_id: Unknown event id\n";
    }
    disconnect_synth;
  }
}

sub generate_sound_clips () {
  for my $event_id (
    (map { my $n = $_; map { "w$n.$_" } 1..5 } 1..5),		# night watches
    (map { "q$_" } 0..3),					# quarterly chimes
    (map { "h$_" } 1..12),					# hourly chimes
  ) {
    generate_sound_clip_for_event $event_id;
  }
}

sub play_sound_file_real ($;$$$) {
  my($input, $volume, $start, $end) = @_;
  my $sink = get_sink;
  my @exts = ('wav', 'mp3', 'ogg', 'oga', 'flac');
  my $ext_re = sprintf('(?:%s)', join('|', @exts));

  # Find a playable file
  for my $ext (@exts) {
  last if -f $input;
    $input = "$1.ext" if !-f $input && $input =~ /^(.*?)\.$ext_re$/ && -f "$1.ext";
  }

  # Fork and play it in the background
  my @cmd = ('mpv', '--audio-client-name', 'Chiming clock', '--no-video', '--really-quiet', '--input-terminal', 'no', '--volume', $volume);
  push @cmd, ('--start', $start) if defined $start;
  push @cmd, ('--end', $end) if defined $end;
  push @cmd, ("--ao=pulse::$sink") if $sink;
  push @cmd, $input;
  log_command @cmd;# if $debug;
  my $h = fork;
  die "$cmd[0]: fork: $!\n" unless defined $h;
  if ($h == 0) {
    no integer;
    my $sink = get_sink;
    my $dt = $config->{$sink}->{'delay'}->[0] + 0 if defined $config->{$sink} && defined $config->{$sink}->{'delay'};
    log_debug sprintf "delay %s (interpreted as %f) for %s", $config->{$sink}->{'delay'}->[0], $dt, $sink;#XXXZZ
    Time::HiRes::sleep $dt if defined $dt && $dt > 0;
    POSIX::close(0);
    exec { $cmd[0] } @cmd;
    die "$cmd[0]: exec: $!\n";
  }
  $children{$h} = 1;
}

sub play_sound_file ($;$$$) {
  my($input, $volume, $start, $end) = @_;
  $volume = 50 unless defined $volume;
  if (@sinks) {
    for my $sink (@sinks) {
      log_debug "set sink $sink" if $debug;
      set_sink $sink;
      play_sound_file_real($input, $volume, $start, $end);
    }
  } else {
    play_sound_file_real($input, $volume, $start, $end);
  }
}

sub strike_gong (;$) {
  my($note) = @_;
  if ($note ne 'r') {
    if ($method eq METHOD__SYNTH) {
      send_midi_command sprintf('noteon 0 %d %s', $note_to_midi_number{$note}, $expressive_mark_to_midi_velocity{'ffff'});
    } else {
      $note = 'a#5' if !defined $note || !defined $gong_scale{$note};
      play_sound_file sprintf('%s/%s', $datadir, $gong_scale{$note}), 50;
    }
  }
}

sub strike_bell ($) {
  my($note) = @_;
  if ($note ne 'r') {
    if ($method eq METHOD__SYNTH) {
      send_midi_command sprintf('noteon 1 %d %s', $note_to_midi_number{$note}, $expressive_mark_to_midi_velocity{'fff'});
    } else {
      $note = 'd#5' if !defined $note || !defined $chime_scale{$note};
      play_sound_file sprintf('%s/%s', $datadir, $chime_scale{$note}), 100;
    }
  }
}

sub strike_stick () {
  if ($method eq METHOD__SYNTH) {
    send_midi_command sprintf('noteon 2 %d %s', $wood_note, $expressive_mark_to_midi_velocity{'f'});
  } else {
    #play_sound_file sprintf('%s/269735__theriavirra__drumsticks-stagg-maple-sm5a-powerclick-no4a.wav', $datadir), 70;
    play_sound_file sprintf('%s/claves_ff.mp3', $datadir), 90;
  }
}

sub transpose_note ($;$) {
  my($note, $shift) = @_;
  my $it = $midi_number_to_note[$note_to_midi_number{$note} + $shift] if $note ne 'r';
  return defined $it? $it: $note;
}

sub strike_tune (@) {
  my @tune = @_;
  log_debug sprintf "Striking %s", join(' ', map { $_->[0] } @tune) if $debug || $verbose_p;
  no integer;
  my $semitones = 8;
  my $t0 = Time::HiRes::time;
  my $elapsed = 0;
  my @midi_commands;
  for my $spec (@tune) {
    my($note, $time, $velocity, $instrument) = @$spec;
    $velocity = 127 unless defined $velocity; # NOTE backward compatibility
    my $t_i = Time::HiRes::time;
    my $note_length = $time * $beat_length;
    if ($method eq METHOD__SYNTH) {
      if (defined $percussion_note_to_midi_number{$note}) {
	push @midi_commands, [$elapsed, sprintf 'noteon 3 %d %d', $percussion_note_to_midi_number{$note}, $velocity];
      } elsif (defined $note_to_midi_number{$note}) {
	my $channel = (defined $instrument_name_to_channel_number{$instrument}? $instrument_name_to_channel_number{$instrument}: 1);
	my $note_number = $note_to_midi_number{$note};
	my $laisser_vibrer_p = 1 unless $instrument eq 'Terminal Bell'; # FIXME
	push @midi_commands, [$elapsed, sprintf 'noteon %d %d %d', $channel, $note_number, $velocity];
	push @midi_commands, [$elapsed + $note_length, sprintf 'noteoff %d %d', $channel, $note_number] unless $laisser_vibrer_p;
      }
    } else {
      # The gongs have a range of [c4, g5], or [48, 67]; the Westminster chimes require a range of [b3, g#4] or [47, 56]
      # for just the melody, or [e3, g#4], or [40, 56], if we count also the strikes that count the hours
      # If we just deal with the melody, we therefore need to transpose everything up by 1 to 11 semitones
      # (and be content that the hourly strikes will sound a random note); otherwise we need to transpose it up by 8 to 11 semitones.
      # The VCSL chimes have a slightly narrower range of [c4, f5] or [48, 65] so we'll need to transpose it up by 8 to 9 semitones.
      #strike_gong transpose_note $note, $semitones;
      strike_bell transpose_note $note, $semitones;
    }
    # Instead of sleeping on the actual note length, we keep track of where we're supposed to be in relation to t0,
    # our initial time. Then calculate how much time we need to sleep to hit the next note at the expected time.
    my $dt = $t0 + $elapsed + $note_length - Time::HiRes::time;
    Time::HiRes::sleep $dt if $method ne METHOD__SYNTH && $dt > 0;
    $elapsed += $note_length;
  }
  if ($method eq METHOD__SYNTH) { # sort batched-up MIDI commands (to take care of noteoffs) and execute them in order
    @midi_commands = sort { $a->[0] <=> $b->[0] } @midi_commands;
    $t0 = Time::HiRes::time; # reset start time
    for (my $i = 0;; $i += 1) {
      my($t, $midi_command) = @{$midi_commands[$i]};
      send_midi_command $midi_command;
    last if $i == $#midi_commands;
      my $dt = $midi_commands[$i + 1]->[0] - $t;
      Time::HiRes::sleep $dt if $dt > 0;
    }
  }
}

sub announce_quarter_hour_by_carillon ($) {
  my($quarter) = @_;
  strike_tune @{$melody{$melody}->[$quarter%4]};
}

sub announce_quarter_hour_by_cuckoo ($) {
  my($quarter) = @_;
  if ($quarter == 2) {
    log_debug "Cuckoo announcing quarter $quarter" if $debug || $verbose_p;
    strike_gong 'c#4';
    play_sound_file "$datadir/121203__inchadney__cuckoo.wav", 100, 1.25, 3.05;
  } else {
    log_debug "Cuckoo does not announce quarter $quarter" if $debug || $verbose_p;
  }
}

sub announce_quarter_hour_by_sysline_beeps ($) {
  my($quarter) = @_;
  strike_tune @{$chime{'sysline'}} if ($quarter & 1) == 0;
}

sub announce_quarter_hour ($) {
  my($quarter) = @_;
  if ($mode eq MODE__CUCKOO) {
    announce_quarter_hour_by_cuckoo($quarter);
  } elsif ($mode eq MODE__SYSLINE) {
    announce_quarter_hour_by_sysline_beeps($quarter);
  } else {
    announce_quarter_hour_by_carillon($quarter);
  }
}

sub announce_hour_by_carillon ($) {
  my($hour) = @_;
  my $strike = $melody{$melody}->[4]; # FIXME
  my @tune = (@$strike) x $hour;
  strike_tune @tune;
}

sub announce_hour_by_cuckoo ($) {
  my($hour) = @_;
  my $f = sub { my($x) = @_; no integer; 1.5 + 1.55*$x };
  log_debug "Cuckoo announcing hour $hour\n" if $debug || $verbose_p;
  play_sound_file "$datadir/121203__inchadney__cuckoo.wav", 100, 1.25, &$f($hour);
  for (my $i = 0; $i < $hour; $i += 1) {
    #strike_gong 'c#4';
    Time::HiRes::sleep(1.5);
  }
}

sub announce_hour_by_sysline_beeps ($) {
  my($hour) = @_;
  strike_tune @{$chime{'sysline'}}; # it's always just one beep
}

sub announce_hour ($) {
  my($hour) = @_;
  if ($mode eq MODE__CUCKOO) {
    announce_hour_by_cuckoo($hour);
  } elsif ($mode eq MODE__SYSLINE) {
    announce_hour_by_sysline_beeps($hour);
  } else {
    announce_hour_by_carillon($hour);
  }
}

sub announce_night_watch_normal ($$) {
  my($watch, $subwatch) = @_;
  my($repeats, $pattern) = @{$watch_chime_pattern[$watch - 1]};
  no integer;
  for (my $i = 0, my $sleep = 0; $i < $repeats; $i += 1) {
    log_debug "Striking $pattern" if $debug || $verbose_p;
    for my $length (split(/\s+/, $pattern)) {
      Time::HiRes::sleep($sleep * $beat_length);
      if ($length eq '.') {
	strike_stick;
	$sleep = SHORT_STRIKE;
      } else {
	strike_gong;
	$sleep = LONG_STRIKE;
      }
    }
    $sleep += GAP;
  }
}

sub announce_night_watch ($$) {
  my($watch, $subwatch) = @_;
  if ($method eq METHOD__SYNTH) {
    strike_tune @{defined $chime{"w$watch.$subwatch"}? $chime{"w$watch.$subwatch"}: $chime{"w$watch"}};
  } else {
    announce_night_watch_normal $watch, $subwatch;
  }
}

sub do_event ($) {
  my($id) = @_;
  my $output = get_cache_pathname_for_event($id);
  log_debug sprintf "Cache file %s %s", $output, (-f $output? 'exists': 'does not exist') if $debug;
  if ($method eq METHOD__SYNTH && -f $output) {
    play_sound_file $output, 100;
  } elsif ($id =~ /^q(\d+)$/) {		# quarter hour chime
    announce_quarter_hour $1;
  } elsif ($id =~ /^h(\d+)$/) {		# hourly chime
    announce_hour $1;
  } elsif ($id =~ /^w(\d+)\.(\d+)$/) {	# night watch
    announce_night_watch $1, $2;
  } else {
    log_warning "Unknown event $id ignored";
  }
}

sub restart_script_real () {	# NOTE: this function exists only to silence the "Statement unlikely to be reached" warning
  for my $pid (keys %children) {
    log_comment "DEBUG: killing synth $pid" if $debug;
    kill 'TERM', $pid;
  }
  my @cmd = @restart_cmd;
  log_warning 'restarting: '. join(' ', @cmd) if $verbose_p || $debug;
  exec { $cmd[0] } @cmd;
}

sub restart_script () {
  restart_script_real;
  log_warning "restart failed: $!";
}

sub safe_to_restart_p () {
  my @cmd = ('perl', '-cw', $restart_cmd[0]);
  log_command @cmd if $debug;
  local $SIG{'CHLD'} = 'DEFAULT'; # need this to check exit status
  return 0 == system { $cmd[0] } @cmd;
}

sub usage (;$) {
  my($st) = @_;
  my $h = $st? *STDERR: *STDOUT;
  print $h <<EOF;
Usage: $0 [OPTION]...
Chime on the quarter hour and on the start of every fifth of a night watch.

  -d, --sink SINK             Use the specified SINK for audio
      --nonproportional-watches (NOT IMPLEMENTED)
                              Use watches that are aligned to duodecimal hours
  -Q, --qing                  Same as --nonproportional-watches --qing-quarters
      --qing-quarters         Use the Qing quarters system (identical to modern
                              quarters) instead of the ancient centiday system
  -v, --verbose               Explain what is being done
      --help                  Display this help and exit
EOF
  print $h <<EOF unless $debug;
                              (--debug --help to show debugging options)
EOF
  print $h <<EOF if $debug;

Options for debugging:

      --debug                 Produce debugging output
      --test                  Continue with test parameters
      --test-event ID[,ID...] Fire event identified by ID, then exit
      --test-scale            Play the major scale from c4 to c5, if possible
EOF
  print $h <<EOF;

Night watches are determined according to the proportional decimal time
system in use c. 7-2 century BC in ancient China. For details please see
https://github.com/acli/new_clock/blob/master/doc/Night_watches.md
EOF
  exit $st;
}

###############################################################################

sub parse_command_line_arguments () {
  select((select(STDERR), $| = 1)[0]); # I don't know why this is needed for STDERR

  # SIGCHLD handler must be IGNORE, otherwise Time::HiRes::sleep will fail randomly
  $SIG{CHLD} = 'IGNORE';

  # Handle config file
  $config = read_ini("$ENV{HOME}/.chimerrc");
  @sinks = @{$config->{'/'}->{'sink'}} if defined $config->{'/'}->{'sink'};
  $method = $config->{'/'}->{'method'}->[0] if defined $config->{'/'}->{'method'};
  $melody = lc $config->{'/'}->{'melody'}->[0] if defined $config->{'/'}->{'melody'};
  $coords = {'lon' => $config->{'/'}->{'longitude'}->[0], 'lat' => $config->{'/'}->{'latitude'}->[0]}
      if defined $config->{'/'}->{'longitude'} && defined $config->{'/'}->{'latitude'};
  die "Melody \"$melody\" is not known\n" unless defined $melody{$melody};

  # Guess location if not specified in config file
  $coords = guess_coordinates unless defined $coords;
  ($lat, $lon) = ($coords->{'lat'}, $coords->{'lon'}) unless defined $lat;
  die "$0: Can't determine coordinates\n" unless defined $coords;

  # Check command-line arguments
  Getopt::Long::config('bundling');
  GetOptions(
    'D|debug' => sub { $debug += 1; },
    'd|sink=s' => sub { @sinks = $_[1]; },
    'enable-nonproportional-watches|nonproportional-watches' => \$enable_nonproportional_watches,
    'enable-qing-quarters|qing-quarters' => \$enable_qing_quarters,
    'Q|qing' => sub { ($enable_nonproportional_watches, $enable_qing_quarters) = (1, 1); },
    'q|quit' => \$quit_p,
    'test' => sub { set_test_params },
    'test-event=s' => sub { set_test_params; connect_synth('test') if $method eq METHOD__SYNTH; for my $e (split(/,\s*/, $_[1])) { do_event $e };
	exit disconnect_synth },
    'test-scale' => sub { set_test_params; connect_synth('test') if $method eq METHOD__SYNTH;
	strike_tune(map {[$_, 1]} @midi_number_to_note[48, 50, 52, 53, 55, 57, 59, 60]);
	exit disconnect_synth },
    'test-tune=s' => sub { set_test_params; connect_synth('test') if $method eq METHOD__SYNTH; strike_tune @{interpret_melody($_[1], 1)};
	exit disconnect_synth },
    'v|verbose' => \$verbose_p,
    'help' => \&usage,
  ) || usage(1);
}

sub do_setup () {
  log_info sprintf "chimer booted at %.2f in %s mode%s using %s", $boottime, $mode, ($mode eq MODE__CARILLON? " (using $melody melody)": ''), $method if $verbose_p || $debug;
  generate_sound_clips if $method eq METHOD__SYNTH;
}

sub do_main_loop () {
  for (my $countdown = COUNTDOWN, my %pending_events, my %completed_events;;) {
    my $t0 = Time::HiRes::time;
    my $c = determine_chinese_time $t0;
    ($_, $_, $_, $_, my $chinese_hour, my $quarter, my $centiday, my $deciday, $_, $_, my $deciday_size) = @$c;
    (my $sec, my $min, my $hour, $_, $_, $_, my $wday) = localtime $t0;

    # Detect terminated child processes
    for my $pid (keys %children) {
      if (!kill 0, $pid || waitpid($pid, WNOHANG) == $pid) {
	log_debug "child process $pid has exited" if $debug;
	delete $children{$pid};
      }
    }

    # Determine what should happen next
    no integer;
    my @event = determine_events($t0, $hour, $min, $sec, $chinese_hour, $quarter, $centiday, $deciday, $deciday_size);
    my $next_event;
    for my $event (@event) {
      # Don't trust floating point calculations - don't use t as key, use id instead
      $pending_events{+$event->{'id'}} = $event;
    }
    for my $id (keys %pending_events) {
      my $e = $pending_events{$id};
      my $t = $e->{'t'};
      $t += $e->{'delay'} if defined $e->{'delay'};
      if ($t0 - $t > 60) { # just do it if we missed it by just a fraction of a second, actually it's fine even if it's a whole minute
	log_info sprintf "EVENT %s (%d) MISSED at %d (%.2f too late)", $id, $t, $t0, $t0 - $t;
	delete $pending_events{$id};
      }
    }
    # reconstitute the @event array
    @event = sort { $a->{'t'} + $a->{'delay'} <=> $b->{'t'} + $b->{'delay'} } map { $pending_events{$_} } keys %pending_events;

    # Determine when we should wake up; try to make some effort to align it to a second boundary
    my $t1 = Time::HiRes::time;
    my $dt0 = $event[0]->{'t'} - $t1;
    my $t_next = ($countdown && $dt0 > 1)? (int($t0) + 1): ($t1 + $dt0/2);
    my $dt = $t_next - $t1;
    $dt = 0 if $dt < 0;

    # Debug message
    log_comment sprintf "%10.2f=%02d+%2.2f=%2.2f=%2.2f (Δt=%2.2f) > %s",
	$t0, $chinese_hour, $quarter, $centiday, $deciday, $dt,
	join(', ', map { sprintf '%.2f (%+.1f) %s', $_->{'t'}, ($_->{'t'} - $t0), $_->{'id'} } @event) if $verbose_p;

    my $t2 = Time::HiRes::time;
    Time::HiRes::sleep $dt;

    # Check if any event should be fired
    my $now = Time::HiRes::time;
    my $dt_actual = $now - $t2;
    log_warning sprintf "tried to sleep for %.2f s but slept for %.2f s\n", $dt, $dt_actual if $dt_actual > $dt + 1;
    for my $id (keys %pending_events) {
      my $e = $pending_events{$id};
      my $t = $e->{'t'};
      $t += $e->{'delay'} if defined $e->{'delay'};
      if ($now < $t) {
	;
      } elsif (defined $completed_events{$id} && $now - $completed_events{$id} < 15) { # This should never happen (but it does)
	log_error sprintf "EVENT %s (%.2f) already fired at %.2f (%.2f s ago)\n", $id, $t, $completed_events{$id}, $now - $completed_events{$id} if $debug;
	delete $pending_events{$id};
      } else {
	my $dt = $now - $t;
	log_info sprintf "EVENT %s (%.2f) fired at %.2f (%s)\n", $id, $t, $now, ($dt < 0.01? 'on time': sprintf('%.2f s late', $dt));
	set_sink_volumes($hour, $min, $sec, $deciday, $wday);
	do_event $id;
	$countdown = 0; # force a re-countdown
	$completed_events{$id} = $now;
	delete $pending_events{$id};
      }
    }

    $countdown -= 1;
    $countdown = COUNTDOWN if $countdown < 0;
  }
}

if (!caller) {
  parse_command_line_arguments;
  do_setup;
  do_main_loop unless $quit_p;
  disconnect_synth;
}

=pod

=head1 HISTORY

Concept from the Javascript chiming clocks:
"Copyright © 2018 by Ambrose Li :-)"

Mostly based on the genmon script for Chinese/Hebrew dates:
"Copyright 2016-2018, 2021 by Ambrose Li <ambrose.li@gmail.com>
The primary purpose of this script is to figure out the year number in the Chinese system
so that I can name my CV's without having to look up two web pages.
Everything else is just for kicks =P"

=cut

1;
