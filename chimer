#!/usr/bin/perl
# vi:set sw=2 ai sm:
# Copyright © 2021–2022 by Ambrose Li

=pod

=encoding utf8

=head1 NAME

chimer – Re-implementation of the Javascript chiming clocks in Perl

=head1 DESCRIPTION

The primary purpose of this script is to avoid running the two chiming clock pages as Firefox tabs,
because Firefox (and Chromium-based browsers) are now unfriendly to pages that primarily use audio for UI.
Firefox also leaks memory really fast so it's best to not keep Firefox running for long periods of time.

Eventually this script might provide a way to make the genmon script less CPU intensive.

=head1 INTERNALS

=cut

# see https://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default for these crazy hacks
# THERE ARE MORE CRAZY HACKS THERE FOR MORE COMPLEX PROJECTS!!
use v5.12; # minimal for unicode string feature
use v5.14; # //u modifier
use utf8;
open qw( :encoding(UTF-8) :std );
use charnames qw( :full :short );
use feature "unicode_strings";

use warnings qw( FATAL utf8 );
use Encode qw( encode decode );
#@ARGV = map { decode("UTF-8", $_) } @ARGV if grep /\P{ASCII}/ => @ARGV;

binmode STDIN, ':utf8';
binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';



use strict;
use integer;


package Debug;
use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype tainted weaken isweak isvstring looks_like_number set_prototype);

sub lazy_sorter ($$) {
  my($a, $b) = @_;
  my $it;
  if ($a =~ /^(.*?)(\d+(?:\.\d+)?)$/s) {
    no integer;
    my($a1, $a2) = ($1, $2);
    if ($b =~ /^(.*?)(\d+(?:\.\d+)?)$/s) {
      my($b1, $b2) = ($1, $2);
      if ($a1 eq $b1 && $a1 =~ /q$/s) {		# q0 = q4 therefore > q3
	$it = ($a2 + 3)%4 <=> ($b2 + 3)%4;
      } else {
	$it = $a1 cmp $b1;
	$it = $a2 <=> $b2 unless $it;
      }
    }
  }
  $it = $a cmp $b unless defined $it && $it;
  return $it;
}

sub cvs ($) {
  my($s) = @_;
  my $it;
  sub compute_size ($) {
    my($s) = @_;
    my $it;
    if (!defined $s || !ref $s) {
      $it = 1;
    } elsif (ref $s eq 'ARRAY') {
      for my $val (@$s) {
	$it += compute_size($val);
      }
    } else { # hash or object
      $it += 2 unless ref $s eq 'HASH';
      for my $val (values %$s) {
	$it += 1 + compute_size($val);
      }
    }
    return $it;
  }
  sub format_scalar ($) {
    my($it) = @_;
    no integer;
    if (!looks_like_number($it)) {
      $it =~ s/([\\\(\)])/\\\1/sg;
      $it =~ s/(\n)/\\n/sg;
      $it = "($it)";
    }
    return $it;
  }
  sub format_as_name ($) {
    my($s) = @_;
    return $s =~ /^[-\.\w]+$/? "/$s": sprintf('%s cvn', cvs($s));
  }
  sub format_array_inner ($) {
    my($s) = @_;
    my $it;
    if (compute_size($s) <= 12) {	# cf. https://picolisp.com/wiki/?prettyPrint
      $it = join(' ', map { cvs($_) } @$s);
    } else {
      my @s = @$s;
      $it = cvs($s[0]) . "\n   " . format_array_inner([@s[1..$#s]]);
    }
    return $it;
  }
  sub format_hash ($) {
    my($s) = @_;
    my @keys = sort { lazy_sorter($a, $b) } keys %$s;
    my @size;
    my $it;
    for (my $i = $#keys; $i >= 0; $i -= 1) {
      my $key = $keys[$i];
      $size[$i] = compute_size($key) + compute_size($s->{$key});
      $size[$i] += $size[$i + 1] if $i < $#keys;
    }
    for (my $i = 0; $i < @keys; $i += 1) {
      my $key = $keys[$i];
      $it .= ($size[$i] <= 12? ' ': "\n") if defined $it;
      $it .= sprintf('%s %s', format_as_name $key, cvs($s->{$key}));
    }
    return "<<$it>>";
  }
  if (!defined $s) {
    $it = 'null';
  } elsif (ref $s eq 'ARRAY') {
    $it = sprintf('[%s]', format_array_inner($s));
  } elsif (ref $s eq 'HASH') {
    $it = format_hash $s;
  } elsif (!ref $s) {
    $it = format_scalar $s;
  } else { # object :-/
    $it = sprintf '%s %s bless', format_hash $s, format_as_name ref $s;
  }
  return $it;
}


package Interpret_Melody_State;
no integer;

sub unit_beat {
  my $self = shift;
  $self->{'unit-beat'} = shift if @_;
  return $self->{'unit-beat'};
}

sub tempo {
  my $self = shift;
  if (@_ && defined $_[0]) {
    my($divisor, $beats_per_minute) = ref $_[0]? @{$_[0]}: @_;
    $self->{'tempo'} = [$divisor, $beats_per_minute];
    $self->unit_beat(($divisor*60)/(4*$beats_per_minute));
  }
  return wantarray? @{$self->{'tempo'}}: $self->{'tempo'};
}

sub relative_p {
  my $self = shift;
  $self->{'relative-p'} = shift if @_;
  return $self->{'relative-p'};
}

sub drummode_p {
  my $self = shift;
  $self->{'drummode-p'} = shift if @_;
  return $self->{'drummode-p'};
}

sub home_position {
  my $self = shift;
  $self->{'home-position'} = shift if @_;
  return $self->{'home-position'};
}

sub repeat_start {
  my $self = shift;
  $self->{'repeat-start'} = shift if @_;
  return $self->{'repeat-start'};
}

sub repeat_count {
  my $self = shift;
  $self->{'repeat-count'} = shift if @_;
  return $self->{'repeat-count'};
}

sub repeat_stacklevel {
  my $self = shift;
  $self->{'repeat-stacklevel'} = shift if @_;
  return $self->{'repeat-stacklevel'};
}

sub stacklevel {
  my $self = shift;
  return scalar @{$self->{'stack'}};
}

sub transpose {
  my $self = shift;
  $self->{'transpose'} = shift if @_; # FIXME?
  return $self->{'transpose'};
}

sub new {
  my $class = shift;
  my $self = {};
  bless $self, $class;
  $self->unit_beat(1);
  $self->relative_p(0);
  $self->drummode_p(0);
  $self->transpose(0);
  $self->{'stack'} = [];
  return $self;
}

sub gsave {
  my $self = shift;
  my $tempo = $self->tempo();
  my $unit_beat = $self->unit_beat();
  my $relative_p = $self->relative_p();
  my $drummode_p = $self->drummode_p();
  my $home_position = $self->home_position();
  my $transpose = $self->transpose();
  my $repeat_stacklevel = $self->repeat_stacklevel();
  my $repeat_start = $self->repeat_start();
  my $repeat_count = $self->repeat_count();
  push @{$self->{'stack'}}, [$tempo, $unit_beat, $relative_p, $drummode_p, $home_position, $transpose,
			    $repeat_stacklevel, $repeat_start, $repeat_count];
}

sub grestore {
  my $self = shift;
  if (@{$self->{'stack'}}) {
    my                      ($tempo, $unit_beat, $relative_p, $drummode_p, $home_position, $transpose,
			      $repeat_stacklevel, $repeat_start, $repeat_count)
	= @{ pop @{$self->{'stack'}} };

    $self->tempo		($tempo);		# tempo must be restored first because setting it changes unit_beat
    $self->unit_beat		($unit_beat);
    $self->relative_p		($relative_p);
    $self->drummode_p		($drummode_p);
    $self->home_position	($home_position);
    $self->transpose		($transpose);
    $self->repeat_stacklevel	($repeat_stacklevel);
    $self->repeat_start		($repeat_start);
    $self->repeat_count		($repeat_count);
  } else {
    my $comment = sprintf(' (context: %s)', Debug::cvs($1)) if @_ && $_[0] =~ /^(.[^\n]*)/s;
    die "grestore called but stack is empty$comment";
  }
}


package Latency;
no integer;
use Time::HiRes;

sub MAX_LATENCIES_REMEMBERED () { 32 }
sub MAX_ERRORS_REMEMBERED    () { 64 }

sub get_cpu_count () {
  state $it;
  my $input = '/proc/cpuinfo';
  if (!defined $it && open(INPUT, '<', $input)) {	# probably not Linux if we can't open it
    for (;;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      $it += 1 if $s =~ /^processor\s*:/s;		# don't grep for "cpu cores" because some archs don't do that
    }
    close INPUT;
  }
  return $it;
}

sub get_loadavg () {
  my $it;
  my $input = '/proc/loadavg';
  if (open(INPUT, '<', $input)) {			# probably not Linux if we can't open it
    my $s = scalar <INPUT>;
    no integer;
    $it = $1 + 0 if $s =~ /^(\d+\.\d+)\s/s;
    close INPUT;
  }
  return $it;
}

sub register_error {
  my $self = shift;
  my($method, $delta) = @_;
  $self->{'errors'}->{$method} = [] unless defined $self->{'errors'}->{$method};
  push @{$self->{'errors'}->{$method}}, $delta;
  shift @{$self->{'errors'}->{$method}} while scalar @{$self->{'errors'}->{$method}} > MAX_ERRORS_REMEMBERED;
}

sub remember {
  my $self = shift;
  my($latency, $tag) = @_;
  my $node = {
      'latency' => $latency,
      't' => Time::HiRes::time,
    };
  $node->{'tag'} = $tag if defined $tag;
  my $loadavg = get_loadavg;
  if (defined $loadavg) {
    $node->{'loadavg'} = $loadavg;
  }
  if (defined $self->{'predictions'}) {
    foreach my $method (keys %{$self->{'predictions'}}) {
      $self->register_error($method, $latency - $self->{'predictions'}->{$method});
    }
    $self->{'predictions'} = undef;
  }
  push @{$self->{'latencies'}}, $node;
  shift @{$self->{'latencies'}} while scalar @{$self->{'latencies'}} > MAX_LATENCIES_REMEMBERED;
}

sub has_usable_measurements_p {
  my $self = shift;
  my $loadavg = get_loadavg;
  my $it;
  if (defined $loadavg) {
    for my $latency (@{$self->{'latencies'}}) {
      $it = 1 if abs($loadavg - $latency->{'loadavg'}) < 5;	# XXX
    last if defined $it;
    }
    $it = 0 unless defined $it;
  } else {
    # We have no way to tell. Just say yes.
    $it = '0 but true';
  }
  return $it;
}

sub summation (@) {
   my(@x) = @_;
   my $it = 0;
   foreach my $x_i (@x) {
      $it += $x_i;
   }
   return $it;
}

sub error_estimate {
  my $self = shift;
  my($method) = @_;
  my $deltas =  $self->{'errors'}->{$method} if defined $self->{'errors'}->{$method};
  return defined $deltas && @$deltas? summation(map { abs $_ } @$deltas)/scalar(@$deltas): undef;
}

sub predict_via_exponential_curve_fitting (\@$$) {
  my($latencies, $loadavg, $t) = @_;
  my $it;
  if (@$latencies > 2 && defined $loadavg) {
    no integer;
    # Assume latency is exponentially related to loadavg
    my($a, $b);
    my $f = sub { my($x) = @_; $a * exp($b * $x) }; # log f = $b * $x + log($a)
    # But simplify the approximation using log f (cf. p. 429 in my numerical methods textbook)
    # not because the simplication is sound but because my numerical skills are not up to par
    my $m = @$latencies;
    my @x = map { $_->{'loadavg'} } @$latencies;
    my @y = map { $_->{'latency'} } @$latencies;
    my @i = 0..($m - 1);
    my $denominator = ($m * summation(map { $x[$_]**2 } @i) - summation(@x)**2);
    if ($denominator) {
      $b = ($m * summation(map { $x[$_]*$y[$_] } @i) - summation(@x) * summation(@y)) / $denominator;
      $a = (summation(@x) * summation(@y) - summation(map { $x[$_] * $y[$_] } @i) * summation(@x)) / $denominator;
      $a = exp($a);
      $it = &$f($loadavg);
    }
  }
  return $it;
}

sub predict_via_polynomial_curve_fitting (\@$$) {
  my($latencies, $loadavg, $t) = @_;
  my $it;
  if (@$latencies > 2 && defined $loadavg) {
    no integer;
    # Assume latency is quadratically related to loadavg
    my($a, $b);
    my $f = sub { my($x) = @_; $a * $x + $b };
    my $m = @$latencies;
    my @x = map { $_->{'loadavg'} } @$latencies;
    my @y = map { $_->{'latency'} } @$latencies;
    my @i = 0..($m - 1);
    my $denominator = ($m * summation(map { $x[$_]**2 } @i) - summation(@x)**2);
    if ($denominator) {
      $a = ($m * summation(map { $x[$_]*$y[$_] } @i) - summation(@x) * summation(@y)) / $denominator;
      $b = (summation(@x) * summation(@y) - summation(map { $x[$_] * $y[$_] } @i) * summation(@x)) / $denominator;
      $it = &$f($loadavg);
    }
  }
  return $it;
}

sub predict_via_averaging (\@$$) {
  my($latencies, $loadavg, $t) = @_;
  my $it;
  if (@$latencies) {
    no integer;
    my $m = @$latencies;
    my @y = map { $_->{'latency'} } @$latencies;
    $it = summation(@y)/$m;
  }
  return $it;
}

sub predict_via_weighted_averaging (\@$$) {
  my($latencies, $loadavg, $t) = @_;
  my $it;
  if (@$latencies && defined $loadavg) {
    no integer;
    state $k = 2**0.125;
    my $m = @$latencies;
    my @y = map { $_->{'latency'} * 2**($loadavg - $_->{'loadavg'}) } @$latencies;
    $it = summation(@y)/$m;
  }
  return $it;
}

sub predict_from_loadavg {
  my $self = shift;
  my($loadavg) = @_;
  my $prediction_method;
  my $it;
  my $t = Time::HiRes::time;
  my @latencies = @{$self->{'latencies'}};
  my %candidates;

  # Calculate candidates predictions
  $candidates{'exponential curve fitting'} = predict_via_exponential_curve_fitting(@latencies, $loadavg, $t);
  $candidates{'polynomial curve fitting'} = predict_via_polynomial_curve_fitting(@latencies, $loadavg, $t);
  $candidates{'weighted-averaging'} = predict_via_weighted_averaging(@latencies, $loadavg, $t);
  $candidates{'averaging'} = predict_via_averaging(@latencies, $loadavg, $t);

  # Remove candidates that returned no results
  for my $method (keys %candidates) {
    delete $candidates{$method} unless defined $candidates{$method};
  }

  # Remove candidates that look implausible
  for my $method (keys %candidates) {
    if ($method ne 'averaging' && $candidates{$method} > 15) {
      Chimer::log_debug(sprintf 'implausible candidate %s from %s removed from consideration', Debug::cvs($candidates{$method}), $method)
	  if (defined $Chimer::verbose_p && $Chimer::verbose_p > 1) || (defined $Chimer::debug && $Chimer::debug > 1);
      delete $candidates{$method};
    }
  }
  Chimer::log_debug(sprintf 'remaining candidates: %s', Debug::cvs(\%candidates))
      if (defined $Chimer::verbose_p && $Chimer::verbose_p > 1) || (defined $Chimer::debug && $Chimer::debug > 1);

  # Choose "best" prediction from candidates
  if (keys %candidates == 1) {
    ($prediction_method, $it) = %candidates;
    Chimer::log_debug(sprintf 'prediction %s from %s used because it was the only candidate', Debug::cvs(\@latencies), $prediction_method)
	  if (defined $Chimer::verbose_p && $Chimer::verbose_p > 1) || (defined $Chimer::debug && $Chimer::debug > 1);
  } elsif (%candidates) {
    my @scores = sort { $a->{'error'} <=> $b->{'error'} } map { { 'method' => $_, 'error' => $self->error_estimate($_) } } keys %candidates;
    $prediction_method = $scores[0]->{'method'};
    $it = $candidates{$prediction_method};
    Chimer::log_debug(sprintf 'prediction %s from %s used because it looks historically accurate', Debug::cvs(\@latencies), $prediction_method)
	  if (defined $Chimer::verbose_p && $Chimer::verbose_p > 1) || (defined $Chimer::debug && $Chimer::debug > 1);
  } else {
    Chimer::log_debug(sprintf 'insufficient data to predict latency from %s', Debug::cvs(\@latencies))
	  if (defined $Chimer::verbose_p && $Chimer::verbose_p > 1) || (defined $Chimer::debug && $Chimer::debug > 1);
  }
  $self->{'predictions'} = \%candidates;
  return wantarray? ($it, $prediction_method): $it;
}

sub predict {
  my $self = shift;
  return $self->predict_from_loadavg(get_loadavg);
}

sub tag {
  my $self = shift;
  $self->{'tag'} = shift if @_;
  return $self->{'tag'};
}                                                                                                                                                    

sub new {
  my $class = shift;
  my($latency, $tag) = @_;
  my $self = {};
  bless $self, $class;
  $self->remember($latency, $tag) if defined $latency;
  return $self;
}


package Chimer;

use POSIX;
use POSIX ":sys_wait_h"; # for nonblocking read
use DateTime;
use Time::HiRes; # overrides (qw) do not seem to work
use Expect::Simple;

use Exporter;
require Exporter;
use vars qw( @ISA @EXPORT @EXPORT_OK );
@ISA = qw(Exporter);
@EXPORT_OK = qw( $dow_re $dow_range_re %expressive_mark_to_midi_velocity );

use vars qw( @restart_cmd );
@restart_cmd = ($0, @ARGV); # save this because GetOpt will clear @ARGV

use vars qw( $use_datetime_event_sunrise );
use vars qw( $use_datetime_astro_sunrise );
use vars qw( $use_astro_sunrise );
BEGIN {
  if (eval { require DateTime::Event::Sunrise; }) {
    $use_datetime_event_sunrise = 1;
  } elsif (eval { require DateTime::Astro::Sunrise; }) {
    $use_datetime_astro_sunrise = 1;
  } elsif (eval { require Astro::Sunrise; }) {
    $use_astro_sunrise = 1;
  } else {
    die "Cannot find a usable Sunrise package";
  }
}

use Getopt::Long;
use Data::Dumper;

use vars qw( $config );
use vars qw( $overrides );
use vars qw( $debug );
use vars qw( $no_cache_p $create_cache_p $test_p );
use vars qw( $verbose_p );
use vars qw( $quit_p );
use vars qw( $enable_nonproportional_watches );
use vars qw( $enable_qing_quarters );

use vars qw( $coords );
use vars qw( $lat $lon );
use vars qw( @sinks );
use vars qw( $synth );
use vars qw( %children );
use vars qw( %expected_latency );

use vars qw( $gong_bank $gong_inst $bell_bank $bell_inst $wood_bank $wood_inst $wood_note $perc_bank $perc_inst $beep_bank $beep_inst );
use vars qw( %instrument_name_to_channel_number );
use vars qw( $fluidR3 );
$fluidR3 = '/usr/share/sounds/sf2/FluidR3_GM.sf2';

use vars qw( $beat_length );
$beat_length = 1;

use vars qw( $boottime );
$boottime = Time::HiRes::time;

use vars qw( $time_displacement );
sub current_time () { no integer; Time::HiRes::time + $time_displacement }

use vars qw( $basedir $datadir );
$basedir = $1 if $0 =~ /^(.*?)\/+[^\/]+$/;
$basedir =~ s/(?:^|\/+)bin$//;
$basedir = '.' if $basedir eq '';
$datadir = "$basedir/data";

# number of times we try sleeping for 1 second until we sleep until the target event
sub COUNTDOWN () { 5 } # things stablize after 2-3 times, we do 5 just in case (10 is overkill)

# number of seconds to sleep before we disconnect the synth - from observation this must be at least 6
sub SECONDS_BEFORE_DISCONNECT () { 7 }

sub MODE__SYSLINE   () { 'sysline' }
sub MODE__CUCKOO    () { 'cuckoo' }
sub MODE__CARILLON  () { 'carillon' }
sub METHOD__SAMPLES () { 'samples' }
sub METHOD__SYNTH   () { 'synth' }

sub MELODY__ABBEY         () { 'abbey' }
sub MELODY__CAMBRIDGE     () { 'cambridge' }
sub MELODY__CAMBRIDGE_RCC () { 'cambridge_rcc' }
sub MELODY__CANTERBURY    () { 'canterbury' }
sub MELODY__GUILDFORD     () { 'guildford' }
sub MELODY__MAGDALEN      () { 'magdalen' }
sub MELODY__NEWCOLLEGE    () { 'newcollege' }
sub MELODY__NORWICH       () { 'norwich' }
sub MELODY__TINGTANG2A    () { 'tingtang2a' }
sub MELODY__TINGTANG2B    () { 'tingtang2b' }
sub MELODY__TINGTANG3A    () { 'tingtang3a' }
sub MELODY__TINGTANG3B    () { 'tingtang3b' }
sub MELODY__TINGTANG4     () { 'tingtang4' }
sub MELODY__TINGTANG5     () { 'tingtang5' }
sub MELODY__WESTMINSTER   () { 'westminster' }
sub MELODY__WHITTINGTON   () { 'whittington' }
sub MELODY__WHITTINGTON11 () { 'whittington11' }

use vars qw( $mode $method $melody );
$mode   = MODE__CARILLON;
$method = METHOD__SAMPLES;
$melody = MELODY__WESTMINSTER;

# night watch chime patterns
sub LONG_STRIKE  () { 1.5 }
sub SHORT_STRIKE () { 0.5 }
sub GAP          () { 2.5 }
# watch chime patterns: repetitions, pattern
# gap needs to be long enough to hear it, but short enough to not mistake it for a long strike. This is HARD
use vars qw( @watch_chime_pattern );
@watch_chime_pattern = ( # v. https://zh.wikipedia.org/wiki/打更 (q.v.)
   [3, '— .'		],
   [2, '. .'		],
   [3, '— . .'		],
   [4, '— . . .'	],
   [5, '— . . . .'	],
);

use vars qw( @midi_number_to_note %note_to_midi_number );
@midi_number_to_note = (
  'c0', 'c#0', 'd0', 'd#0', 'e0', 'f0', 'f#0', 'g0', 'g#0', 'a0', 'a#0', 'b0',
  'c1', 'c#1', 'd1', 'd#1', 'e1', 'f1', 'f#1', 'g1', 'g#1', 'a1', 'a#1', 'b1',
  'c2', 'c#2', 'd2', 'd#2', 'e2', 'f2', 'f#2', 'g2', 'g#2', 'a2', 'a#2', 'b2',
  'c3', 'c#3', 'd3', 'd#3', 'e3', 'f3', 'f#3', 'g3', 'g#3', 'a3', 'a#3', 'b3',
  'c4', 'c#4', 'd4', 'd#4', 'e4', 'f4', 'f#4', 'g4', 'g#4', 'a4', 'a#4', 'b4',
  'c5', 'c#5', 'd5', 'd#5', 'e5', 'f5', 'f#5', 'g5', 'g#5', 'a5', 'a#5', 'b5',
  'c6', 'c#6', 'd6', 'd#6', 'e6', 'f6', 'f#6', 'g6', 'g#6', 'a6', 'a#6', 'b6',
  'c7', 'c#7', 'd7', 'd#7', 'e7', 'f7', 'f#7', 'g7', 'g#7', 'a7', 'a#7', 'b7',
  'c8', 'c#8', 'd8', 'd#8', 'e8', 'f8', 'f#8', 'g8', 'g#8', 'a8', 'a#8', 'b8',
  'c9', 'c#9', 'd9', 'd#9', 'e9', 'f9', 'f#9', 'g9', 'g#9', 'a9', 'a#9', 'b9',
);
%note_to_midi_number = map { $midi_number_to_note[$_] => $_ } 0..$#midi_number_to_note;

use vars qw( %gong_scale %chime_scale );
%gong_scale = (
  'c4'	=> '582141__strangehorizon__g01-c-4-gong.wav',
  'c#4'	=> '582140__strangehorizon__g02-c-4-gong.wav',
  'd4'	=> '582139__strangehorizon__g03-d-4-gong.wav',
  'd#4'	=> '582138__strangehorizon__g04-d-4-gong.wav',
  'e4'	=> '582145__strangehorizon__g05-e-4-gong.wav',
  'f4'	=> '582144__strangehorizon__g06-f-4-gong.wav',
  'f#4'	=> '582143__strangehorizon__g07-f-4-gong.wav',
  'g4'	=> '582142__strangehorizon__g08-g-4-gong.wav',
  'g#4'	=> '582147__strangehorizon__g09-g-4-gong.wav',
  'a4'	=> '582146__strangehorizon__g10-a-4-gong.wav',
  'a#4'	=> '582156__strangehorizon__g11-a-4-gong.wav',
  'b4'	=> '582155__strangehorizon__g12-b-4-gong.wav',
  'c5'	=> '582154__strangehorizon__g13-c-5-gong.wav',
  'c#5'	=> '582153__strangehorizon__g14-c-5-gong.wav',
  'd5'	=> '582160__strangehorizon__g15-d-5-gong.wav',
  'd#5'	=> '582159__strangehorizon__g16-d-5-gong.wav',
  'e5'	=> '582158__strangehorizon__g17-e-5-gong.wav',
  'f5'	=> '582157__strangehorizon__g18-f-5-gong.wav',
  'f#5'	=> '582162__strangehorizon__g19-f-5-gong.wav',
  'g5'	=> '582161__strangehorizon__g20-g-5-gong.wav',
);
%chime_scale = (
  'c4'	=> 'chimes_C1.ogg',
  'c#4'	=> 'chimes_C#1.ogg',
  'd4'	=> 'chimes_D1.ogg',
  'd#4'	=> 'chimes_D#1.ogg',
  'e4'	=> 'chimes_E1.ogg',
  'f4'	=> 'chimes_F1.ogg',
  'f#4'	=> 'chimes_F#1.ogg',
  'g4'	=> 'chimes_G1.ogg',
  'g#4'	=> 'chimes_G#1.ogg',
  'a4'	=> 'chimes_A1.ogg',
  'a#4'	=> 'chimes_A#1.ogg',
  'b4'	=> 'chimes_B1.ogg',
  'c5'	=> 'chimes_C2.ogg',
  'c#5'	=> 'chimes_C#2.ogg',
  'd5'	=> 'chimes_D2.ogg',
  'd#5'	=> 'chimes_D#2.ogg',
  'e5'	=> 'chimes_E2.ogg',
  'f5'	=> 'chimes_F2.ogg',
);

sub gensym () {
  state $n;
  return sprintf('g%d', $n++);
}

sub log_internal ($$;$$$) {
  my($flag, $s, $prefix, $newline_p, $keep_p) = @_;
  state $last_logged;
  my $daemon_p = !-t STDERR;
  $newline_p = 1 if $s =~ s/^\n+//s;
  $newline_p = 0 unless defined $last_logged;
  $newline_p = 1 if defined $last_logged && $last_logged->{'keep'};
  $newline_p = 0 if $daemon_p;
  my $cleol_p = !$daemon_p && !$newline_p;
  $keep_p = 1 if $debug;
  $prefix .= ': ' if defined $prefix && $prefix =~ /\S/s && $prefix !~ /: $/s;
  chomp $s;
  printf STDERR "%s%10.2f%s\t%s%s%s%s", ($newline_p? "\n": ''),
      current_time, $flag, $prefix, $s, ($cleol_p? "\033[K": ''), ($daemon_p? "\n": "\r");

  $last_logged->{'keep'} = $keep_p + 0;
}

sub log_output  ($) { log_internal '>', $_[0] }
sub log_comment ($) { log_internal '#', $_[0] }
sub log_debug   ($) { log_internal '#', $_[0], 'DEBUG', 1, 1 }
sub log_info    ($) { log_internal '#', $_[0], undef,   0, 1 }
sub log_error   ($) { log_internal '#', $_[0], 'ERROR', 1, 1 }
sub log_warning ($) { log_internal '#', $_[0], 'WARNING', 1, 1 }
sub log_command (@) { log_debug 'running: '. join(' ', map { s/([\\"])/\\\1/sg if /\s/; /\s|^$/? "\"$_\"": $_ } @_) }


=pod

=head2 Chime melodies

Each chime melody is internally represented as an array of
B<[>I<midi note name>, I<time in seconds>, I<percentage volume>, I<instrument>B<]> entries
(I<instrument> can be undef),
but written as calls to I<define_event> which takes 3 parameters –
the identifier for the mode,
the identifier for the melody,
a string containing any definitions (in the form S<I<var> = I<some definition>>) –
plus a list of key-value pairs.
Valid keys are B<q1> for first-quarter chimes,
B<q2> for second-quarter chimes,
B<q3> for third-quarter chimes,
B<q0> for fourth-quarter chimes,
and B<h> for the hour strike.

As many definitions as needed can be included, but each definition I<must> be of the form of either of

=over

I<var> = B<\relative> I<pitch> B<{> I<melody> B<}>

I<var> = B<\drums> B<{> I<melody> B<}>

I<var> B<{> I<tempo or some other initialization> B<}>

=back

The values are written in LilyPond notation
(in either relative pitch or drum mode, optionally including note lengths and basic expressive marks),
described in

=over

Relative Octave Entry. (n.d.). In I<LilyPond — Notation Reference v2.22.1 (stable-branch)>.
Retrieved August 18, 2021, from http://lilypond.org/doc/v2.22/Documentation/notation/writing-pitches#relative-octave-entry

Percussion notes. (n.d.). In I<LilyPond — Notation Reference v2.22.1 (stable-branch)>.
Retrieved August 20, 2021, from http://lilypond.org/doc/v2.22/Documentation/notation/percussion-notes

=back

For the hour strike, you should normally use B<%I> for represent the hour
so that you can strike the bell the correct number of times
(you should of course omit B<%I> for I<sysline> mode
or for ancient ting-tang quarters that always strike the hour strike once).

I<event_def> calls I<interpret_melody> to convert this notation into the internal representation described above,
but this conversion is just a simple pattern match and therefore can produce incorrect results.
If results are incorrect but the notation typesets correctly in LilyPond, the bug is in I<interpret_melody>.

The mapping between Lilypond expressive marks and MIDI velocities is based on

=over

Yamaha. (n.d.). I<Everything You've Ever Wanted to Know About Using MIDI with a Disklavier>.
Yamaha Disklavier Education Network.
Retrieved August 19, 2021, from https://www.yamahaden.com/easyblog/entry/everything-you-ve-ever-wanted-to-know-about-using-midi-with-a-disklavier

Vandenneucker, D.Z<Dominique> (2012). MIDI tutorial.
Retrieved September 5, 2021, from http://www.music-software-development.com/midi-tutorial.html

=back

The mapping between Lilypond percussion notes and MIDI percussion notes is based on

=over

General MIDI instrument codes. (n.d.).
Retrieved August 20, 2021, from http://www.ccarh.org/courses/253/handout/gminstruments/

=back

=cut

use vars qw( %ly_notes );
%ly_notes = (
  'ces' => -1, 'c' => 0, 'cis' => 1,
  'des' => 1, 'd' => 2, 'dis' => 3,
  'ees' => 3, 'e' => 4, 'eis' => 5,
  'fes' => 4, 'f' => 5, 'fis' => 6,
  'ges' => 6, 'g' => 7, 'gis' => 8,
  'aes' => 8, 'a' => 9, 'ais' => 10,
  'bes' => 10, 'b' => 11, 'bis' => 12,
);
use vars qw( %percussion_note_to_midi_number );
%percussion_note_to_midi_number = (
  'bassdrum'		=> 36,		'bd'	=> 36,
  'acousticbassdrum'	=> 35,		'bda'	=> 35,
  'snare'		=> 38,		'sn'	=> 38,		# arbitrarily map to sna
  'acousticsnare'	=> 38,		'sna'	=> 38,
  'electricsnare'	=> 40,		'sne'	=> 40,
  'lowfloortom'		=> 41,		'tomfl'	=> 41,
  'highfloortom'	=> 43,		'tomfh'	=> 43,
  'lowtom'		=> 45,		'toml'	=> 45,
  'hightom'		=> 50,		'tomh'	=> 50,
  'lowmidtom'		=> 47,		'tomml'	=> 47,
  'himidtom'		=> 48,		'tommh'	=> 48,
  'highhat'		=> 44,		'hh'	=> 44,		# arbitrarily map to hhp
  'closedhighhat'	=> 42,		'hhc'	=> 42,
  'openhighhat'		=> 46,		'hho'	=> 46,
  'halfopenhighhat'	=> undef,	'hhho'	=> undef,	# don't know how to map
  'pedalhighhat'	=> 44,		'hhp'	=> 44,
  'crashcymbal'		=> 49,		'cymc'	=> 49,		# arbitrarily map to cymca
  'crashcymbala'	=> 49,		'cymca'	=> 49,
  'crashcymbalb'	=> 57,		'cymcb'	=> 57,
  'ridecymbal'		=> 51,		'cymr'	=> 51,		# arbitrarily map to cymra
  'ridecymbala'		=> 51,		'cymra'	=> 51,
  'ridecymbalb'		=> 59,		'cymrb'	=> 59,
  'chinesecymbal'	=> 52,		'cymch'	=> 52,
  'splashcymbal'	=> 55,		'cyms'	=> 55,
  'ridebell'		=> 53,		'rb'	=> 53,
  'cowbell'		=> 56,		'cb'	=> 56,
  'hibongo'		=> 60,		'boh'	=> 60,
  'openhibongo'		=> undef,	'boho'	=> undef,	# don't know how to map
  'muteopenhibongo'	=> undef,	'bohm'	=> undef,	# don't know how to map
  'lobongo'		=> 61,		'bol'	=> 61,
  'openlobongo'		=> undef,	'bolo'	=> undef,	# don't know how to map
  'muteopenlobongo'	=> undef,	'bolm'	=> undef,	# don't know how to map
  'hiconga'		=> 63,		'cgh'	=> 63,		# arbitrarily map to cgho
  'openhiconga'		=> 63,		'cgho'	=> 63,
  'mutehiconga'		=> 62,		'cghm'	=> 62,
  'loconga'		=> 64,		'cgl'	=> 64,
  'openloconga'		=> undef,	'cglo'	=> undef,	# don't know how to map
  'muteloconga'		=> undef,	'cglm'	=> undef,	# don't know how to map
  'hitimbale'		=> 65,		'timh'	=> 65,
  'lotimbale'		=> 66,		'timl'	=> 66,
  'hiagogo'		=> 67,		'agh'	=> 67,
  'loagogo'		=> 68,		'agl'	=> 68,
  'sidestick'		=> 37,		'ss'	=> 37,
  'hisidestick'		=> undef,	'ssh'	=> undef,	# don't know how to map
  'losidestick'		=> undef,	'ssl'	=> undef,	# don't know how to map
  'guiro'		=> 73,		'gui'	=> 73,		# arbitrarily map to guis
  'shortguiro'		=> 73,		'guis'	=> 73,
  'longguiro'		=> 74,		'guil'	=> 74,
  'cabasa'		=> 69,		'cab'	=> 69,
  'maracas'		=> 70,		'mar'	=> 70,
  'shortwhistle'	=> 71,		'whs'	=> 71,
  'longwhistle'		=> 72,		'whl'	=> 72,
  'handclap'		=> 39,		'hc'	=> 39,
  'tambourine'		=> 54,		'tamb'	=> 54,
  'vibraslap'		=> 58,		'vibs'	=> 58,
  'tamtam'		=> undef,	'tt'	=> undef,	# no way to map this
  'claves'		=> 75,		'cl'	=> 75,
  'hiwoodblock'		=> 76,		'wbh'	=> 76,
  'lowoodblock'		=> 77,		'wbl'	=> 77,
  'opencuica'		=> 79,		'cuio'	=> 79,
  'mutecuica'		=> 78,		'cuim'	=> 78,
  'triangle'		=> 81,		'tri'	=> 81,		# arbitrarily map to trio
  'opentriangle'	=> 81,		'trio'	=> 81,
  'mutetriangle'	=> 80,		'trim'	=> 80,
  'oneup'		=> undef,	'ua'	=> undef,	# no idea what this is
  'twoup'		=> undef,	'ub'	=> undef,	# no idea what this is
  'threeup'		=> undef,	'uc'	=> undef,	# no idea what this is
  'fourup'		=> undef,	'ud'	=> undef,	# no idea what this is
  'fiveup'		=> undef,	'ue'	=> undef,	# no idea what this is
  'onedown'		=> undef,	'da'	=> undef,	# no idea what this is
  'twodown'		=> undef,	'db'	=> undef,	# no idea what this is
  'threedown'		=> undef,	'dc'	=> undef,	# no idea what this is
  'fourdown'		=> undef,	'dd'	=> undef,	# no idea what this is
  'fivedown'		=> undef,	'de'	=> undef,	# no idea what this is
);
use vars qw( %expressive_mark_to_midi_velocity );
%expressive_mark_to_midi_velocity = (
  'ppppp'	=> 1,
  'pppp'	=> 8,	# this should be 8 according to Vandenneucker (2012)
  'ppp'		=> 20,	# this should be close to 20 according to Yamaha (n.d.), exactly 20 according to Vandenneucker (2012)
  'pp'		=> 31,
  'p'		=> 42,
  'mp'		=> 53,
  'mf'		=> 64,
  'f'		=> 80,
  'ff'		=> 96,
  'fff'		=> 112,	# this should be close to 110 according to Yamaha (n.d.), exactly 112 according to Vandenneucker (2012)
  'ffff'	=> 119,	# this should be 127 according to Vandenneucker (2012)
  'fffff'	=> 127,
);
use vars qw( %interpretation );
use vars qw( %typesettable_version );
use vars qw( %mode_description );
use vars qw( %melody_description );

sub interpret_absolute_pitch ($) { # interpret c' as c4
  my($s) = @_;
  my $it;
  if ($s =~ /^(\w+)(?:(,*)|('*))$/) {
    $it = $ly_notes{$1} + 12*(3 - length($2) + length($3));
  } else {
    die "Can't interpret absolute pitch " . Debug::cvs($s);
  }
  return $it;
}

sub interpret_divisor ($) {
  my($s) = @_;
  no integer;
  return !defined $s? $s: $s =~ /\x{5c}longa/? 0.25: $s =~ /\x{5c}breve/? 0.5: $s =~ /^\d+$/? $s + 0: $s; # XXX
}

sub calculate_beat_length ($$) {
  my($divisor, $dots) = @_;
  no integer;
  my $it = 4 / $divisor;
  for (my $i = $dots, my $adj = $it/2; $i; $i -= 1, $adj /= 2) {
    $it += $adj;
  }
  return $it;
}

my $duration_re = q((?:(\s*\x{5c}longa|\s*\x{5c}breve|\d+)(\.+)?));	# NOTE: 2 captures: divisor, dots
sub interpret_melody ($) {
  my($s0) = @_;
  my $it;
  my $typesettable_version;
  no integer;

  state $rest_re = sprintf('(?:r)');
  state $percussion_instrument_re = sprintf('(?:%s)', join('|', keys %percussion_note_to_midi_number));
  state $pitch_re = q(([a-g](?:[ei]s)?)?(?:(,*)|('*)));				# NOTE: 3 captures: base pitch, commas, apostrophes
  state $pitch_re_no_captures = ($pitch_re =~ s/\x28(?!\?)/\x28?:/sgr);
  state $expressive_mark_re = sprintf("(?:%s)", join('|', keys %expressive_mark_to_midi_velocity));
  state $end_re = q((?=[-\s\x{7d}\x{5e}~()\[\]]|$));				# - or space or braceright or caret or tilde or ()[] or eof

  my $state = new Interpret_Melody_State;
  my($last_pitch, $percussive_instrument);
  my $main_instrument = 'Carillon';
  my($tie_p);
  my($note, $divisor, $dots, $volume) = (undef, 4, 0, $expressive_mark_to_midi_velocity{'mf'});
  my($def_key, $def_value, $def_level, %def);
  my($current_position, $position_at_end_of_last_recording);
  my $grace_note_type;
  my $voice;
  for (my($s, @stack) = ($s0); $s =~ /\S/s; ) {
    unless (defined $def_key) {
      $s =~ s/^\s*//s;
      $typesettable_version .= $&;
    }
    if ($s =~ /^\\([A-Za-z]+)\b/s && defined $def{$1}) {	# expand variables
      my($key) = $1;						# we MUST store this in a variable for the substitution to work
      $s =~ s/^\\$key/$def{$key}/s;
    }
    my $lhs;
    my $directive;
    log_debug sprintf 's=%s', Debug::cvs($s) if $debug > 2;
    if ($s =~ s/^\%[^\n]*\n*//s) {		# percent - comment to always discard
      ;
    } elsif (!defined $def_key && $s =~ s/^([A-Za-z]+)\s*=\s*//s) {
      ($def_key, $def_value, $def_level) = ($1);
    } elsif (defined $def_key) {
      if ($s =~ s/^(\s+)//s) {
	$def_value .= ' ';
      } elsif ($s =~ s/^("[^""]*")//s) {
	$def_value .= $1;
      } elsif ($s =~ s/^((?:\x{7b}|<<))//s) {		# braceleft
	$def_value .= $1;
	$def_level += 1;
      } elsif ($s =~ s/^((?:\x{7d}|>>))//s) {		# braceright
	$def_value .= $1;
	$def_level -= 1;
	if ($def_level == 0) {
	  $def_value = $1 if $def_value =~ /^{\s*(.*?)\s*}$/s;
	  $def{$def_key} = $def_value;
	  ($def_key, $def_value, $def_level) = ();
	}
      } elsif ($s =~ s/^(\S)//s) {
	$def_value .= $1;
      } else {
	log_error "interpret_melody: defined \$def_key reached \"else\" case";
      }

    } elsif ($s =~ s/^\x{7b}\s*//s) {		# braceleft
      $typesettable_version .= $&;
      $state->gsave();

    } elsif ($s =~ s/^<>-\s*//s) {		# ignore empty containers for expressive marks
      $typesettable_version .= $&;

    } elsif ($s =~ s/^<<\s*//s) {		# FIXME
      $typesettable_version .= $&;
      $state->gsave();

    } elsif ($s =~ s/^>>\s*//s) {		# FIXME
      $typesettable_version .= $&;
      $state->grestore($s);

    } elsif ($s =~ s/^[\^_]\\markup\s+//s) {	# ignore markup
      $typesettable_version .= $&;
    } elsif ($s =~ s/^\\(?:halign\s+#\w+|markup|tiny)\s+//s) {	# ignore markup
      $typesettable_version .= $&;

    } elsif ($s =~ s/^#\(\s*play-recording\s+"([^""]+)"\s+(\d+(?:\.\d+)?)\s+(\d+(?:\.\d+)?)(?:\s+(\d+(?:\.\d+)?))?\s*\)\s+//s) { # pseudo-lisp 
      my($filename, $start, $end, $treat_as_this_many_beats) = ($1, $2, $3, $4);
      # Generate pseudo-note directly instead of setting $directive ($directive needs an existing note to act on)
      no integer;
      my $duration = $end - $start;
      my $unit = 4*$state->unit_beat();
      my $unit_beats = $duration/$unit;
      my $quantized_beats = int($unit_beats);
      my @quantized_beats = (1) x $quantized_beats;
      my $remainder = $unit_beats - $quantized_beats;
      for (my $divisor = 2; $divisor < 32; $divisor *= 2) {
	my $adjustment = 1/$divisor;
	if (($remainder * $divisor) & 1) {
	  push @quantized_beats, $divisor;
	  $quantized_beats += $adjustment;
	  $remainder -= $adjustment;
	}
      }
      my $fake_duration = $quantized_beats*$unit;
      $fake_duration = $treat_as_this_many_beats*$state->unit_beat() if defined $treat_as_this_many_beats;
      my $fake_note = ['ua', $fake_duration, $volume, undef, {
	    'directive' => ['play', $filename, $start, $end],
	    'durations' => [@quantized_beats],
	  }];
      push @$voice, $fake_note;

      # Generate a typesettable score that makes actual sense. We basically have two options: set it as a one-line percussion staff
      # and show all the notes, or set it as a non-percussion staff (RhythmicStaff is perfect for this as it's one-line) and show
      # a cluster that's just one black line. The good thing about separate notes is we can attach start and end times to the correct
      # notes; we can't do this with clusters but separate notes are misleading given we're talking about recordings (no known notes).
      # If we use a non-percussion staff b' (absolute) will look about right, otherwise ua is a good placeholder with no MIDI meaning.
      #
      # If Lilypond sees two consecutive clusters, it will merge them even though they are two separate clusters. The only way to
      # prevent this is to insert a rest between them.
      #
      $typesettable_version .= sprintf('\set Staff.instrumentName = #"%s" \textLengthOn', $filename);
      state $last_note_used;
      my $use_clusters_p = !$state->drummode_p();
      my $fmt0 = '_\markup{ \halign #%s \tiny "%s" }';
      my($fmt1a, $fmt1b) = (sprintf($fmt0, 'LEFT', '%.2f'), sprintf($fmt0, 'RIGHT', '%.2f'));
      my $clash_p = $use_clusters_p && defined $position_at_end_of_last_recording && $position_at_end_of_last_recording == $current_position;
      my $note = !$use_clusters_p? 'da': !$clash_p? "c''": $last_note_used eq "c''"? "a'": "c''";
      my $markup = sprintf($fmt1a, $start);
      for my $pass (!$use_clusters_p? ('normal'): ('cluster', 'ghost')) {
	my $last_duration;
	my $tie = ' ';
	$typesettable_version .= "<<\n" if $pass eq 'cluster';
	$typesettable_version .= "\\\\\n" if $pass eq 'ghost';
	$typesettable_version .= '\makeClusters ' if $pass eq 'cluster';
	$typesettable_version .= "{\n\\absolute {\n" if $use_clusters_p;
	$typesettable_version .= '\voiceOne ' if $pass eq 'ghost';
	$typesettable_version .= sprintf("%s\n", join(' ', map {"\\hide $_"} ($pass eq 'ghost'? qw(NoteHead Rest Stem Dots Tie): qw(Rest))));
	my($gap, @effective_quantized_beats) = (undef, @quantized_beats);
	if ($pass eq 'cluster' && $clash_p) {
	  $gap = 128;
	  for (; $quantized_beats[$#quantized_beats] != $gap;) {
	    my $n = pop @quantized_beats;
	    $n *= 2;
	    push @quantized_beats, $n;
	    push @quantized_beats, $n unless $n == $gap;
	  }
	}
	$typesettable_version .= " r$gap" if defined $gap;
	for my $duration (@quantized_beats) {
	  if (!$duration) {
	    ;
	  } elsif (defined $last_duration && $last_duration == $duration/2) {
	    $typesettable_version .= '.';
	  } else {
	    $typesettable_version .= sprintf('%s%s%d', $tie, $note, $duration);
	    if ($pass ne 'cluster') {
	      $typesettable_version .= $markup;
	      $markup = undef;
	    }
	  }
	  $tie = '~';
	  $last_duration = $duration;
	}
	$typesettable_version .= $markup if $pass ne 'cluster' && defined $markup;
	$typesettable_version .= sprintf($fmt1b, $end) if $pass ne 'cluster';
	$typesettable_version .= "}\n" if $use_clusters_p;	# close \absolute
	$typesettable_version .= "}\n" if $use_clusters_p;
      }
      $typesettable_version .= ">>\n" if $use_clusters_p;
      $last_note_used = $note;

      # Update current position manually
      $current_position += $duration;
      $position_at_end_of_last_recording = $current_position;

    } elsif ($s =~ s/^"((?:\\"|[^"])*)"//s) {				# text
      $typesettable_version .= $&;
      my($s) = ($1);

    } elsif ($s =~ s/^\\(laisserVibrer)\s+//s) {			# ignore \laisserVibrer for now
      $typesettable_version .= $&;
      $directive = $1;

    } elsif ($s =~ s/^\\(acciaccatura)\s+//s) {				# ignore \acciaccatura for now
      $typesettable_version .= $&;
      $grace_note_type = $1;

    } elsif ($s =~ s/^\\key\s+$pitch_re\s+\\(?:major|minor)\s+//s) {	# ignore \key
      $typesettable_version .= $&;

    } elsif ($s =~ s/^\\partial\s+$duration_re\s+//s) {			# ignore \partial
      $typesettable_version .= $&;

    } elsif ($s =~ s/^\\mark\s+(?:\\default|#\d+|"[^""]+")\s+//s) {	# ignore \mark
      $typesettable_version .= $&;

    } elsif ($s =~ s/^\\set\s+Score\.markFormatter\s+=\s+#[-a-z]+\s+//s) {	# ignore set mark formatter
      $typesettable_version .= $&;

    } elsif ($s =~ s/^\\textLengthOn\s+//s) {				# ignore \textLengthOn
      $typesettable_version .= $&;

    } elsif ($s =~ s/^\\omit\s+[A-Z][A-Za-z]+(?:\.[A-Z][A-Za-z]+)+\s+//s) {	# ignore \omit
      $typesettable_version .= $&;

    } elsif ($s =~ s/^\\new\s+(?:(?:(Drum)|Rhythmic)?Staff|Voice)\s+(?:\\with \{[^\{}]+})?//s || $s =~ s/^\\\\\s*//s) {
      $typesettable_version .= $&;
      # FIXME - do we need to gsave?
      $state->drummode_p(1) if $1;
      push @$it, $voice if $voice;
      $voice = undef;

    } elsif ($s =~ s/^\\voice(?:One|Two|Three|Four)\s+//s) {
      $typesettable_version .= $&;

    } elsif ($s =~ s/^\\score\s+\x{7b}\s*//s) {
      $typesettable_version .= $&;
      $state->gsave();

    } elsif ($s =~ s/^\\(?:drums|drummode)\s*\x{7b}//s) {
      $typesettable_version .= $&;
      $state->gsave();
      $state->drummode_p(1);
      # FIXME - do we need to push voice?

    } elsif ($s =~ s/^\\absolute\s*\x{7b}//s) {
      $typesettable_version .= $&;
      $state->gsave();
      $state->relative_p(0);

    } elsif ($s =~ s/^\\relative\s*\x{7b}//s) {
      $typesettable_version .= $&;
      $state->gsave();
      $state->relative_p(1);
      $last_pitch = undef;

    } elsif ($s =~ s/^\\relative\s+($pitch_re)\s*\x{7b}//s) {
      $typesettable_version .= $&;
      $state->gsave();
      $state->relative_p(1);
      $last_pitch = interpret_absolute_pitch $1;

    } elsif ($s =~ s/^\\transpose\s+($pitch_re)\s+($pitch_re)\s*\x{7b}//s) {
      $typesettable_version .= $&;
      my($from, $to) = (interpret_absolute_pitch $1, interpret_absolute_pitch $5);
      $state->gsave();
      $state->relative_p(0);
      $state->transpose($state->transpose() + $to - $from);

    } elsif ($s =~ s/^\\repeat\s+(?:volta|unfold|percent)\s+(\d+)\s*\x{7b}//s) {
      $typesettable_version .= $&;
      my $n = $1 + 0;
      $state->gsave();
      $state->repeat_stacklevel($state->stacklevel());
      $state->repeat_count($n);
      $state->repeat_start(defined $voice? scalar @$voice: 0);

    } elsif ($s =~ s/^\x{7d}\s*//s) {		# braceright
      $typesettable_version .= $&;
      if (defined $state->repeat_stacklevel() && $state->repeat_stacklevel() == $state->stacklevel()) {
	my @A = @$voice;
	my $i = $state->repeat_start();
	my $n = $state->repeat_count();
	$voice = [@A[0 .. $i - 1], (@A[$i .. $#A]) x $n];
      }
      $state->grestore($s);
    } elsif ($s =~ s/^[\[\]]\s*//s) {		# ignore bracketleft/bracketright = beam on/beam off
      $typesettable_version .= $&;
    } elsif ($s =~ s/^\(\s*//s) {		# ignore parenleft = phrasing slur start
      $typesettable_version .= $&;
    } elsif ($s =~ s/^\)\s*//s) {		# ignore parenright = phrasing slur end
      $typesettable_version .= $&;
    } elsif ($s =~ s/^\|\s*//s) {		# ignore bar checks
      $typesettable_version .= $&;
    } elsif ($s =~ s/^\~\s*//s) {		# tie
      $typesettable_version .= $&;
      $tie_p = 1;
    } elsif ($s =~ s/^(?:\\accent\b|->)//s) {
      $typesettable_version .= $&;
      $directive = 'accent';
    } elsif ($s =~ s/^(?:\\staccato\b|-\.)//s) {
      $typesettable_version .= $&;
      $directive = 'staccato';
    } elsif ($s =~ s/^\x{5e}\s*\\(fermata)\b//s) {	# pause
      $typesettable_version .= $&;
      $directive = $1;
    } elsif ($s =~ s/^\\tempo(?:\s+"[^""]+")?\s+(\d+)\s+=\s+(\d+)\s+//s) {
      $typesettable_version .= $&;
      $state->tempo($1, $2);
    } elsif ($s =~ s/^\\time\s+\d+\/\d+\s+//s) {	# ignore time signature
      $typesettable_version .= $&;
    } elsif ($s =~ s/^\\clef\s+"[^""]+"\s*//s) {	# ignore clef change
      $typesettable_version .= $&;
    } elsif ($s =~ s/^\\breathe\s+//s) {	# ignore breath marks for now
      $typesettable_version .= $&;
    } elsif ($s =~ s/^\\tuplet\s+(\d+)\/(\d+)\s*\x{7b}//s) {
      $typesettable_version .= $&;
      $state->gsave();
      $state->unit_beat($state->unit_beat() * $2 / $1);
    } elsif ($s =~ s/^$duration_re$end_re//s) {
      $typesettable_version .= $&;
      ($divisor, $dots) = (interpret_divisor $1, length $2);
      log_debug "Duration \"$divisor$dots\" encountered before any rest, pitch, or percussion instrument" unless defined $note;
      $lhs = $note;

    } elsif ($s =~ s/^$rest_re(?:$duration_re)?$end_re//s) {
      $typesettable_version .= $&;
      my($new_divisor, $new_dots) = ($1, $2);
      ($divisor, $dots) = (interpret_divisor $new_divisor, length $new_dots) if defined $new_divisor;
      $lhs = 'r';

    } elsif ($s =~ s/^(?!$end_re)($pitch_re)(?:$duration_re)?$end_re//s		# make sure SOMETHING is matched ($pitch_re can match nothing)
	  || $s =~ s/^<\s*($pitch_re)(?:\s+$pitch_re_no_captures)+\s*>(?:$duration_re)?$end_re//s) {	# discard lower notes in chords

      my $what = $&;
      $typesettable_version .= $&;
      my($pitch_as_written, $base_pitch, $lower, $raise, $new_divisor, $new_dots)
	  = ($1, ($ly_notes{$2} + 12)%12, 0 + length $3, 0 + length $4, $5, $6);

      my $pitch;
      if ($state->relative_p()) {
	($last_pitch, $lower, $raise) = (interpret_absolute_pitch $pitch_as_written, undef, undef) if !defined $last_pitch;
	my $last_base_pitch = ($last_pitch + 12)%12;
	for (my $i = 0; $i < 8; $i += 1) {
	  for my $dir (-1, 1) {
	    my $candidate = $last_pitch + $dir*$i;
	    $pitch = $candidate if $candidate%12 == $base_pitch;
	  last if defined $pitch;
	  }
	last if defined $pitch;
	}
	$pitch += 12*($raise - $lower);
      } else {
	$pitch = interpret_absolute_pitch $pitch_as_written;
      }
      $pitch += $state->transpose() if defined $pitch;
      ($divisor, $dots) = (interpret_divisor $new_divisor, length $new_dots) if defined $new_divisor;
      $lhs = $midi_number_to_note[$pitch];
      die "interpret_melody error: note $pitch_as_written out of range\n" unless defined $lhs;
      $last_pitch = $pitch;

    } elsif ($s =~ s/^($percussion_instrument_re)(?:$duration_re)?$end_re//s) {
      $typesettable_version .= $&;
      ($percussive_instrument, my $new_divisor, my $new_dots) = ($1, $2, $3);
      ($divisor, $dots) = (interpret_divisor $new_divisor, length $new_dots) if defined $new_divisor;
      $lhs = $percussive_instrument;

    } elsif ($s =~ s/^\\($expressive_mark_re)\b//s) {
      $typesettable_version .= $&;
      $volume = $expressive_mark_to_midi_velocity{$1};

    } elsif ($s =~ s/^\\set\s+Staff\.instrumentName\s+=\s+#"([^""]+)"\s*//s) {
      $typesettable_version .= $&;
      $main_instrument = $1;

    } elsif ($s =~ s/^(\S+)//s) {
      $typesettable_version .= $&;
      log_debug sprintf('Unknown expression "%s" near "%s" discarded', $1, $');
    } else {
      $typesettable_version .= $&;
      log_debug "Internal error: \"else\" case reached in interpret_melody, s=($s)";
    }
    if (defined $lhs) {
      my $rhs = $state->unit_beat() * calculate_beat_length($divisor, $dots);
      if ($tie_p) {
	if (!defined $note) {
	  $tie_p = 0;
	  log_error "Tie ignored because there is no note to tie to";
	} elsif ($note ne $lhs) {
	  $tie_p = 0;
	  log_error "Tie ignored because $note and $lhs are different";
	} else {
	  $voice->[+scalar @$voice - 1][1] += $rhs;
	}
      }
      my $rest_p = $lhs eq 'r';
      my $instrument = ($lhs eq $percussive_instrument || $rest_p)? undef: $main_instrument; # FIXME
      my $node = [$lhs, $rhs, ($rest_p? undef: $volume), $instrument] unless $tie_p;
      if (defined $grace_note_type) {	# zero out the note's duration, in effect ignoring all grace notes for now
	$node->[1] = 0;
	$node->[4] = {'actual-duration' => $rhs};
      }
      push @$voice, $node if defined $node;
      $note = $lhs;
      $tie_p = 0;
      $grace_note_type = undef;
      no integer;
      $current_position += $rhs;
    } elsif (defined $directive) {
      my $verb = ref $directive? $directive->[0]: $directive;
      if (!defined $note) {
	log_error "Directive $verb ignored because there is no note before it";
      } elsif ($verb eq 'accent') {
	my $volume = $voice->[+scalar @$voice - 1]->[2];
	if (defined $volume) {
	  no integer;
	  $volume *= 1.44;
	  $volume = 127 if $volume > 127;
	  $voice->[+scalar @$voice - 1]->[2] = $volume;
	}
      } elsif ($verb eq 'staccato') {
	my $node = $voice->[+scalar @$voice - 1];
	no integer;
	$node->[4]->{'actual-duration'} = $node->[1]/4;
      } elsif ($verb eq 'fermata') {
	$voice->[+scalar @$voice - 1]->[1] *= 2;	# FIXME
      } elsif ($verb eq 'laisserVibrer') {
	;						# FIXME
      } else {
	log_error "interpret_melody: Unknown directive \"$verb\"";
      }
    }
  }
  push @$it, $voice if $voice;
  log_debug sprintf "%s interpreted as %s", $s0,
      join(" \\\\ ", map { join(' ', map { $_->[0] } @$_) } @$it) if $debug > 1;
  return wantarray? ($it, $typesettable_version): $it;
}

sub event_id ($$;$) {
  my($mode, $event, $melody) = @_;
  return join('-', map { defined $_? s/[^\.\w]+/_/sgr: () } ($mode, $melody, $event));
}
sub define_event_internal_real ($$$$$$$%) {
  my($mode, $melody, $description, $composer, $year, $source, $shared_defs, %event_defs) = @_;
  my %it;
  my($t0, $thing) = (eval { no integer; Time::HiRes::time },
		    (defined $melody? $melody: join(' ', ($mode, sort keys %event_defs))) =~ s/^\s+//sr);

  log_comment "interpreting score for $thing" if $debug || $verbose_p;
  if (defined $melody && defined $description) {
    $melody_description{$melody} = {'description' => $description, 'source' => $source};
    $melody_description{$melody}->{'composer'} = $composer if defined $composer;
    $melody_description{$melody}->{'year'} = $year if defined $year;
  } elsif (defined $mode && defined $description) {
    $mode_description{$mode} = {'description' => $description, 'source' => $source};
    $mode_description{$mode}->{'composer'} = $composer if defined $composer;
    $mode_description{$mode}->{'year'} = $year if defined $year;
  }
  $shared_defs =~ s/(?:^|(?<=\n))\s+//sg;			# kill indents
  $shared_defs =~ s/\s+$//sg;					# trim
  $shared_defs .= "\n" if $shared_defs =~ /\S/s;		# force newline at end if nonempty
  for my $event (keys %event_defs) {
    my $tune = $event_defs{$event};
    $tune = sprintf('\\new Staff { %s }', $tune) unless $tune =~ /^\s*\\(?:drums|new\s+(?:Drum|Rhythmic)?Staff)\s+/;
    $tune = sprintf('%s\score { %s }', $shared_defs, $tune);
    $event = sprintf('q%d', $1/2) if $event =~ /^e[02468]$/;	# in case we got e2, e4 etc, convert them to q1, q2 etc.
    $event = "q0" if $event eq 'q4';				# in case we got q4
    if ($event =~ /^(?:h|halb)$/ && $tune =~ /\%[Il]/) {	# expand to h1..h12
      for (my $i = 1; $i <= 12; $i += 1) {
	my $edited_tune = $tune;
	$edited_tune =~ s/\%[Il]/$i/sg;
	$it{&event_id($mode, "$event$i", $melody)} = $edited_tune;
      }
    } else {
      $it{&event_id($mode, $event, $melody)} = $tune;
    }
  }
  for my $tune (values %it) {
    my($interpretation, $typesettable_version) = interpret_melody $tune;
    $interpretation{$tune} = $interpretation unless defined $interpretation{$tune};
    $typesettable_version{$tune} = $typesettable_version unless defined $typesettable_version{$tune};
  }
  log_comment sprintf "%s defined in %.2f s", $thing, Time::HiRes::time - $t0 if $debug || $verbose_p;
  return %it;
}
sub define_event_internal ($$$$$$$%) {
  my($specified_mode, $specified_melody, $description, $composer, $year, $source, $shared_defs, %event_defs) = @_;
  my %it;
  if (!defined $specified_mode || ($specified_mode eq $mode && ($mode ne MODE__CARILLON || $specified_melody eq $melody))) {
    %it = define_event_internal_real($specified_mode, $specified_melody, $description, $composer, $year, $source, $shared_defs, %event_defs);
  } else {
    log_debug sprintf "%s %s definition skipped", $specified_mode, $specified_melody if $debug;
  }
  return %it;
}
sub define_event ($$$$$$$%) {
  my($mode, $melody, $description, $composer, $year, $source, $shared_defs, %event_defs) = @_;
  my %it;
  if (ref $melody eq 'HASH') {
    for my $melody_i (keys %$melody) {
      my $description_i = defined $description? $description: $melody->{$melody_i}->{'title'};
      my $composer_i = defined $composer? $composer: $melody->{$melody_i}->{'composer'};
      my $year_i = defined $year? $year: $melody->{$melody_i}->{'year'};
      my $source_i = defined $source? $source: $melody->{$melody_i}->{'source'};
      my %event_defs_i = %{$event_defs{$melody_i}};
      %it = (%it, define_event_internal($mode, $melody_i, $description_i, $composer_i, $year_i, $source_i, $shared_defs, %event_defs_i));
    }
  } else {
    %it = define_event_internal($mode, $melody, $description, $composer, $year, $source, $shared_defs, %event_defs);
  }
  return %it;
}
sub interpret_watch ($$$$$$) {
  my($watch, $subwatch, $volume1, $instrument1, $volume2, $instrument2) = @_;
  my $score;
  my($repeats, $pattern) = @{$watch_chime_pattern[$watch - 1]};
  my $gap = ($watch == 1? ' r2': ' r4.'); # FIXME
  no integer;
  my $previous_volume;
  my $beats;
  for (my $i = 0; $i < $repeats; $i += 1) {
    $beats = calculate_beat_length(interpret_divisor $1, length $2) if $i == 0 && $gap =~ /$duration_re$/;
    $score .= $gap if defined $score;
    my $previous_duration; # need to reset this after emitting r
    for my $length (map { $_ ne '.' } split(/\s+/, $pattern)) {
      $score .= ' ' if defined $score;
      my($instrument, $volume, $duration) = $length? ($instrument1, $volume1, '4.'): ($instrument2, $volume2, '8.');
      $score .= sprintf('<>-\%s ', $volume) if !defined $previous_volume || $previous_volume ne $volume;
      $score .= (!defined $previous_duration || $previous_duration ne $duration)? sprintf('%s%s', $instrument, $duration): $instrument;
      $previous_duration = $duration;
      $previous_volume = $volume;
      $beats += calculate_beat_length(interpret_divisor $1, length $2) if $i == 0 && $duration =~ /$duration_re$/;
    }
  }
  #printf STDERR "%s x%d interpreted as %s\n", $pattern, $repeats, $score;

  my($numerator, $denominator) = (8*$beats, 32);
  while ($numerator%2 == 0 && $denominator%2 == 0 && $denominator > 8) {
    $numerator /= 2;
    $denominator /= 2;
  }
  return sprintf('\drums { \tempo 4 = 60 \time %g/%g %s }', $numerator, $denominator, $score);
}
sub define_watches ($$$$$) {
  my($subwatch, $volume1, $instrument1, $volume2, $instrument2) = @_;
  my %defs;
  for (my $watch = 1; $watch <= 5; $watch += 1) {
    my $event_id = defined $subwatch? "w$watch.$subwatch": "w$watch";
    $defs{$event_id} = interpret_watch($watch, $subwatch, $volume1, $instrument1, $volume2, $instrument2);
  }
  return define_event(undef, undef, undef, undef, undef, undef, undef, %defs);
}


use vars qw( %chime );
sub define_chimes () {
  my $t0 = eval { no integer; Time::HiRes::time };
%chime = (
  define_watches(1,     'ff', 'cyms',  'ff', 'tamb'),
  define_watches(5,     'ff', 'cymch', 'ff', 'mar'),
  define_watches(undef, 'ff', 'cymch', 'ff', 'cl'),
  define_event(MODE__SYSLINE, undef, 'sysline mode', undef, undef, '4.2bsd', q(
	A = \relative { \set Staff.instrumentName = #"Sine Wave" ees''''8 r4. ~ r4 }
      ),
      'q2' => '\A',
      'q0' => '\A',
      'h' => '\A',
    ),
  define_event(MODE__CUCKOO, undef, 'cuckoo clock mode', undef, '2021', undef, q(
	x = { \tempo 1 = 35 }
	S = \absolute { c'1 }
	A = { #(play-recording "72699__benboncan__cuckoo" 0.05 1.15) }
	B = { #(play-recording "72699__benboncan__cuckoo" 0.05 3.75) }
	C = { #(play-recording "72699__benboncan__cuckoo" 0.05 5.50) }
	D = { #(play-recording "72699__benboncan__cuckoo" 0.05 7.15) }
	E = { #(play-recording "72699__benboncan__cuckoo" 0.05 8.90) }
	F = { #(play-recording "72699__benboncan__cuckoo" 0.05 10.65 24) }
      ),
      'halb'	=> '\new RhythmicStaff << \x \A \new Staff { <>-\ff \S } >>',
      'h1'	=> '\new RhythmicStaff << \x \A \new Staff { <>-\ff \S } >>',
      'h2'	=> '\new RhythmicStaff << \x \B \new Staff { <>-\ff \repeat unfold 2 { \S } } >>',
      'h3'	=> '\new RhythmicStaff << \x \C \new Staff { <>-\ff \repeat unfold 3 { \S } } >>',
      'h4'	=> '\new RhythmicStaff << \x \D \new Staff { <>-\ff \repeat unfold 4 { \S } } >>',
      'h5'	=> '\new RhythmicStaff << \x \E \new Staff { <>-\ff \repeat unfold 5 { \S } } >>',
      'h6'	=> '\new RhythmicStaff << \x \F \new Staff { <>-\ff \repeat unfold 6 { \S } } >>',
      'h7'	=> '\new RhythmicStaff << \x { \F \A } \new Staff { <>-\ff \repeat unfold 7 { \S } } >>',
      'h8'	=> '\new RhythmicStaff << \x { \F \B } \new Staff { <>-\ff \repeat unfold 8 { \S } } >>',
      'h9'	=> '\new RhythmicStaff << \x { \F \C } \new Staff { <>-\ff \repeat unfold 9 { \S } } >>',
      'h10'	=> '\new RhythmicStaff << \x { \F \D } \new Staff { <>-\ff \repeat unfold 10 { \S } } >>',
      'h11'	=> '\new RhythmicStaff << \x { \F \E } \new Staff { <>-\ff \repeat unfold 11 { \S } } >>',
      'h12'	=> '\new RhythmicStaff << \x { \F \F } \new Staff { <>-\ff \repeat unfold 12 { \S } } >>',
    ),
  # Experiment of adding melodies to cuckoo mode. Edelweiss would have been appropriate
  # but it turns out Edelweiss cannot be used because it's not a real folk song
  define_event(MODE__CUCKOO, 'study1', 'cuckoo clock mode study 1', undef, '2021', undef, q(
	x = { \tempo 1 = 35 }
	S = \absolute { c'1 }
	A = { #(play-recording "72699__benboncan__cuckoo" 0.05 1.15) }
	B = { #(play-recording "72699__benboncan__cuckoo" 0.05 3.75) }
	C = { #(play-recording "72699__benboncan__cuckoo" 0.05 5.50) }
	D = { #(play-recording "72699__benboncan__cuckoo" 0.05 7.15) }
	E = { #(play-recording "72699__benboncan__cuckoo" 0.05 8.90) }
	F = { #(play-recording "72699__benboncan__cuckoo" 0.05 10.65 24) }
	% Source: https://www.volksliederarchiv.de/des-morgens-in-der-fruehe/
%	frueheglobal = { \key e \major \time 2/4 }
%	fruehemelody = \transpose c c' { \partial 8 \repeat volta 2 { e8 | e8. fis16 e8 c' | a4 e8 } c'8 |
%	  \mark "110p2" b8[e'] b[e'] | c'[a c'] c' | b4 dis' | e' e'8 |
%	  \mark "110p3" \repeat volta 2 { d'8 b fis gis | a[c'] e c' |
%	  \mark "110p4" 
%	}
	% Source: https://www.volksliederarchiv.de/kein-schoener-land-in-dieser-zeit/ (night)
	keinschoenerlandindieserzeitglobal = { \key a \major \time 3/4 }
	keinschoenerlandindieserzeitmelody = \transpose c c' { r2. | r4. % \partial 4.
	  <>-\mp
	  e8 e e | a4 cis' b8 a |
	  b4 r8 e e e | a4 cis' b8 a |
	  b4 r8 cis' a b | cis'8[e'] d' cis' b a |
	  b8[d'] cis'8 b a gis | a4 r8 cis' a b |
	  cis'8[e'] d' cis' b a | b[d'] cis' b a gis | a4 r8 }
	keinschoenerlandindieserzeitharmony = \transpose c c' { r2. | r4. % \partial 4.
	  e8 e e | cis4 a gis8 fis |
	  gis4 r8 e e e | cis4 a gis8 fis |
	  gis4 r8 a a gis | a8[cis'] b a gis a |
	  gis8[b] a gis a e | cis4 r8 a a gis |
	  a8[cis'] b a gis a | gis8[b] a e cis e | cis4 r8 }
	% Source: https://www.volksliederarchiv.de/ich-stund-an-einem-morgen/
      ),
      'halb'	=> '\new RhythmicStaff << \x \A \new Staff { <>-\ff \S } >>',
      'h1'	=> '\new RhythmicStaff << \x \A \new Staff { <>-\ff \S } >>',
      'h2'	=> '\new RhythmicStaff << \x \B \new Staff { <>-\ff \repeat unfold 2 { \S } } >>',
      'h3'	=> '\new RhythmicStaff << \x \C \new Staff { <>-\ff \repeat unfold 3 { \S } } >>',
      'h4'	=> '\new RhythmicStaff << \x \D \new Staff { <>-\ff \repeat unfold 4 { \S } } >>',
      'h5'	=> '\new RhythmicStaff << \x \E \new Staff { <>-\ff \repeat unfold 5 { \S } } >>',
      'h6'	=> '\new RhythmicStaff << \x \F \new Staff { <>-\ff \repeat unfold 6 { \S } } >>',
      'h7'	=> '\new RhythmicStaff << \x { \F \A } \new Staff { <>-\ff \repeat unfold 7 { \S } } >>',
      'h8'	=> '\new RhythmicStaff << \x { \F \B } \new Staff { <>-\ff \repeat unfold 8 { \S } } >>',
      'h9'	=> '\new RhythmicStaff << \x { \F \C } \new Staff { <>-\ff \repeat unfold 9 { \S } } >>',
      'h10'	=> '\new RhythmicStaff << \x { \F \D } \new Staff { <>-\ff \repeat unfold 10 { \S } } >>',
      'h11'	=> '\new RhythmicStaff << \x { \F \E } \new Staff { <>-\ff \repeat unfold 11 { \S } } >>',
      'h12'	=> '\new RhythmicStaff << \x { \F \F } \new Staff { <>-\ff \repeat unfold 12 { \S } } >>',
      'posth'	=> q(\keinschoenerlandindieserzeitglobal %\set Staff.instrumentName = #"Music Box"
	  << \voiceOne \keinschoenerlandindieserzeitmelody
	  \\\\ \voiceTwo \keinschoenerlandindieserzeitharmony >>),
    ),
  define_event(MODE__CARILLON, MELODY__ABBEY, 'Abbey chimes, Fort Augustus, NB', undef, '1880', 'Starmer, 1907, p. 13', q(
	x = { \tempo 1 = 68 }
	A = \relative { c''1 b d c }
	B = \relative { c''1 b d e }
	C = \relative { e''1 c d c }
	D = \relative { a'1(c) d c^\fermata }
	S = \relative { r1 g'1 }				% rest inserted
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \A \B',
      'q3' => '\x <>-\ff \A \B \C',
      'q0' => '\x <>-\ff \A \B \C \D',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__CAMBRIDGE, 'Cambridge Quarters', 'Jowett et al.', '1793–1794', 'Starmer, 1907, p. 7', q(
	x = { \tempo 4 = 64 }
	A = \relative c' { e'4 d c | g2. }
	B = \relative c' { c'4 e d | g,2. | c4 d e | c2. }
	C = \relative c' { e'4 c d | g,2. | g4 d' e | c2. | e4 d c | g2. }
	D = \relative c' { c'4 e d | g,2. | c4 d e | c2. | e4 c d | g,2. | g4 d' e | c2.^\fermata }
	S = \relative c' { c1 }
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \B',
      'q3' => '\x <>-\ff \C',
      'q0' => '\x <>-\ff \D',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__CAMBRIDGE_RCC, 'Chimes at R. C. Church, Cambridge', 'arr. Canon Scott', '1896', 'Starmer, 1907, p. 13', q(
	x = { \tempo 1 = 60 }
	A = \relative { d'1 g(a) b(g) a(g) }
	B = \relative { a'1 b a g e d }
	C = \relative { d'1 g a b g a g }
	D = \relative { c''1 a b g a g^\fermata }
	S = \relative { r1 d' }					% guessed
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \A \B',
      'q3' => '\x <>-\ff \A \B \C',
      'q0' => '\x <>-\ff \A \B \C \D',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__CANTERBURY, 'Canterbury Cathedral chimes', 'arr. F. J. O. Helmore', '1897', 'Starmer, 1907, p. 14', q(
	% The score given by Starmer is a Gregorian chant, so note lengths are meaningless. We need to interpret it or the music will sound dead
	A = \relative c' { g'8. a c4. }
	B = \relative c' { g'8. a c4. r4 d8. c b c2 }
	C = \relative c' { g'8. a c4. r4 d8. c b c2 r4 c8. b g4. }
	D = \relative c' { g'8. a c4. r4 d8. c b c2 r4 c8. b g4. r8 a8. c d c2 r4 }	% rest inserted
	S = \relative c' { cis1 }
      ),
      'q1' => '<>-\ff \A',
      'q2' => '<>-\ff \B',
      'q3' => '<>-\ff \C',
      'q0' => '<>-\ff \D',
      'h' => '<>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__GUILDFORD, 'Guildford chimes', 'George Wilkins', '1843', 'Starmer, 1907, p. 10', q(
	x = { \tempo 4 = 80 }
	A = \relative c' { c'2 e,4 a | g1 }
	B = \relative c' { e4 g c b | d, f a g | e1 }
	C = \relative c' { c'4 g a e | f d g e | a f g b | c1 }
	D = \relative c' { c4 g' e c' | b4. a8 g4 e | f a d, g | e2. f4 | g4 c b a | g e c c' | b g a e | g1 }
	S = \relative c' { c1 }
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \B',
      'q3' => '\x <>-\ff \C',
      'q0' => '\x <>-\ff \D',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__MAGDALEN, 'Magdalen chimes', undef, '1713', 'Starmer, 1907, p. 10', q(
	x = { \tempo 4 = 96 }
	A = \relative c' { b'4 c }
	B = \relative c' { b'4 c c, g' }
	C = \relative c' { g'4 a f e a d, }
	D = \relative c' { g'4 a f e a d, b' c | r2. }		% rest inserted
	S = \relative c' { c1 }
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \B',
      'q3' => '\x <>-\ff \C',
      'q0' => '\x <>-\ff \D',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__NEWCOLLEGE, 'New College chimes', undef, undef, 'Pearce, 1903; "Great Bells of the British Isles" (n.d.)', q(
	x = { \key d \major \omit Staff.TimeSignature }
	A = \relative c' { b'4 e, }
	B = \relative c' { d4 e b' a }
	C = \relative c' { b'4 g e a fis d }
	D = \relative c' { d4 fis e g b cis a d r1}	% rest inserted
	S = \relative c' { a1 }				% durations guessed
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \B',
      'q3' => '\x <>-\ff \C',
      'q0' => '\x <>-\ff \D',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__NORWICH, 'Norwich Cathedral chimes', 'E. S. Medley', '1876', 'Starmer, 1907, p. 11', q(
	x = { \tempo 1 = 75 }
	A = \relative c' { a'1 g f e d }
	B = \relative c' { d1 e a g f  | g d f e d }
	C = \relative c' { d1 e f a d, | f a g e f | d e g f d }
	D = \relative c' { a'1 e f g d | e f g e a | d, a' g f e | g f e d a' | r }
	S = \relative c' { r1. d1 }			% rest inserted to make it sound less rushed
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \B',
      'q3' => '\x <>-\ff \C',
      'q0' => '\x <>-\ff \D',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__TINGTANG2A, 'Ting-tang (ding-dong) quarters on major second', undef, 'traditional', 'Starmer, 1907, p. 4', q(
	x = { \tempo 4 = 96 }
	A = \relative c' { c'4 b }
	B = \relative c' { r4 }
	S = \relative c' { f1 }
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \A \B \A',
      'q3' => '\x <>-\ff \A \B \A \B \A',
      'q0' => '\x <>-\ff \A \B \A \B \A \B \A \B',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__TINGTANG2B, 'Ting-tang (ding-dong) quarters on minor second', undef, 'traditional', 'Starmer, 1907, p. 4', q(
	x = { \tempo 4 = 96 }
	A = \relative c' { c'4 bes }
	B = \relative c' { r4 }
	S = \relative c' { f1 }
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \A \B \A',
      'q3' => '\x <>-\ff \A \B \A \B \A',
      'q0' => '\x <>-\ff \A \B \A \B \A \B \A \B',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__TINGTANG3A, 'Ting-tang (ding-dong) quarters on major third', undef, 'traditional', 'Starmer, 1907, p. 4', q(
	x = { \tempo 4 = 96 }
	A = \relative c' { c'4 a }
	B = \relative c' { r4 }
	S = \relative c' { f1 }
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \A \B \A',
      'q3' => '\x <>-\ff \A \B \A \B \A',
      'q0' => '\x <>-\ff \A \B \A \B \A \B \A \B',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__TINGTANG3B, 'Ting-tang (ding-dong) quarters on minor third', undef, 'traditional', 'Starmer, 1907, p. 4', q(
	x = { \tempo 4 = 96 }
	A = \relative c' { c'4 aes }
	B = \relative c' { r4 }
	S = \relative c' { f1 }
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \A \B \A',
      'q3' => '\x <>-\ff \A \B \A \B \A',
      'q0' => '\x <>-\ff \A \B \A \B \A \B \A \B',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__TINGTANG4, 'Ting-tang (ding-dong) quarters on perfect fourth', undef, 'traditional', 'Starmer, 1907, p. 4', q(
	x = { \tempo 4 = 96 }
	A = \relative c' { c'4 g }
	B = \relative c' { r4 }
	S = \relative c' { f1 } % or e1 or c1
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \A \B \A',
      'q3' => '\x <>-\ff \A \B \A \B \A',
      'q0' => '\x <>-\ff \A \B \A \B \A \B \A \B',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__TINGTANG5, 'Ting-tang (ding-dong) quarters on perfect fifth', undef, 'traditional', 'Starmer, 1907, p. 4', q(
	x = { \tempo 4 = 96 }
	A = \relative c' { c'4 f, }
	B = \relative c' { r4 }
	S = \relative c' { c1 }
      ),
      'q1' => '\x <>-\ff \A',
      'q2' => '\x <>-\ff \A \B \A',
      'q3' => '\x <>-\ff \A \B \A \B \A',
      'q0' => '\x <>-\ff \A \B \A \B \A \B \A \B',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__WESTMINSTER, 'Westminster Quarters', 'Jowett et al.', '1793–1794', 'Wikipedia', q(
	A = \relative e' { gis4 fis e b2  }
	B = \relative e' { e4 gis fis b,2 }
	C = \relative e' { e4 fis gis e2  }
	D = \relative e' { gis4 e fis b,2 }
	E = \relative e' { b4 fis' gis e2 }
	S = \relative e' { e,2 }
	F = \relative e' { r1 }
      ),
      'q1' => '<>-\fff \A',
      'q2' => '<>-\fff \B \C',
      'q3' => '<>-\fff \D \E \A',
      'q0' => '<>-\fff \B \C \D \E \F',
      'h' => '<>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, MELODY__WHITTINGTON, 'Whittington chimes on eight bells', undef, 'traditional', 'Wikipedia', q(
	x = { \tempo 4 = 196 \key e \major }
	A = \relative e' { e'4-> fis, dis' gis, cis-> a b e, }
	B = \relative e' { e'4-> cis a fis dis'-> b gis e }
	C = \relative e' { e'4-> dis a gis cis-> b fis e }
	D = \relative e' { fis4-> a cis e dis-> b gis e }
	E = \relative e' { e'4-> dis cis b a-> gis fis e }
	S = \relative e' { e,\longa }
	F = \relative e' { r\longa }
      ),
      'q1' => '\x \E',
      'q2' => '\x \A \B',
      'q3' => '\x \C \D \E',
      'q0' => '\x \A \B \C \D \F',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
    ),
  define_event(MODE__CARILLON, {
      &MELODY__WHITTINGTON11 => {
	title => 'Whittington chimes on eleven bells',
      },
      'whittington11study' => {
	title => 'Whittington chimes on eleven bells (arr. Ambrose Li)',
      },
    }, 'Whittington chimes on eleven bells', 'Charles Villiers Stanford', '1905', 'Starmer, 1907, p. 5', q(
	s = { \key b \major \voiceOne \clef "treble" }
	t = { \key b \major \voiceThree \clef "bass" }
	b = { \key b \major \voiceFour \clef "bass" }
	w = { \tempo 4 = 96 }
	x = { \tempo 4 = 96 \time 3/4 }
	y = { <>-\mp \set Staff.instrumentName = #"Keyboard" }
	z = { <>-\mf }
	A = \transpose c b { c'4 g' f' e' }
	B = \transpose c b { c'4 g' f' e' g' d' }
	C = \transpose c b { a4 g f e g d' c' e' d' }
	D = \transpose c b { c'4 g' f' e' g' d' c' a f e g d^\fermata }	% pause inserted to make the hour strike sound less abrupt
	S = \transpose c b { c1 }
      ),
      &MELODY__WHITTINGTON11 => {
	'q1' => '\x <>-\ff \partial 4 \A',
	'q2' => '\x <>-\ff \B',
	'q3' => '\x <>-\ff \C',
	'q0' => '\x <>-\ff \D',
	'h' => '\w <>-\fff \repeat volta %I { \S }',
      },
      # FIXME: Don't use chord notation. The proof will look right but sound will be wrong because the code to handle chords just isn't there
      'whittington11study' => {
	'q1' => q(<< { \s \x <>-\f \partial 4 \A }
	      \new Staff { \t \x \y \transpose c b, { \partial 4 a1 } }
	      \new Staff { \b \x \y \transpose c b, { \partial 4 f1 } }
	    >>),
	'q2' => q(<< { \s \x <>-\f \B }
	      \new Staff { \t \x \y \transpose c b, { b2. a } }
	      \new Staff { \b \x \y \transpose c b, { g2. f } }
	    >>),
	'q3' => q(<< { \s \x <>-\f \C }
	      \new Staff { \t \x \y \transpose c b, { b2. c' d' } }
	      \new Staff { \b \x \y \transpose c b, { g2. a  b  } }
	    >>),
	'q0' => q(<< { \s \x <>-\f \D }
	      \new Staff { \t \x \y \transpose c b, { g2. a b a } }
	      \new Staff { \b \x \y \transpose c b, { e2. f g f } }
	    >>),
	'h1' => q(<< { \s \w <>-\ff { \S } }
	      \new Staff { \t \w \y \transpose c b, { c1 } }
	      \new Staff { \b \w \y \transpose c b, { c,1 } }
	    >>),
	'h2' => q(<< { \s \w <>-\ff { \S \S } }
	      \new Staff { \t \w \y \transpose c b, { d1 \z c } }
	      \new Staff { \b \w \y \transpose c b, { c1 \z c, } }
	    >>),
	'h3' => q(<< { \s \w <>-\ff { \S \S \S } }
	      \new Staff { \t \w \y \transpose c b, { e1 e \z c } }
	      \new Staff { \b \w \y \transpose c b, { c1 c \z c, } }
	    >>),
	'h4' => q(<< { \s \w <>-\ff { \S \S \S \S } }
	      \new Staff { \t \w \y \transpose c b, { f1 f f \z c } }
	      \new Staff { \b \w \y \transpose c b, { c1 c c \z c, } }
	    >>),
	'h5' => q(<< { \s \w <>-\ff { \S \S \S \S \S } }
	      \new Staff { \t \w \y \transpose c b, { g1 g g g \z c } }
	      \new Staff { \b \w \y \transpose c b, { c1 c c c \z c, } }
	    >>),
	'h6' => q(<< { \s \w <>-\ff { \S \S \S \S \S \S } }
	      \new Staff { \t \w \y \transpose c b, { a1 a a a a \z c } }
	      \new Staff { \b \w \y \transpose c b, { c1 c c c c \z c, } }
	    >>),
	'h7' => q(<< { \s \w <>-\ff { \S \S \S \S \S \S \S } }
	      \new Staff { \t \w \y \transpose c b, { b1 b b b b b \z c } }
	      \new Staff { \b \w \y \transpose c b, { c1 c c c c c \z c, } }
	    >>),
	'h8' => q(<< { \s \w <>-\ff { \S \S \S \S \S \S \S \S } }
	      \new Staff { \t \w \y \transpose c b, { c1 c c c c c c \z c, } }
	      \new Staff { \b \w \y \transpose c b, { c,1 c, c, c, c, c, c, \z c, } }
	    >>),
	'h9' => q(<< { \s \w <>-\ff { \S \S \S \S \S \S \S \S \S } }
	      \new Staff { \t \w \y \transpose c b, { d1 d d d d d d d \z c, } }
	      \new Staff { \b \w \y \transpose c b, { c,1 c, c, c, c, c, c, c, \z c, } }
	    >>),
	'h10' => q(<< { \s \w <>-\ff { \S \S \S \S \S \S \S \S \S \S } }
	      \new Staff { \t \w \y \transpose c b, { e1 e e e e e e e e \z c, } }
	      \new Staff { \b \w \y \transpose c b, { c,1 c, c, c, c, c, c, c, c, \z c, } }
	    >>),
	'h11' => q(<< { \s \w <>-\ff { \S \S \S \S \S \S \S \S \S \S \S } }
	      \new Staff { \t \w \y \transpose c b, { f1 f f f f f f f f f \z c, } }
	      \new Staff { \b \w \y \transpose c b, { c,1 c, c, c, c, c, c, c, c, c, \z c, } }
	    >>),
	'h12' => q(<< { \s \w <>-\ff { \S \S \S \S \S \S \S \S \S \S \S \S } }
	      \new Staff { \t \w \y \transpose c b, { g1 g g g g g g g g g g \z c, } }
	      \new Staff { \b \w \y \transpose c b, { c,1 c, c, c, c, c, c, c, c, c, c, \z c, } }
	    >>),
      },
    ),
  define_event(MODE__CARILLON, 'study1', 'Study 1', undef, '2021', 'O Canada, God Save The Queen, Malines half-quarters; cf. Starmers, 1910, p. 97', q(
	% Calixa Lavallée, 1880 (source: https://laws-lois.justice.gc.ca/fra/lois/N-2/20180207/P1TT3xt3.html)
	x = { \tempo 4 = 96 } % allegro vivent would be 120-ish but even at 120 it's way too fast
	A = \relative c'' {
	  \time 4/4
	  a2 c4. c8 | f,2. g4 | a4 bes4 c4  d4 |
	  g,2. r4 | a2 b4. b8 | c2. d4 |
	  e4 e4 d4 d4 | c2. g8.[a16] | bes4. a8 g4 a8.[bes16] |
	  c4. bes8 a4 bes8.[c16] | d4 c4 bes4 a4 | g2. g8.[a16] |
	  bes4. a8 g4 a8.[bes16] | c4. bes8 a4 a4 | g4 c4 c8[b8] a8[b8] | c2 r2 |
	  a2 c4. c8 | f,2 r2 | bes4.~bes8 d4. d8 | g,2 r2 |
	  c2 cis4. cis8 | d4 bes4 a4 g4 | f2 g2 | a2. r4 |
	  c2 f4. f8 | d4 bes4 a4 g4 | c2 e,2 | f2. r4 |
	}
	% Source:  Weir, R. S., Lavallée, C. & Schaeffer, G. A. G. (1914). O Canada! The national song of the Dominion.
	% Retrieved from https://archive.org/details/CSM_01142/
	nationalanthemglobal = { \time 4/4 \key ees \major }
	nationalanthem = \relative { \nationalanthemglobal
	<<
	  \relative {
	    \voiceOne
	    g'2 bes4. bes8 | ees,2. f4 | g aes bes c | f,2. r4 |
	    % p.4
	    g2 a4. a8 | bes2. c4 | d d c c | bes2. f8.[ g16] |
	    aes4. g8 f4 g8.[ aes16] | bes4. aes8 g4 aes8.[ bes16] | c4 bes aes g | f2. f8.[ g16] |
	    aes4. g8 f4 g8.[ aes16] | bes4. aes8 g4 g | f bes bes8[ a] g[ a] | bes2 r |
	    % p.5
	    g2 bes4. bes8 | ees,2 r | aes2 c4. c8 | f,2 r |
	    bes2 b4. b8 | c4 aes g f | ees2 f | g2. r4 |
	    bes2 ees4. ees8 | c4 aes g f | bes2 d, | ees1 |
	  }
	  \new Voice \relative {
	    \voiceTwo
	    ees'2 d4. d8 | c2. d4 | ees4 ees ees ees | ees2( d4) r |
	    % p.4
	    ees2 f4. f8 | f2. g4 | f4 f a a | f2. d4 |
	    d4. d8 d4 d | ees4. ees8 ees4 ees | ees ees ees ees | d2. d4 |
	    d4. d8 d4 d | ees4. ees8 ees4 cis | d f f f | f2 r |
	    % p.5
	    ees2 f4. f8 | ees2 r | f2 f4. f8 | f2 r |
	    ees2 des4. des8 | c4 c ees c | bes2 d | ees2. r4 |
	    ees2 ees4. ees8 | ees4 f ees c | ees2 bes | bes1 |
	  }
	  \new Staff
	  \relative { \clef "bass" \nationalanthemglobal
	    \voiceFour
	    ees2 bes4. bes8 | c2. bes4 | ees f g aes | bes2. r4 |
	    % p.4
	    ees,2 c4. c8 | d2. ees4 | f f f f | bes2. aes8.[ g16] |
	    f4. g8 aes4 bes8.[ aes16] | g4. f8 ees4 f8.[ g16] | aes4 g aes a | bes2. bes,4 |
	    bes4. bes8 bes4 bes | ees4. ees8 ees4 e | f f f f | bes2 r |
	    % p.5
	    ees,2 d4. d8 | c2 r | f2 ees4. ees8 | d2 r |
	    ees2 ees4. ees8 | aes,4 f g aes | bes2 bes | ees2. r4 |
	    g2 g,4. g8 | aes4 f g aes | bes2 bes | ees1 |
	  }
	>>
	}
	excerptfromstart = \relative a' {
	<<
	  \relative { \nationalanthemglobal
	    \voiceOne
	    g'2 bes4. bes8 | ees,2. f4 | g aes bes c | f,2. r4 |
	  }
	  \new Voice \relative { \nationalanthemglobal
	    \voiceTwo
	    ees'2 d4. d8 | c2. d4 | ees4 ees ees ees | ees2( d4) r |
	  }
	  \new Staff
	  \relative { \clef "bass" \nationalanthemglobal
	    ees2 bes4. bes8 | c2. bes4 | ees f g aes | bes2. r4 |
	  }
	>>
	}
	excerptfromend = \relative a' {
	<<
	  \relative g' { \nationalanthemglobal
	    \voiceOne
	    g2 bes4. bes8 | ees,2 r | aes2 c4. c8 | f,2 r |
	  }
	  \new Voice \relative ees'' { \nationalanthemglobal
	    \voiceTwo
	    ees,2 d4. d8 | c2 r | f2 ees4. ees8 | d2 r |
	  }
	  \new Staff
	  \relative ees' { \clef "bass" \nationalanthemglobal
	    ees,2 d4. d8 | c2 r | f2 ees4. ees8 | d2 r |
	  }
	>>
	}
	% anonymous, 1745
	excerptfromroyalanthem = {
	<<
	  \time 3/4
	  \key g \major
	  \relative g' {
	  g4 g a | fis4. g8 a4 | b b c | b4. a8 g4 |
	  a g fis | g2. |
	  d'4 d d | d4. c8 b4 | c c c | c4. b8 a4 |
	  b c8[b] a[g] | b4. c8 d4 | e8[c] b4 a | g2.
	  }
	  \new Staff
	  \relative { \clef "bass" % source: https://en.wikipedia.org/wiki/File:Gstk.png
	  \key g \major
	    g4 g, g' | d4. e8 fis4 | g g a | fis4. fis8 g4 |
	    c, d d | g,2. |
	    b'4 b b | b4. a8 g4 | a a a | a4. g8 fis4 |
	    g a8[g] fis[e] | d4. c8 b4 | c d4. d8 | g,2.
	  }
	>>
	}
	S = \relative { c'1 }
	% Malines half quarters from Starmer (1910, p. 97)
	malinesi   = \relative { r16 f'''[e d] c[b a g] f[c a f] c[a f8] }
	malinesii  = \relative { r8 a16[c] f[a c f] g[a b c] d[e f8] }
	malinesiii = \relative { \time 4/16 f''16[d a' f] | \time 16/16 d'[a f d] b'[g e cis] d[a f a] \clef "bass" d,8[d,] }
	malinesiv  = \relative { \time 4/16 r16 d''[f a]  | \time 16/16 d[a b g] a[f g e] f[d e cis] d8[\clef "bass" d,,] }
      ),
      'q1' => '\x \excerptfromstart',
      'q2' => '\x <>-\f \excerptfromroyalanthem r2.',
      'q3' => '\x \excerptfromend',
      'q0' => '\x \nationalanthem r1',
      'h' => '\x <>-\fff \repeat volta %I { \S }',
      # "continental" additions
      'halb' => q(\x <>-\f \repeat volta %I { \relative { c''1 } }),
      'e1' => q(\x \malinesi),
      'e3' => q(\x \malinesii),
      'e5' => q(\x \malinesiii),
      'e7' => q(\x \malinesiv),
    ),
  define_event(MODE__CARILLON, 'whittington8study', 'Whittington chimes on eight bells (chord study)', '2021', 'arr. Ambrose', 'Wikipedia', q(
	x = { \tempo 4 = 196 \key e \major }
	partA = \relative e' { e'4 fis, dis' gis, cis a b e, }
	partB = \relative e' { e'4 cis a fis dis' b gis e }
	partC = \relative e' { e'4 dis a gis cis b fis e }
	partD = \relative e' { fis4 a cis e dis b gis e }
	partE = \relative e' { e'4 dis cis b a gis fis e }
	A = { \mark "q1" \partE }
	B = { \mark "q2" \partA \partB }
	C = { \mark "q3" \partC \partD \partE }
	D = { \mark "q4" \partA \partB \partC \partD }
	S = \relative e' { e1 }

	Aa = \transpose c e	{ c'2 d' e'1 }
	Ba = \transpose c e	{ c'2 b a g | c'1 e' }
	Ca = \transpose c e	{ c'2 d' e1 | d'2 e' d'1 | c'2 d' b1 }
	Da = \transpose c e	{ c'1 d'2 b | e'1 d'2 b | c'1 e'2 d' | a1 g2 a }
	Sa = \transpose c e	{  }

	At = \transpose c e	{ a2 b g1 }
	Bt = \transpose c e	{ a2 g f e | a1 g }
	Ct = \transpose c e	{ a2 b c1 | b2 c' g1 | a2 b e1 }
	Dt = \transpose c e	{ a1 b2 g | c'1 b2 g | a1 c'2 b | f1 d2 e }
	St = \transpose c e	{ g,2. r4 }

	Ab = \transpose c e	{ f2 g c1 }
	Bb = \transpose c e	{ f2 e d c | f1 c }
	Cb = \transpose c e	{ f2 g a1 | g2 a b,1 | f2 g c1 }
	Db = \transpose c e	{ f1 g2 e | a1 g2 e | e1 a2 g | d1 b,2 c }
	Sb = \transpose c e	{ c,2. r4 }
      ),
      'q1' => '\x << \A \\\\ \Aa \\\\ \At \\\\ \Ab >>',
      'q2' => '\x << \B \\\\ \Ba \\\\ \Bt \\\\ \Bb >>',
      'q3' => '\x << \C \\\\ \Ca \\\\ \Ct \\\\ \Cb >>',
      'q4' => '\x << \D \\\\ \Da \\\\ \Dt \\\\ \Db >>',
      'h' => '\x r1 <>-\ff \repeat volta %I { << \S \\\\ \Sa \\\\ \St \\\\ \Sb >> }',
    ),
  define_event(MODE__CARILLON, {
	'study2' => { 'title' => 'Study 2',
		      'source' => 'Weir, Lavallée, and Schaeffer (1914); Starmers (1910, p. 97)',
		    },
	'study3' => { 'title' => 'Study 3',
		      'source' => 'Weir, Lavallée, and Schaeffer (1914); Stevenson (n.d.); Starmers (1910, p. 97)',
		    },
      }, undef, undef, '2021', undef, q(
	x = { \tempo 4 = 96 } % allegro vivent would be 120-ish but even at 120 it's way too fast
	% Source:
	% - Weir, R. S., Lavallée, C. & Schaeffer, G. A. G. (1914). O Canada! The national song of the Dominion.
	%   Retrieved from https://archive.org/details/CSM_01142/
	nationalanthemglobal = { \time 4/4 \key ees \major \x }
	nationalanthemMelodyPartA = \transpose c c' { g2 bes4. bes8 | ees2. f4 | g aes bes c' | f2. r4 | }
	nationalanthemMelodyPartB = \transpose c c' { \mark "4p1" g2 a4. a8 | bes2. c'4 | d' d' c' c' | bes2. }
	nationalanthemMelodyPartC = \transpose c c' { f8.[ g16] |
	    \mark "4p2" aes4. g8 f4 g8.[ aes16] | bes4. aes8 g4 aes8.[ bes16] | c'4 bes aes g | f2. }
	nationalanthemMelodyPartD = \transpose c c' { f8.[ g16] |
	    \mark "4p3" aes4. g8 f4 g8.[ aes16] | bes4. aes8 g4 g | f bes bes8[ a] g[ a] | bes2 r | }
	nationalanthemMelodyPartE = \transpose c c' { \mark "5p1" g2 bes4. bes8 | ees2 r | aes2 c'4. c'8 | f2 r | }
	nationalanthemMelodyPartF = \transpose c c' { \mark "5p2" bes2 b4. b8 | c'4 aes g f | ees2 f | g2. r4 | }
	nationalanthemMelodyPartG = \transpose c c' { \mark "5p3" bes2 ees'4. ees'8 | c'4 aes g f | bes2 d | ees1 | }
	nationalanthemAltoPartA = \transpose c c' { ees2 d4. d8 | c2. d4 | ees4 ees ees ees | ees2( d4) r | }
	nationalanthemAltoPartB = \transpose c c' { \mark "4p1" ees2 f4. f8 | f2. g4 | f4 f a a | f2. }
	nationalanthemAltoPartC = \transpose c c' { d4 |
	    \mark "4p2" d4. d8 d4 d | ees4. ees8 ees4 ees | ees ees ees ees | d2. }
	nationalanthemAltoPartD = \transpose c c' { d4 |
	    \mark "4p3" d4. d8 d4 d | ees4. ees8 ees4 cis | d f f f | f2 r | }
	nationalanthemAltoPartE = \transpose c c' { \mark "5p1" ees2 f4. f8 | ees2 r | f2 f4. f8 | f2 r | }
	nationalanthemAltoPartF = \transpose c c' { \mark "5p2" ees2 des4. des8 | c4 c ees c | bes,2 d | ees2. r4 | }
	nationalanthemAltoPartG = \transpose c c' { \mark "5p3" ees2 ees4. ees8 | ees4 f ees c | ees2 bes, | bes,1 | }
	nationalanthemBassPartA = { ees2 bes,4. bes,8 | c2. bes,4 | ees f g aes | bes2. r4 | }
	nationalanthemBassPartB = { \mark "4p1" ees2 c4. c8 | d2. ees4 | f f f f | bes2. }
	nationalanthemBassPartC = { aes8.[ g16] |
	    \mark "4p2" f4. g8 aes4 bes8.[ aes16] | g4. f8 ees4 f8.[ g16] | aes4 g aes a | bes2. }
	nationalanthemBassPartD = { bes,4 |
	    \mark "4p3" bes,4. bes,8 bes,4 bes, | ees4. ees8 ees4 e | f f f f | bes2 r | }
	nationalanthemBassPartE = { \mark "5p1" ees2 d4. d8 | c2 r | f2 ees4. ees8 | d2 r | }
	nationalanthemBassPartF = { \mark "5p2" ees2 ees4. ees8 | aes,4 f, g, aes, | bes,2 bes, | ees2. r4 | }
	nationalanthemBassPartG = { \mark "5p3" g2 g,4. g,8 | aes,4 f, g, aes, | bes,2 bes, | ees1 | }
	nationalanthem = <<
	  { \voiceOne
	    \nationalanthemglobal
	    \nationalanthemMelodyPartA \nationalanthemMelodyPartB \nationalanthemMelodyPartC \nationalanthemMelodyPartD
	    \nationalanthemMelodyPartE \nationalanthemMelodyPartF \nationalanthemMelodyPartG
	  }
	  \new Voice { \voiceTwo
	    \nationalanthemglobal
	    \nationalanthemAltoPartA \nationalanthemAltoPartB \nationalanthemAltoPartC \nationalanthemAltoPartD
	    \nationalanthemAltoPartE \nationalanthemAltoPartF \nationalanthemAltoPartG
	  }
	  \new Staff { \voiceFour \clef "bass"
	    \nationalanthemglobal
	    \nationalanthemBassPartA \nationalanthemBassPartB \nationalanthemBassPartC \nationalanthemBassPartD
	    \nationalanthemBassPartE \nationalanthemBassPartF \nationalanthemBassPartG
	  }
	>>
	excerptfromstart = <<
	  { \voiceOne
	    \nationalanthemglobal
	    \nationalanthemMelodyPartB
	  }
	  \new Voice { \voiceTwo
	    \nationalanthemglobal
	    \nationalanthemAltoPartB
	  }
	  \new Staff { \voiceFour \clef "bass"
	    \nationalanthemglobal
	    \nationalanthemBassPartB
	  }
	>>
	excerptfrommiddle = <<
	  { \voiceOne
	    \nationalanthemglobal
	    \nationalanthemMelodyPartB \nationalanthemMelodyPartC \nationalanthemMelodyPartD
	  }
	  \new Voice { \voiceTwo
	    \nationalanthemglobal
	    \nationalanthemAltoPartB \nationalanthemAltoPartC \nationalanthemAltoPartD
	  }
	  \new Staff { \voiceFour \clef "bass"
	    \nationalanthemglobal
	    \nationalanthemBassPartB \nationalanthemBassPartC \nationalanthemBassPartD
	  }
	>>
	excerptfromend = <<
	  { \voiceOne
	    \nationalanthemglobal
	    \nationalanthemMelodyPartF
	  }
	  \new Voice { \voiceTwo
	    \nationalanthemglobal
	    \nationalanthemAltoPartF
	  }
	  \new Staff { \voiceFour \clef "bass"
	    \nationalanthemglobal
	    \nationalanthemBassPartF
	  }
	>>
	% Source:
	% - Stevenson, J. (n.d.). “God Save The King!” The National Anthem of England, with an additional stanza for our gracious Queen;
	%   arranged for one, two, or three voices (and chorus) with an accompanyment for the piano forte.
	%   In <cite>Collection of sheet music from the late 18th and 19th centuries</cite>, 27–34.
	%   Retrieved from https://archive.org/details/hartley00535542
	royalanthemglobal = { \time 3/4 \key bes \major \tempo 4 = 72 }
	% p.4 in the score is p.32 in the PDF
	royalanthemMelodyPartA = \transpose c c'' { \mark "4p3" bes,4 bes, c | a,4. bes,8 c4 | d d ees | d4. c8 bes,4 | c bes, a, | bes,2. | }
	royalanthemMelodyPartB = \transpose c c'' { \mark "5p2" f4 f f | f4. ees8 d4 | 
	    \mark "5p3" ees ees ees | ees4. d8 c4 | }
	royalanthemMelodyPartC = \transpose c c'' { d ees8[ d] c[ bes,] | d4. ees8 f4 | g8[ f16 ees] d4( c8.) bes,16 | bes,2. | }
	royalanthemAltoPartA = \transpose c c' { \mark "4p3" f4 g g | f4. ees8 f4 | f g8[ bes] a[ g] | f4 g8[ a] bes4 | g f f | f2. | }
	royalanthemAltoPartB = \transpose c c' { \mark "5p2" f4 f f | f4. a8 bes4 | 
	    \mark "5p3" a f f | f4. f8 f4 | }
	royalanthemAltoPartC = \transpose c c' { f bes bes | f4. a8 bes4 | g8[ c'] bes4( a8.) bes16 | bes2. | }
	royalanthemBassPartA = \absolute { \mark "4p3" bes4 g ees | f4. g8 a4 | bes4 g ees | f4. fis8 g4 | ees f f, | bes,2. | }
	royalanthemBassPartB = \absolute { \mark "5p2" bes,4 d f | bes8[ a16 g] f[ ees d c] bes,4 |
	    \mark "5p3" f4 a c' | f4. f8 f4 | }
	royalanthemBassPartC = \absolute { bes8[ a] g[ f] ees[ d] | bes,4. c8 d4 | ees f r8. f,16 | bes,2. | }
	royalanthem = <<
	  { \voiceOne
	    \royalanthemglobal
	    \royalanthemMelodyPartA \royalanthemMelodyPartB \royalanthemMelodyPartC
	  }
	  \new Voice { \voiceTwo
	    \royalanthemglobal
	    \royalanthemAltoPartA \royalanthemAltoPartB \royalanthemAltoPartC
	  }
	  \new Staff { \voiceFour \clef "bass"
	    \royalanthemglobal
	    \royalanthemBassPartA \royalanthemBassPartB \royalanthemBassPartC
	  }
	>>
	% hour strike on random note
	S = \relative { c'1 }
	% Malines half quarters from Starmer (1910, p. 97)
	malinesi   = \relative { r16 f'''[e d] c[b a g] f[c a f] c[a f8] }
	malinesii  = \relative { r8 a16[c] f[a c f] g[a b c] d[e f8] }
	malinesiii = \relative { \time 4/16 f''16[d a' f] | \time 16/16 d'[a f d] b'[g e cis] d[a f a] \clef "bass" d,8[d,] }
	malinesiv  = \relative { \time 4/16 r16 d''[f a]  | \time 16/16 d[a b g] a[f g e] f[d e cis] d8[\clef "bass" d,,] }
      ),
      'study2' => {
	'q1' => '\excerptfromstart',
	'q2' => '\excerptfrommiddle r2',
	'q3' => '\excerptfromend',
	'q0' => '\nationalanthem r1',
	'h' => '\x <>-\fff \repeat volta %I { \S }',
	# "continental" additions
	'halb' => q(\x <>-\f \repeat volta %I { \transpose c c' { \S } }),
	'e1' => q(\x \malinesi),
	'e3' => q(\x \malinesii),
	'e5' => q(\x \malinesiii),
	'e7' => q(\x \malinesiv),
      },
      'study3' => {
	'q1' => '\excerptfromstart',
	'q2' => '\royalanthem r2',
	'q3' => '\excerptfromend',
	'q0' => '\nationalanthem r1',
	'h' => '\x <>-\fff \repeat volta %I { \S }',
	# "continental" additions
	'halb' => q(\x <>-\f \repeat volta %I { \transpose c c' { \S } }),
	'e1' => q(\x \malinesi),
	'e3' => q(\x \malinesii),
	'e5' => q(\x \malinesiii),
	'e7' => q(\x \malinesiv),
      },
    ),
);
  log_info sprintf "%.2f s was spent interpreting scores for chime melodies", eval { no integer; Time::HiRes::time - $t0};
}


sub start_of_day ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  return mktime(0, 0, 0, $mday, $mon, $year);
}

sub yesterday ($) {
  my($t) = @_;
  return start_of_day(start_of_day($t) - 12*3600);
}

sub tomorrow ($) {
  my($t) = @_;
  return start_of_day(start_of_day($t) + 36*3600);
}

sub estimate_sunrise ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->start;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[0];
    $it = $tmp->strftime('%s');
  } else {
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunrise;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub estimate_sunset ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->end;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[1];
    $it = $tmp->strftime('%s');
  } else {
    # this should be the same as the else case in estimate_sunrise except the last line
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunset;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub trim ($) {
  my($s) = @_;
  $s =~ s/^\s+//;
  $s =~ s/\s+$//;
  return $s;
}

sub guess_city () {
  my $input = '/etc/localtime';
  my $det = readlink $input;
  die "$input: $!\n" unless defined $det;
  return $1 if $det =~ /([^\/]+)$/s;
}

sub guess_coordinates () {
  my $it;
  my $city = guess_city;
  log_comment "guessed city=($city)" if $debug;
  my @cmd = qw(hebcal cities);
  log_command @cmd if $debug;
  my $pid = open(INPUT, '-|');
  die "$0: guess_coordinates: $cmd[0]: fork: $!\n" unless defined $pid;
  if ($pid) {
    my $re = quotemeta $city;
    for (;;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp;
      if ($s =~ /^$re \((\d+)d(\d+)' ([NS]) lat, (\d+)d(\d+)' ([EW]) long/) {
	no integer;
	$it = {
	      'lat' => ($1 + $2/60)*($3 eq 'N'? 1: -1),
	      'lon' => ($4 + $5/60)*($6 eq 'E'? 1: -1),
	    };
      }
    last if defined $it;
    }
    close INPUT;
  } else {
    exec {$cmd[0]} @cmd;
    die "$0: guess_coordinates: $cmd[0]: exec: $!\n";
  }
  return $it;
}

# NOTE: modified to act like the current PHP version (root section goes to /, duplicate keys allowed and get stashed into an array)
sub read_ini ($) {
  my($input) = @_;
  my $it;
  local(*INPUT, $.);
  if (open(INPUT, '<:utf8', $input)) {
    for (my $section = '/';;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp $s;
      if ($s =~ /^\s*(?:[#\%;]|$)/) {
	;
      } elsif ($s =~ /^\s*\[\s*([^\[\]]+?)\s*\]\s*$/) {
	$section = $1;
      } elsif ($s =~ /^\s*([^=]+?)\s*=\s*(.*)/) {
	if (defined $section) {
	  $it->{$section}->{$1} = [] unless defined $it->{$section}->{$1};
	  push @{$it->{$section}->{$1}}, $2;
	} else {
	  $it->{$1} = [] unless defined $it->{$1};
	  push @{$it->{$1}}, $2;
	}
      } else {
	warn "$input:$.: Warning: Unknown input \"$s\"\n";
      }
    }
    close INPUT;
  }
  return $it;
}

use vars qw( $deciday_1_re $deciday_2_re $deciday_3_re $deciday_4_re $deciday_5_re );
use vars qw( $deciday_6_re $deciday_7_re $deciday_8_re $deciday_9_re $deciday_10_re );
use vars qw( $clocktime_re $deciday_re );
$clocktime_re = '(?:(?:0?\d|1\d|2[0-3]):[0-5]\d|24:00)';
$deciday_1_re = '\b(?:morning|ˈ?dziu)\b';
$deciday_2_re = '\b(?:forenoon|ˌ?jy)\b';
$deciday_3_re = '\b(?:midday|ˈ?dzuŋ)\b';
$deciday_4_re = '\b(?:afternoon|ˈbou)\b';
$deciday_5_re = '\b(?:evening|ˍdzik)\b';
$deciday_6_re = '\b(?:A|ˉ?gap)\b';
$deciday_7_re = '\b(?:B|ˍ?jyt)\b';
$deciday_8_re = '\b(?:C|ˊ?biŋ)\b';
$deciday_9_re = '\b(?:D|ˈ?diŋ)\b';
$deciday_10_re = '\b(?:E|ˍ?mou)\b';
$deciday_re = "(?:$deciday_1_re|$deciday_2_re|$deciday_3_re|$deciday_4_re|$deciday_5_re|$deciday_6_re|$deciday_7_re|$deciday_8_re|$deciday_9_re|$deciday_10_re)";

use vars qw( $sun_re $mon_re $tue_re $wed_re $thu_re $fri_re $sat_re $dow_re $dow_range_re );
$sun_re = '(?:\b(?:U|Sun(?:day)?)\b)';
$mon_re = '(?:\b(?:M|Mon(?:day)?)\b)';
$tue_re = '(?:\b(?:T|Tue(?:s(?:day)?)?)\b)';
$wed_re = '(?:\b(?:W|Wed(?:nes(?:day)?)?)\b)';
$thu_re = '(?:\b(?:R|Thu(?:r(?:s(?:day)?)?)?)\b)';
$fri_re = '(?:\b(?:F|Fri(?:day)?)\b)';
$sat_re = '(?:\b(?:S|Sat(?:urday)?)\b)';
$dow_re = "(?:$sun_re|$mon_re|$tue_re|$wed_re|$thu_re|$fri_re|$sat_re)";
$dow_range_re = "(?:[UMTWRFS]+|(?:$dow_re(?:\\s*[-,]\\s*$dow_re)*))";

sub parse_dow ($) {
  my($s) = @_;
  local($`, $&, $');
  return $s =~ /^$sun_re$/? 0:
	 $s =~ /^$mon_re$/? 1:
	 $s =~ /^$tue_re$/? 2:
	 $s =~ /^$wed_re$/? 3:
	 $s =~ /^$thu_re$/? 4:
	 $s =~ /^$fri_re$/? 5:
	 $s =~ /^$sat_re$/? 6: undef;
}


sub parse_clocktime ($) {
  my($s) = @_;
  local($`, $&, $', $1, $2);
  no integer;
  return $s =~ /^(?=$clocktime_re$)(\d+):(\d\d)/? $1 + $2/60: undef;
}

sub parse_named_deciday ($) {
  my($s) = @_;
  local($`, $&, $', $1, $2);
  no integer;
  return $s =~ /^$deciday_1_re$/? 1:
	 $s =~ /^$deciday_2_re$/? 2:
	 $s =~ /^$deciday_3_re$/? 3:
	 $s =~ /^$deciday_4_re$/? 4:
	 $s =~ /^$deciday_5_re$/? 5:
	 $s =~ /^$deciday_6_re$/? 6:
	 $s =~ /^$deciday_7_re$/? 7:
	 $s =~ /^$deciday_8_re$/? 8:
	 $s =~ /^$deciday_9_re$/? 9:
	 $s =~ /^$deciday_10_re$/? 10: undef
}

sub parse_dow_range ($) {
  my($s) = @_;
  my $it;
  if (defined $s) {
    local($`, $&, $', $1, $2);
    if ($s =~ /^[UMTWRFS]+$/) { # Waterloo style single-letter codes
      $it = join(',', map { parse_dow($_) } split(//, $s));
    } else {
      $it = join('', map { substr($_, 0, 1) =~ /[-,]/? (substr($_, 0, 1) . parse_dow(substr($_, 1))): parse_dow($_) } split(/(?=[-,]|$)/, $s));
      $it = 'ERROR' unless $it =~ /^\d+(?:[-,]\d+)*$/;

      # Handle looparounds like Fri-Sun or Sat-Tue
      $it =~ s/\b([1-6])-([1-6])\b/ $1 < $2? $&: "$1-6,0-$2" /ge;
      $it =~ s/\b(?<!-)([1-5])-0\b/\1-6,0/g;
      $it =~ s/\b(?<!-)(6)-0\b/\1,0/g;
    }
  }
  return $it;
}

sub parse_clocktime_range ($) {
  my($s) = @_;
  my $it;
  if (defined $s) {
    local($`, $&, $', $1, $2);
    $it = join('', map { substr($_, 0, 1) =~ /[-,]/? (substr($_, 0, 1) . parse_clocktime(substr($_, 1))): parse_clocktime($_) } split(/(?=[-,]|$)/, $s));
    $it = 'ERROR' unless $it =~ /^\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*$/;

    # Handle looparounds like 23:00-07:00
    no integer;
    $it =~ s/\b(\d+(?:.\d+)?)-(0)\b/ $1 < $2? $&: "$1-24" /ge;
    $it =~ s/\b(\d+(?:.\d+)?)-(\d+(?:.\d+)?)\b/ $1 < $2? $&: "$1-24,0-$2" /ge;
  }
  return $it;
}

sub parse_named_deciday_range ($) {
  my($s) = @_;
  my $it;
  if (defined $s) {
    local($`, $&, $', $1, $2);
    $it = join('', map { substr($_, 0, 1) =~ /[-,]/? (substr($_, 0, 1) . parse_named_deciday(substr($_, 1))): parse_named_deciday($_) } split(/(?=[-,]|$)/, $s));
    $it = 'ERROR' unless $it =~ /^\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*$/;

    # Handle looparounds like C-morning
    no integer;
    $it =~ s/\b(\d+)-(1)\b/ $1 < $2? $&: "$1-10,1" /ge;
    $it =~ s/\b(\d+)-(\d+)\b/ $1 < $2? $&: "$1-10,1-$2" /ge;
  }
  return $it;
}


# Quarters are weird. See https://zh.wikipedia.org/wiki/%E5%88%BB
#                     and http://yywz.snnu.edu.cn/show.aspx?id=697&cid=26
# Apparently the old Chinese system also used proportional hours... so we'll need to refactor things here at some point
# http://www.twword.com/wiki/%E5%B9%B2%E6%94%AF%E7%B4%80%E6%B3%95
sub determine_chinese_time ($) {
  my($t) = @_;
  my $it;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $midnight = start_of_day $t;
  my $deciday;
  my $slice; # size of proportional hour, needed to figure out when to sound the next chime
  # NOTE: according to one source (forgot which), the first hour (ˊdzi) spans [2300, 0100) but the new day still starts at 0000. Very odd :-/
  # therefore the old adjustment for [2300, 0000) has been deleted
  if (defined $coords) {
    my $today = start_of_day $t;
    my $yesterday = yesterday $t;
    my $tomorrow = tomorrow $t;
    my($daybreak, $slice_start, $slice_end, $starting_hour);
    # Proportional hour is used in a very early system (Spring and Autumn Period / Warring States),
    # but I don't even have an idea when the day starts (probably day before night) so we'll arbitrarily use sunrise as cutoff
    if ($t < estimate_sunrise($today)) {
      $daybreak = estimate_sunrise($yesterday);
      $slice_start = estimate_sunset($yesterday);
      $slice_end = estimate_sunrise($today);
      $starting_hour = 6;
    } elsif ($t < estimate_sunset($today)) {
      $daybreak = estimate_sunrise($today);
      $slice_start = $daybreak;
      $slice_end = estimate_sunset($today);
      $starting_hour = 1;
    } else {
      $daybreak = estimate_sunrise($today);
      $slice_start = estimate_sunset($today);
      $slice_end = estimate_sunrise($tomorrow);
      $starting_hour = 6;
    }
    if ($slice_start && $slice_end) {
      no integer;
      $slice = ($slice_end - $slice_start)/5;
      $deciday = $starting_hour + ($t - $slice_start)/$slice;
    }
  }
  my($greg_year, $greg_month, $greg_day) = ($year + 1900, $mon + 1, $mday);
  my $relative_chinese_hour = eval { no integer; fmod(($t - ($midnight - 3600))/7200, 12) };
  my $chinese_hour = $relative_chinese_hour + 1;
  my $quarter;
  my $centiday = eval { no integer; ($t - $midnight)/864 };
  if ($enable_qing_quarters) {
    $quarter = $min/15 + 1;
    $quarter += 4 if $hour%2 == 0;
  } else {
    # NOTE: traditionally these aren't quarters, but number of centiday marks past the beginning of the hour
    no integer;
    #
    # 0.5 hours maps exactly to 0 centidays. So to calculate the reporting origin, which is fractional.
    # Each hour is 86400/12 seconds, each centiday is 86400/100 seconds, so each hour is 100/12 centidays
    # In theory, each zero-based hour h begins exactly at ⌊h - 0.5⌋*100/12 centidays
    # However, when h ∈ [0, 0.5) this gives unexpected results because the formula will give a negative result
    # There's no easy way to fix this because reporting origins are hour-aligned, not half-hour aligned
    # (so we can't even change ⌊h - 0.5⌋ to (⌊h*2 - 1⌋%24)/2 because this breaks for h > 1.0)
    #
    my $reporting_origin = POSIX::floor(($relative_chinese_hour < 0.5? 11.5: (int($relative_chinese_hour) - 0.5)) * 100 / 12);
    log_debug "relative_chinese_hour=$relative_chinese_hour => reporting_origin=$reporting_origin" if $debug;
    $quarter = $centiday - int($reporting_origin);
  }
  $it = [undef, undef, undef, undef, $chinese_hour, $quarter, $centiday, $deciday,
      $wday, eval { no integer; $relative_chinese_hour < 0.5 }, $slice];
  return $it;
}

sub parse_chime_id ($) {
  my($id) = @_;
  my $it = ();
  $it->{'id'} = $1 if $id =~ s/-([^-]+)$//s || $id =~ s/^(w\d+(?:\.\d+)?)$//s; # FIXME
  die "parse_chime_id: id not found in \"$id\"" unless defined $it->{'id'};
  if ($id =~ /^([^-]+)-(.*)$/) {
    $it->{'mode'} = $1;
    $it->{'melody'} = $2;
  } elsif ($id =~ /\S/s) {
    $it->{'mode'} = $id;
  }
  return $it;
}

sub enumerate_event_types () {
  my %it;
  for my $id (keys %chime) {
    my $det = parse_chime_id $id;
    $it{$det->{'id'}} = 1;
  }
  return sort { Debug::lazy_sorter($a, $b) } keys %it;
}

sub enumerate_defined_events () {
  my @it;
  for my $event (enumerate_event_types) {
    my $id = determine_chime_id_for_event($event);
    push @it, $event if defined $id;
  }
  return @it;
}

sub determine_chime_id_for_event ($) {
  my($event) = @_;
  my $it;
  for (;;) {
    my $id1 = event_id($mode, $event, $melody);
    my $id2 = event_id($mode, $event);
    my $id3 = event_id(undef, $event);
    $it = defined $chime{$id1}? $id1: defined $chime{$id2}? $id2: defined $chime{$id3}? $id3: undef;
  last if defined $it;
    my $last_tried = $event;
    if ($event =~ /\./s) {
      $event =~ s/\.[^\.]+$//; # chop off subevent and try again
    } elsif ($event =~ /\d+$/s) {
      $event =~ s/\d+$//s;		# chop off number and try again
    }
  last unless $event ne $last_tried;	# nothing else to try
  }
  log_debug sprintf "event %s has definition keyed to %s", $event, Debug::cvs($it) if $debug > 1;
  return $it;
}

sub determine_chime_duration ($$) {
  my($id, $default) = @_;
  my $it = $default;
  my $tune = $chime{$id};
  if (defined $tune) {
    $it = 0;
    for my $voice (@{$interpretation{$tune}}) {
      my $voice_duration = 0;
      for my $note (@$voice) {
	no integer;
	log_debug sprintf '%s %s', $note->[0], $note->[1] if $debug > 1;
	$voice_duration += $note->[1];
      }
      $it = $voice_duration if $voice_duration > $it;
    }
    log_debug "duration for chime $id is $it" if $debug;
  } elsif (defined $id) {
    $it = 0 if $method eq METHOD__SYNTH;
    log_debug "no chime defined for chime $id, using $it" if $debug;
  } else {
    log_debug "determine_chime_duration called, but no id was specified" if $debug;
  }
  return $it;
}

sub determine_event_duration ($$) {
  my($event, $default) = @_;
  my $id = determine_chime_id_for_event $event;
  my $it;
  if (defined $id) {
    $it = determine_chime_duration($id, $default) if defined $id;
    log_debug "event duration for event $event is $it" if $debug;
  } else {
    log_debug "event duration for event $event is undefined" if $debug;
  }
  return $it;
}

sub determine_next_uncached_event (@) {
  my @event = @_;
  my $it;
  for my $event (@event) {
    my $event_id = $event->{'id'};
    my $det = get_cache_pathname_for_event($event_id);
    $it = $event_id if defined $det && !-f $det;
  last if defined $it;
  }
  return $it;
}

sub determine_latency_key_from_event_id ($) {
  my($event_id) = @_;
  # We used to use $event_id as-is, but it's probably more reasonable to somewhat group them
  my $it;
  if ($event_id =~ /^w\d/s) {			# night watches are a separate category because they just randomly happen
    $it = 'w';
  } elsif ($event_id =~ /^(?:h|halb)\d/s) {	# hourly/half-hourly melodies that most likely are preceded by a quarter chime
    $it = 'h';
  } elsif ($event_id =~ /^posth/s) {		# melodies after the hourly strikes
    $it = 'posth';
  } else {					# everything else get massed into one single category
    $it = '*';
  }
  return $it;
}

sub determine_next_event_with_unknown_latency (@) {
  my @event = @_;
  my $it;
  for my $event (@event) {
    my $event_id = $event->{'id'};
    my $latency_key = determine_latency_key_from_event_id $event_id;
    $it = $event_id if !defined $expected_latency{$latency_key};
  last if defined $it;
    $it = $event_id if !$expected_latency{$latency_key}->has_usable_measurements_p();
  last if defined $it;
  }
  return $it;
}

sub determine_events ($$$$$$$$$) {
  my($t0, $hour, $min, $sec, $chinese_hour, $quarter, $centiday, $deciday, $deciday_size) = @_;
  my @it;
  no integer;
  my $global_delay = $config->{'/'}->{'delay'}->[0] + 0 if defined $config->{'/'}->{'delay'};
  $global_delay = 0 unless defined $global_delay;

  # Western quarter-hour chime
  # Make absolutely sure we have a chime event, in case it gets thrown out because we're too close to the actual next quarter hour
  # Actually, make absolutely sure we have four quarter-hour chime events because we are now throwing nonexistent events out
  # and all quarter-hour chimes can get thrown out (e.g., sysline doesn't use q1 and q3, cuckoo mode doesn't use any of q1..q4)
  # so we need to make sure the entire next hour is covered
  my $seconds_since_hour_change = 60*$min + $sec;
  my $t_next_half_quarter_chime = int($t0) + (450 - $seconds_since_hour_change%450) + $global_delay;
  my $next_half_quarter = (int($seconds_since_hour_change / 450) + 1)%8;
  my $next_hour = (($next_half_quarter? $hour: $hour + 1) + 11)%12 + 1;
  my $half_quarter_chime_events_pushed = 0;
  my $quarter_chime_events_pushed = 0;
  for (my $i = 0;; $i += 1,
			  $t_next_half_quarter_chime += 450,
			  $next_half_quarter = ($next_half_quarter + 1)%8,
			  $next_hour += !$next_half_quarter, $next_hour = ($next_hour - 1)%12 + 1) {
    my $prechime_length;
    if ($next_half_quarter%4 == 0) {
      my $id = sprintf('%s%d', $next_half_quarter == 0? ('h', $next_hour): ('halb', $next_hour%12 + 1));
      push @it, {
	't' => $t_next_half_quarter_chime,
	'id' => $id,
	'type' => 'hour',
	'comment' => ($next_half_quarter == 0? "$next_hour o'clock chime": "half past $next_hour chime (continental)"),
      };
      # Some clock do the melody after the hour/half-hour strikes - push that as posth/posthalb
      my $chime_length = determine_event_duration($id, undef);
      if (defined $chime_length) {
	push @it, {
	  't' => $t_next_half_quarter_chime + $chime_length,
	  'id' => "post$id",
	  'type' => 'post-quarter',
	  'comment' => ($it[$#it]->{'comment'} =~ s/(?=\bchime\b)/post/sr),
	};
      }
    }
    if ($next_half_quarter == 0) {
      $prechime_length = determine_event_duration('q0', 25);
    } elsif ($next_half_quarter == 1) {
      $prechime_length = determine_event_duration('e1', 5);
    } elsif ($next_half_quarter == 2) {
      $prechime_length = determine_event_duration('q1', 5);
    } elsif ($next_half_quarter == 3) {
      $prechime_length = determine_event_duration('e3', 5);
    } elsif ($next_half_quarter == 4) {
      $prechime_length = determine_event_duration('q2', 10);
    } elsif ($next_half_quarter == 5) {
      $prechime_length = determine_event_duration('e5', 5);
    } elsif ($next_half_quarter == 6) {
      $prechime_length = determine_event_duration('q3', 15);
    } elsif ($next_half_quarter == 7) {
      $prechime_length = determine_event_duration('e7', 5);
    }
    if ($t_next_half_quarter_chime - $prechime_length >= $t0) {
      if ($next_half_quarter % 2 == 0) {
	my $next_quarter = $next_half_quarter/2;
	my $id = "q$next_quarter";
	push @it, {
	  't' => $t_next_half_quarter_chime - $prechime_length,
	  'id' => $id,
	  'type' => 'quarter',
	  'comment' => "hour $next_hour quarter $next_quarter prechime",
	  'anticipating' => $prechime_length,
	};
	$quarter_chime_events_pushed += 1;
      } else {
	push @it, {
	  't' => $t_next_half_quarter_chime - $prechime_length,
	  'id' => "e$next_half_quarter",
	  'type' => 'half quarter',
	  'comment' => "hour $next_hour half quarter $next_half_quarter prechime (continental)",
	  'anticipating' => $prechime_length,
	};
	$half_quarter_chime_events_pushed += 1;
      }
    }
  last if $quarter_chime_events_pushed > 3 && $half_quarter_chime_events_pushed > 3;
  }

  # Spring-and-Autumn-era proportional-deciday-based night watch chimes
  # 1 watch is exactly 1 deciday, which is not actually 1/10 of a day but 1/5 of the current proportional moitie
  if ($deciday > 5 && $deciday < 6) { # 5 is the last deciday in the "day" moitie
    my $t_first_watch = $t0 + (6 - $deciday)*$deciday_size;
    push @it, {
      't' => $t_first_watch,
      'id' => 'w1.1',
      'type' => 'watch',
      'comment' => 'watch 1',
    };
  } elsif ($deciday >= 6) {
    my $decidays_into_the_night = $deciday - 6;
    my $subwatches_into_the_night = 5*$decidays_into_the_night;
    my $zero_based_next_subwatch = (int($subwatches_into_the_night) + 1)%25;
    if ($zero_based_next_subwatch) {
      my $next_watch = int($zero_based_next_subwatch/5) + 1;
      my $next_subwatch = $zero_based_next_subwatch%5 + 1;
      my $t_next_subwatch = $t0 + (1 - fmod($subwatches_into_the_night, 1)) * ($deciday_size/5) + $global_delay;
      my $id = "w$next_watch.$next_subwatch";
      push @it, {
	't' => $t_next_subwatch,
	'id' => $id,
	'type' => 'watch',
	'comment' => "watch $next_watch.$next_subwatch",
      };
    }
  }

  @it = sort { $a->{'t'} <=> $b->{'t'} } @it;
  return wantarray? @it: \@it;
}

sub in_range ($$) {
  my($n, $range_spec) = @_;
  my $it = 0;
  no integer;
  for my $subrange_spec (split(/\s*,\s*/, $range_spec)) {
    die "in_range: Malformed element \"$subrange_spec\" in \"$range_spec\"" unless $subrange_spec =~ /^(\d+(?:\.\d+)?)(?:-(\d+(?:\.\d+)?))?$/;
    if (defined $2) {
      $it = $1 <= $n && $n <= $2;
    } else {
      $it = $1 == $n;
    }
  last if $it;
  }
  return $it;
}

sub in_semi_closed_range ($$) {
  my($n, $range_spec) = @_;
  my $it = 0;
  no integer;
  for my $subrange_spec (split(/\s*,\s*/, $range_spec)) {
    die "in_range: Malformed element \"$subrange_spec\" in \"$range_spec\"" unless $subrange_spec =~ /^(\d+(?:\.\d+)?)(?:-(\d+(?:\.\d+)?))?$/;
    if (defined $2) {
      $it = $1 <= $n && $n < $2;
    } else {
      $it = $1 == $n;
    }
  last if $it;
  }
  return $it;
}

sub get_sink () {
  return $ENV{'PULSE_SINK'};
}

sub set_sink ($) {
  my($sink) = @_;
  $ENV{'PULSE_SINK'} = $sink if defined $sink;
}

sub set_test_params () {
  @sinks = @{$config->{'test'}->{'sink'}} if defined $config->{'test'}->{'sink'};
  $mode = $config->{'test'}->{'mode'}->[0] if defined $config->{'test'}->{'mode'};
  $method = $config->{'test'}->{'method'}->[0] if defined $config->{'test'}->{'method'};
  $melody = lc $config->{'test'}->{'melody'}->[0] if defined $config->{'test'}->{'melody'};
  $datadir = $config->{'test'}->{'datadir'} if defined $config->{'test'}->{'datadir'};
  log_debug sprintf "test params set at %.2f: mode=%s, method=%s, melody=%s", $boottime, $mode, $method, $melody if $verbose_p || $debug;
}

sub set_sink_volume ($$) {
  my($sink, $volume) = @_;
  my @cmd = ('pactl', 'set-sink-volume', $sink, int($volume));
  log_command @cmd if $debug;
  system { $cmd[0] } @cmd;
}

sub interpret_time_parametrized_config_value ($$$$$$$$$) {
  my($thing_label, $thing_re, $thing_valid, $directive, $hour, $min, $sec, $deciday, $wday) = @_;
  my($target_dow, $target_times, $target_volume, $dow_in_range_p, $time_in_range_p);
  my($result, $error);
  die "interpret_time_parametrized_config_value : $thing_re: Unsupported regexp" if $thing_re =~ /(?<!\\)\x28(?!\?)/s;
  no integer;
  my $hours_past_midnight = $hour + $min/60 + $sec/3600;
  if ($directive =~ /^(?:($dow_range_re)\s+)?hours?\s+(\d+(?:[-,]\d+)*)\s*[:=]\s*($thing_re)$/) {		# integer to integer
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range($hour, $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?hours?\s+(\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*)\s*[:=]\s*($thing_re)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range($hours_past_midnight, $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?decidays?\s+(\d+(?:[-,]\d+)*)\s*[:=]\s*($thing_re)$/) {	# integer to integer
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range(int($deciday), $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?decidays?\s+(\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*)\s*[:=]\s*($thing_re)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range($deciday, $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?($clocktime_re-$clocktime_re)\s*[:=]\s*($thing_re)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_semi_closed_range($hours_past_midnight, parse_clocktime_range $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?($deciday_re(?:\s*-\s*$deciday_re)?)\s*[:=]\s*($thing_re)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range(int($deciday), parse_named_deciday_range $target_times);
  } elsif ($directive =~ /^$thing_re$/) {	# just the thing
    ($target_dow, $time_in_range_p, $target_volume) = (undef, 1, $directive);
  } else {
    $error = "unrecognized directive \"$directive\"";
  }
  $dow_in_range_p = !defined $target_dow || in_range($wday, parse_dow_range($target_dow)) if !defined $error;
  if (defined $error || !$dow_in_range_p || !defined $time_in_range_p || !$time_in_range_p) {
    ;
  } elsif (!defined $thing_valid || &$thing_valid($target_volume)) {
    $result = $target_volume;
  } else {
    $error = "out of range $thing_label $target_volume";
  }
  return wantarray? ($result, $error): [$result, $error];
}

sub get_time_parametrized_config ($$$$$$$$$;$) {
  my($section, $key, $thing_re, $thing_valid, $hour, $min, $sec, $deciday, $wday, $thing_label) = @_;
  my($adj, $error, $reason);
  $thing_label = $key unless defined $thing_label;
  for my $directive (map { split /\s*;\s*/ } @{$config->{$section}->{$key}}) {
    log_debug "considering directive: $directive" if $debug > 1;
    (my $candidate_adj, $error) = interpret_time_parametrized_config_value($thing_label, $thing_re, $thing_valid, $directive, $hour, $min, $sec, $deciday, $wday);
    ($adj, $reason) = ($candidate_adj, "because of $thing_label rule \"$directive\"") if defined $candidate_adj;
    log_error "CONFIG ERROR: $error in [$section] $key" if defined $error;
  last if defined $adj;
  }
  return wantarray? ($adj, $error, $reason): [$adj, $error, $reason];
}

sub set_sink_volumes ($$$$$) {
  my($hour, $min, $sec, $deciday, $wday) = @_;
  for my $sink (@sinks) {
    my $label = defined $config->{$sink} && defined $config->{$sink}->{'label'}? $config->{$sink}->{'label'}->[0]: "sink $sink";
    no integer;
    my $adj;
    my $reason;
    if (defined $config->{$sink} && defined $config->{$sink}->{'volume'}) {
      ($adj, my $error, $reason) = get_time_parametrized_config($sink, 'volume', '\d+(?:\.\d+)?', sub {
	my($target_volume) = @_;
	no integer;
	$target_volume >= 0 && $target_volume <= 1;
      }, $hour, $min, $sec, $deciday, $wday);
      $adj = 1.0 unless defined $adj;
    } else {
      # Default adjustment for "night"
      $adj = 1.0;
      $adj *= 0.9 if $deciday < 1 || $deciday > 5;
      $adj *= 0.9 if $hour < 9 || $hour > 8;
    }
    $reason = 'by default' if defined $adj && !defined $reason;
    log_info "Master volume adjusted to $adj for $label $reason" if $debug || $verbose_p;
    set_sink_volume $sink, 65535 * $adj;
  }
}

sub get_cache_pathname_for_event ($) {
  my($id) = @_;
  my $it;
  if (defined $id && $id ne 'test') {
    die "get_cache_pathname_for_event: Internal error: $mode: Illegal mode" unless $mode =~ /^[-\.\w]+$/s;
    die "get_cache_pathname_for_event: $id: Illegal event id" unless $id =~ /^[-\.\w]+$/s;
    my $basename;
    if ($id =~ /^tmp\d+$/) {
      $it = sprintf('%s/%s.oga', $datadir, $id);
    } else {
      my $chime_id = determine_chime_id_for_event $id;
      $it = sprintf('%s/cache-%s.oga', $datadir, $chime_id) if defined $chime_id;
    }
  }
  return $it;
}

sub send_midi_command ($) {
  my($cmd) = @_;
  log_output $cmd if $debug || $verbose_p;
  if (defined $synth) {
    $synth->send($cmd);
    $synth->{'.last-note'} = current_time if $cmd =~ /\bnoteon\b/; # XXX
  } else { # cached synth output disappeared
    log_error "trying to send midi command while synth is not connected";
  }
}

sub probe_synth_instruments () {
  send_midi_command('inst 1');
  my @instruments = $synth->before;
  my %instruments = map { /^(\d+)-(\d+)\s+(.*)$/s? ($3 => [$1 + 0, $2 + 0], "$1-$2" => $3): () } split(/\r?\n/, $synth->before);
  return wantarray? %instruments: \%instruments;
}

sub find_synth_instrument ($@) {
  my($instruments, @preferences) = @_;
  my $it;
  for my $candidate (@preferences) {
    $it = $instruments->{$candidate} if defined $instruments->{$candidate};
    $it = $instruments->{$it} if defined $it && !ref $it && defined $instruments->{$it};
  last if defined $it;
  }
  return $it;
}

sub synth_instrument_name ($$) {
  my($instruments, $instrument) = @_;
  my $id = sprintf('%03d-%03d', $instrument->[0], $instrument->[1]);
  return $instruments->{$id};
}

sub connect_synth ($) {
  my($id) = @_;
  my $output = get_cache_pathname_for_event($id);
  my($sf_path, $gain);
  my $immediate_p = $id eq 'test';
  if (!defined $synth && ($immediate_p || defined $output)) { # if we're connected don't try to create a second instance, it was disastrous

    # Figure out where our soundfont is
    for my $key ('Timbres Of Heaven', 'FluidR3') {
      if (defined $config->{'/'}->{$key}) {
	foreach my $candidate (@{$config->{'/'}->{$key}}) {
	  $sf_path = $candidate if -f $candidate;
	last if defined $sf_path;
	}
      }
      if (defined $sf_path && $key eq 'Timbres Of Heaven') {
	$gain = 0.2; # default gain
      }
    last if defined $sf_path;
    }
    $sf_path = $fluidR3 if !defined $sf_path; # hmm hope this works
    $gain = 1 if !defined $gain;

    log_comment sprintf('Connecting synth %s', $immediate_p? (@sinks? "to $sinks[0]": ''): "for write to $output") if $debug || $verbose_p;
    set_sink $sinks[0] if $immediate_p && @sinks;
    my @cmd = ('fluidsynth', '-g', $gain,
			     '--midi-channels', '7',
			     ($immediate_p?
				('-a', 'pulseaudio'):
				('-a', 'file',
				 '-o', "audio.file.name=$output")),
			     $sf_path);

    log_command @cmd if $debug;
    $synth = new Expect::Simple({
	'Cmd' => \@cmd,
	'Prompt' => "\n> ",
	'DisconnectCmd' => 'quit',
      });

    # Figure out what instruments to use
    my $instruments = probe_synth_instruments;
    my $gong = find_synth_instrument($instruments, 'Gong!!!', 'Tubular Bells');
    # XXX Chimes from Sonatina seems to sound nicer than Carillon, but Sonatina doesn't have standard percussion so we can't really use it
    my $bell = find_synth_instrument($instruments, 'Chimes', 'Carillon', 'Tubular Bells');
    my $wood = find_synth_instrument($instruments, 'Woodblock'); # 000-115
    my $perc = find_synth_instrument($instruments, 'Jazz Drum Kit', 'Jazz', 'Orchestra Kit');
    my $beep = find_synth_instrument($instruments, 'Sine Wave', '1 kHz Test', '000-008'); # fallback to any celesta
    my $mbox = find_synth_instrument($instruments, 'Music Box', '000-010');	# XXX this doesn't sound right
    my $clav = find_synth_instrument($instruments, '000-019');	# church organ
    #my $clav = find_synth_instrument($instruments, '000-000');	# piano
    ($gong_bank, $gong_inst) = @$gong;
    ($bell_bank, $bell_inst) = @$bell;
    ($wood_bank, $wood_inst) = @$wood;
    ($perc_bank, $perc_inst) = @$perc;
    ($beep_bank, $beep_inst) = @$beep;
    my($mbox_bank, $mbox_inst) = @$mbox;
    my($clav_bank, $clav_inst) = @$clav;
    $wood_note = (synth_instrument_name($instruments, $wood) =~ / Kit\b/ || $wood_bank == 128)? 31: $note_to_midi_number{'d#5'};
    send_midi_command "select 0 1 $gong_bank $gong_inst";
    send_midi_command "select 1 1 $bell_bank $bell_inst";
    send_midi_command "select 2 1 $wood_bank $wood_inst";
    send_midi_command "select 3 1 $perc_bank $perc_inst";
    send_midi_command "select 4 1 $beep_bank $beep_inst";
    send_midi_command "select 5 1 $mbox_bank $mbox_inst";
    send_midi_command "select 6 1 $clav_bank $clav_inst";
    $instrument_name_to_channel_number{'Gong'} = 0;
    $instrument_name_to_channel_number{'Carillon'} = 1;
    $instrument_name_to_channel_number{'Woodblock'} = 2;
    $instrument_name_to_channel_number{'Sine Wave'} = 4;
    $instrument_name_to_channel_number{'Music Box'} = 5;
    $instrument_name_to_channel_number{'Keyboard'} = 6;

    # Set reverb, based on advice from
    # - mrbumpy409. (2012, December 19). The fluidsynth reverb, while not as good as the old Live!/Audigy hardware reverbs (which were 
    #   quite good), can still sound decent [Reply to forum post]. Retrieved from https://forums.scummvm.org/viewtopic.php?t=11632
    send_midi_command "rev_setroomsize 0.61";
    send_midi_command "rev_setdamp 0.23";
    send_midi_command "rev_setwidth 0.76";
    send_midi_command "rev_setlevel 0.57";
    send_midi_command "cho_set_nr 3";
    send_midi_command "cho_set_level 1.2";
    send_midi_command "cho_set_speed 0.3";
    send_midi_command "cho_set_depth 8";
    send_midi_command "reverb on";
    send_midi_command "chorus on";
  }
  return;
}

sub disconnect_synth () {
  if (defined $synth) {
    sleep SECONDS_BEFORE_DISCONNECT if defined $synth && defined $synth->{'.last-note'}; # wait a bit for things to stabilize if we sent anything
    $synth = undef;
    log_debug 'synth disconnected' if $debug;
  }
}
END { disconnect_synth }

sub generate_sound_clip_for_event ($) {
  my($event_id) = @_;
  my $dummy_id = "tmp$$";
  my $temp = get_cache_pathname_for_event($dummy_id);
  my $output = get_cache_pathname_for_event($event_id);
  log_debug sprintf "Event %s has cache pathname %s, using temp file %s", $event_id, $output, $temp if $debug;
  if (!-f $output) {
    log_info "Generating audio for event $event_id";
    local @sinks;
    connect_synth $dummy_id;
    my %leftovers = strike_tune_real(1, @{$interpretation{$chime{+determine_chime_id_for_event($event_id)}}});
    disconnect_synth;
    my $ok = 0;
    if (!%leftovers) {
      $ok = rename $temp, $output;
      log_error "$output: $!" unless $ok;
    } else {										# see ffmpeg.md for comments
      my @cmd = ('ffmpeg', '-nostdin', '-hide_banner', '-y');				# global options
      push @cmd, ('-loglevel', 0) unless $debug;
      push @cmd, map { ('-i', $_) } ($temp, @{$leftovers{'files'}});			# input files
      push @cmd, ('-filter_complex', $leftovers{'filter-graph'});
      push @cmd, $output;								# output files
      log_command @cmd if $debug;
      local $SIG{'CHLD'} = 'DEFAULT'; # need this to check exit status
      my $st = system { $cmd[0] } @cmd;
      $ok = !$st;
      log_error "$output: $cmd[0] returned status $st" if !$ok;
    }
    log_info "Audio for event $event_id generated" if $ok;
    unlink $temp if -f $temp;
  }
}

sub generate_sound_clips () {
  log_debug "Generating audio files" if $debug;
  disconnect_synth;
  for my $event_id (enumerate_defined_events) {
    generate_sound_clip_for_event $event_id;
  }
}

sub latency_measurable_p () {
  return @sinks < 2;
}

sub play_sound_file_real ($;$$$) {
  my($input, $volume, $start, $end) = @_;
  my $sink = get_sink;
  state $exts = ['wav', 'mp3', 'ogg', 'oga', 'flac'];
  state $ext_re = sprintf('(?:%s)', join('|', @$exts));
  no integer;

  # Find a playable file
  for my $ext (@$exts) {
  last if -f $input;
    $input = "$1.ext" if !-f $input && $input =~ /^(.*?)\.$ext_re$/ && -f "$1.ext";
  }

  # Fork and play it in the background
  my $user_agent = 'Chiming clock';
  my $close_stdin_p = 1;
  my $use_paplay_p = 0;
  my $measure_latency_p = latency_measurable_p;
  my $latency;
  my $expected_output;
  my $t0 = Time::HiRes::time;
  my @cmd;
  if ($use_paplay_p && $volume == 100 && !defined $start && !defined $end && $input =~ /\.(?:oga|wav)$/s) {
    @cmd = ('paplay', '-n', $user_agent);
    push @cmd, ('-v') if $measure_latency_p;
    push @cmd, ('-d', $sink) if $sink;
    #push @cmd, ('--volume', 65536*$volume / 100) if $volume != 100;
    $expected_output = 'Stream started.';
    $close_stdin_p = 0; # otherwise paplay craps out
  } else {
    # Ubuntu's mpv accepts --input-terminal no but the Pi only accepts --input-terminal=no (otherwise it thinks "no" is an input file)
    @cmd = ('mpv', '--audio-client-name', $user_agent, '--no-video', '--input-terminal=no', '--volume', int($volume));
    push @cmd, ($measure_latency_p? '--quiet': '--really-quiet');
    push @cmd, ('--start', $start) if defined $start;
    push @cmd, ('--end', $end) if defined $end;

    # Ubuntu's mpv accepts --ao=pulse::$sink but the Pi says ao doesn't accept sub-options
    # The Pi's mpv is newer so why this happens is a mystery
    push @cmd, ("--ao=pulse") if $sink;
    set_sink $sink;
    $expected_output = 'Playing: ';
  }
  push @cmd, $input;
  log_command @cmd if $verbose_p || $debug;
  my $fh = gensym;
  no strict 'refs';
  my $h = $measure_latency_p? open($fh, '-|'): fork;
  use strict;
  die "$cmd[0]: fork: $!\n" unless defined $h;
  if ($h == 0) {
    my $sink = get_sink;
    my $dt = $config->{$sink}->{'delay'}->[0] + 0 if defined $config->{$sink} && defined $config->{$sink}->{'delay'};
    log_debug sprintf "delay %s (interpreted as %f) for %s", $config->{$sink}->{'delay'}->[0], $dt, $sink if $debug || ($verbose_p && $dt);
    Time::HiRes::sleep $dt if defined $dt && $dt > 0;
    POSIX::close(0) if $close_stdin_p;
    exec { $cmd[0] } @cmd;
    die "$cmd[0]: exec: $!\n";
  }
  if ($measure_latency_p) {
    for (;;) {
      no strict 'refs';
      my $s = scalar <$fh>;
      use strict;
    last unless defined $s;
      if (!defined $latency && $s =~ /^$expected_output/) {
	$latency = Time::HiRes::time - $t0;
	log_debug sprintf 'Latency for %s measured at %g', $input, $latency if $debug;
      }
    last if defined $latency; # XXX must exit or we won't until we get past the 10s silence at the end; hopefully nothing more will be output
    }
  }
  $children{$h} = $fh;
  return $latency;
}

sub interpret_volume ($;$) {
  my($volume, $default) = @_;
  if (ref $volume eq 'ARRAY') {
      my($base, $hour, $min, $sec, $deciday, $wday) = @$volume;
      if (defined $wday) {
	no integer;
	my $sink = get_sink();
	my $label = defined $config->{$sink} && defined $config->{$sink}->{'label'}? $config->{$sink}->{'label'}->[0]: "sink $sink";
	my($adj, $error, $reason) = get_time_parametrized_config($sink, 'clock volume', '\d+(?:\.\d+)?', sub {
	    my($target_volume) = @_;
	    no integer;
	    $target_volume >= 0 && $target_volume <= 1;
	  }, $hour, $min, $sec, $deciday, $wday);
	$adj = 1 unless defined $adj;
	log_info "Clock volume adjusted to $adj for $label $reason" if $debug || $verbose_p;
	$volume = $base * $adj;
      }
  }
  $volume = $default if !defined $volume && defined $default;
  return $volume;
}

sub play_sound_file ($;$$$) {
  my($input, $volume, $start, $end) = @_;
  my $latency;
  if (@sinks) {
    for my $sink (@sinks) {
      log_debug "set sink $sink" if $debug;
      set_sink $sink;
      $latency = play_sound_file_real($input, interpret_volume($volume, 50), $start, $end);
    }
  } else {
    $latency = play_sound_file_real($input, interpret_volume($volume, 50), $start, $end);
  }
  return $latency;
}

sub strike_gong (;$) {
  my($note) = @_;
  if ($note ne 'r') {
    if ($method eq METHOD__SYNTH) {
      send_midi_command sprintf('noteon 0 %d %s', $note_to_midi_number{$note}, $expressive_mark_to_midi_velocity{'ffff'});
    } else {
      $note = 'a#5' if !defined $note || !defined $gong_scale{$note};
      play_sound_file sprintf('%s/%s', $datadir, $gong_scale{$note}), 50;
    }
  }
}

sub strike_bell ($) {
  my($note) = @_;
  if ($note ne 'r') {
    if ($method eq METHOD__SYNTH) {
      send_midi_command sprintf('noteon 1 %d %s', $note_to_midi_number{$note}, $expressive_mark_to_midi_velocity{'fff'});
    } else {
      $note = 'd#5' if !defined $note || !defined $chime_scale{$note};
      play_sound_file sprintf('%s/%s', $datadir, $chime_scale{$note}), 100;
    }
  }
}

sub strike_stick () {
  if ($method eq METHOD__SYNTH) {
    send_midi_command sprintf('noteon 2 %d %s', $wood_note, $expressive_mark_to_midi_velocity{'f'});
  } else {
    #play_sound_file sprintf('%s/269735__theriavirra__drumsticks-stagg-maple-sm5a-powerclick-no4a.wav', $datadir), 70;
    play_sound_file sprintf('%s/claves_ff.mp3', $datadir), 90;
  }
}

sub transpose_note ($;$) {
  my($note, $shift) = @_;
  my $it = $midi_number_to_note[$note_to_midi_number{$note} + $shift] if $note ne 'r';
  return defined $it? $it: $note;
}

sub strike_tune_real ($@) {
  my($construct_filter_graph_p, @tune) = @_;
  my %leftovers;
  my($last_volume_used, @intermediate_input_labels);
  log_debug sprintf "Flag %d, striking %s", $construct_filter_graph_p, join(" \\\\ ", map { join(' ', map { $_->[0] } @$_) } @tune) if $debug || $verbose_p;
  no integer;
  my $semitones = 8;
  my @midi_commands;
  for my $voice (@tune) {
    my $elapsed = 0;
    my $t0 = current_time;
    for my $spec (@$voice) {
      my($note, $time, $velocity, $instrument, $flags) = @$spec;
      $velocity = 127 unless defined $velocity; # NOTE backward compatibility
      my $t_i = current_time;
      my $actual_time = $flags->{'actual-duration'};
      my $note_length = $time * $beat_length;
      my $effective_note_length = defined $actual_time? $actual_time * $beat_length: $note_length;
      if (defined $flags && defined $flags->{'directive'}) {
	push @midi_commands, [$elapsed, $flags->{'directive'}, $velocity];
      } elsif (defined $percussion_note_to_midi_number{$note}) {
	push @midi_commands, [$elapsed, sprintf 'noteon 3 %d %d', $percussion_note_to_midi_number{$note}, $velocity];
      } elsif (exists $percussion_note_to_midi_number{$note}) {	# valid percussion note but no MIDI equivalent
	log_debug "percussion note $note has no MIDI equivalent";	# XXX
      } elsif (defined $note_to_midi_number{$note}) {
	my $channel = (defined $instrument_name_to_channel_number{$instrument})? $instrument_name_to_channel_number{$instrument}: 1;
	my $note_number = $note_to_midi_number{$note};
	my $laisser_vibrer_p = 1 unless $instrument =~ /^(?:Keyboard|Sine Wave)$/s || defined $actual_time; # FIXME
	push @midi_commands, [$elapsed, sprintf 'noteon %d %d %d', $channel, $note_number, $velocity];
	push @midi_commands, [$elapsed + $effective_note_length, sprintf 'noteoff %d %d', $channel, $note_number] unless $laisser_vibrer_p;
      } elsif ($note ne 'r') {
	log_debug "strike_tune: $note: \"else\" case reached";
      }
      # Instead of sleeping on the actual note length, we keep track of where we're supposed to be in relation to t0,
      # our initial time. Then calculate how much time we need to sleep to hit the next note at the expected time.
      my $dt = $t0 + $elapsed + $note_length - current_time;
      Time::HiRes::sleep $dt if $method ne METHOD__SYNTH && $dt > 0;
      $elapsed += $note_length;
    }
  }
  if (@midi_commands) { # sort batched-up MIDI commands (to take care of noteoffs) and execute them in order
    @midi_commands = sort { $a->[0] <=> $b->[0] } @midi_commands;
    map { log_debug "schedule: " . Debug::cvs($_) } @midi_commands if $debug > 1;
    my $t0 = current_time; # reset start time
    for (my $i = 0;; $i += 1) {
      my($t, $midi_command, $non_midi_extra) = @{$midi_commands[$i]};
      if (ref $midi_command) {
	my($directive, @args) = @$midi_command;
	if ($directive eq 'play') {
	  my($volume, $filename, $start, $end) = ($non_midi_extra, @args);
	  my $pathname = sprintf('%s/%s.wav', $datadir, $filename);
	  no integer;
	  if ($construct_filter_graph_p) {				# construct ffmpeg filter graph - see ffmpeg.md for comments
	    my $intermediate_input_label = gensym;
	    push @{$leftovers{'files'}}, $pathname;
	    push @intermediate_input_labels, $intermediate_input_label;
	    my @cmd;
	    push @cmd, sprintf('volume=127/%d', $last_volume_used) if defined $last_volume_used;
	    push @cmd, sprintf('volume=%d/127', $volume);
	    push @cmd, sprintf('atrim=%f:%f', $start, $end);
	    push @cmd, sprintf('adelay=%d', 1000*$t) if $t;
	    log_debug sprintf 'intermediate file %s has label %s', $pathname, $intermediate_input_label if $debug;
	    $leftovers{'filter-graph'} .= sprintf('[%d]%s[%s];', scalar @{$leftovers{'files'}}, join(',', @cmd), $intermediate_input_label);
	    $last_volume_used = $volume;
	  } else {
	    play_sound_file $pathname, 100*$volume/127, $start, $end;
	  }
	} else {
	  log_error "strike_tune: Unknown directive \"$directive\"";
	}
      } elsif ($method eq METHOD__SYNTH) {
	send_midi_command $midi_command;
      } elsif ($midi_command =~ /^noteon 3 (\d+) (\d+)/) {		# percussion
	my($instrument, $volume) = ($1, $2);
	if ($instrument == $percussion_note_to_midi_number{'cyms'}
	  || $instrument == $percussion_note_to_midi_number{'cymch'}) {
	  strike_gong;
	} else {
	  strike_stick;
	}
      } elsif ($midi_command =~ /^noteon (\d+) (\d+) (\d+)/) {		# pitched
	my($channel, $pitch, $volume) = ($1, $2, $3);
	my $note = $midi_number_to_note[$pitch];
	# The gongs have a range of [c4, g5], or [48, 67]; the Westminster chimes require a range of [b3, g#4] or [47, 56]
	# for just the melody, or [e3, g#4], or [40, 56], if we count also the strikes that count the hours
	# If we just deal with the melody, we therefore need to transpose everything up by 1 to 11 semitones
	# (and be content that the hourly strikes will sound a random note); otherwise we need to transpose it up by 8 to 11 semitones.
	# The VCSL chimes have a slightly narrower range of [c4, f5] or [48, 65] so we'll need to transpose it up by 8 to 9 semitones.
	#strike_gong transpose_note $note, $semitones;
	strike_bell transpose_note $note, $semitones;
      } else {
	log_debug "strike_tune: samples mode reached \"else\" case (midi command was \"$midi_command\")";
      }
    last if $i == $#midi_commands;
      my $dt = $midi_commands[$i + 1]->[0] - $t;
      Time::HiRes::sleep $dt if $dt > 0;
    }
  }
  if (%leftovers) {
    $leftovers{'filter-graph'} .= sprintf('[0]%samix=inputs=%d',
	join('', map { "[$_]" } @intermediate_input_labels),
	@intermediate_input_labels + 1);

    log_debug sprintf('strike_tune_real: returning leftovers=%s', Debug::cvs(\%leftovers)) if $debug;
  }
  return %leftovers;
}

sub strike_tune (@) {
  my @tune = @_;
  log_debug sprintf "Striking %s", join(" \\\\ ", map { join(' ', map { $_->[0] } @$_) } @tune) if $debug || $verbose_p;
  return strike_tune_real 0, @tune;
}

sub update_latency_for_event ($$) {
  my($id, $latency) = @_;
  if (defined $id && defined $latency) {
    my $latency_key = determine_latency_key_from_event_id $id;
    if (defined $expected_latency{$latency_key}) {
      $expected_latency{$latency_key}->remember($latency, $id);
      log_debug sprintf 'measured latency %g for event %s, state updated (currently %s)', $latency, $id, Debug::cvs($expected_latency{$latency_key});
    } else {
      $expected_latency{$latency_key} = Latency->new($latency, $id);
      $expected_latency{$latency_key}->tag($latency_key);
      log_debug sprintf 'measured latency %g for event %s, state initialized (currently %s)', $latency, $id, Debug::cvs($expected_latency{$latency_key});
    }
  }
}

sub measure_latency_for_event ($) {
  my($id) = @_;
  my $output = get_cache_pathname_for_event($id);
  my $chime_id = determine_chime_id_for_event $id;
  my $latency;
  if (defined $chime_id && $method eq METHOD__SYNTH && -f $output && !$no_cache_p) {
    $latency = play_sound_file $output, 0;
    update_latency_for_event $id, $latency;
  }
}

sub do_event ($;$$$$$) {
  my($id, $hour, $min, $sec, $deciday, $wday) = @_;
  my $output = get_cache_pathname_for_event($id);
  my $chime_id = determine_chime_id_for_event $id;
  my $latency;
  if (!defined $chime_id) {
    log_debug sprintf "Event %s does not exist for the current mode/melody", $id if $debug;
  } else {
    log_debug sprintf "Cache for event %s (%s) %s", $id, $output, (!-f $output? 'does not exist': $no_cache_p? 'exists but ignored by request': 'exists') if $debug;
    if ($method eq METHOD__SYNTH && -f $output && !$no_cache_p) {
      $latency = play_sound_file $output, (defined $wday? [100, $hour, $min, $sec, $deciday, $wday]: 100);
      update_latency_for_event $id, $latency;
    } else {
      strike_tune @{$interpretation{$chime{$chime_id}}};
    }
  }
  return $latency;
}

sub restart_script_real () {	# NOTE: this function exists only to silence the "Statement unlikely to be reached" warning
  for my $pid (keys %children) {
    log_comment "DEBUG: killing synth $pid" if $debug;
    kill 'TERM', $pid;
  }
  my @cmd = @restart_cmd;
  log_warning 'restarting: '. join(' ', @cmd) if $verbose_p || $debug;
  exec { $cmd[0] } @cmd;
}

sub restart_script () {
  restart_script_real;
  log_warning "restart failed: $!";
}

sub safe_to_restart_p () {
  my @cmd = ('perl', '-cw', $restart_cmd[0]);
  log_command @cmd if $debug;
  local $SIG{'CHLD'} = 'DEFAULT'; # need this to check exit status
  return 0 == system { $cmd[0] } @cmd;
}

sub generate_proofsheet () {
  my @events_to_check = enumerate_defined_events;
  my @events_found;
  my($title, $source, $composer, $year);
  for (my $pass = 0; $pass < 2; $pass += 1) {
    for my $event (@events_to_check) {
      my $id = determine_chime_id_for_event($event);
      if (defined $id) {
	push @events_found, $id if $pass == 0;
	if (!defined $title) {
	  my $description = $pass == 0? \%melody_description: \%mode_description;
	  if (($pass == 0? $id =~ /^carillon-(.*?)-$event$/: $id =~ /^(.*?)-$event$/) && defined $description->{$1}) {
	    $title = $description->{$1}->{'description'};
	    $source = $description->{$1}->{'source'};
	    $composer = $description->{$1}->{'composer'};
	    $year = $description->{$1}->{'year'};
	  }
	}
      }
    }
  last if defined $title;
  }
  my($proportional, $monospaced) = ('Lato', 'Fira Mono');
  print "\\version \"2.18.2\"\n";
  print "\\paper { ";
  print "#(define fonts (make-pango-font-tree \"$proportional\" \"$proportional\" \"$monospaced\" 1))\n";
  print "left-margin = 144\\pt\n";
  print "right-margin = 48\\pt\n";
  print "top-margin = 24\\pt\n";
  print "bottom-margin = 24\\pt\n";
  print "}\n";
  if (defined $title) {
    print "\\header {\n";
    print "title = \\markup {Proof sheet for $title}\n";
    print "subtitle = \\markup {(Source: $source)}\n" if defined $source;
    print "composer = \\markup {$composer}\n" if defined $composer;
    print "}\n\\markup { \\vspace #1 }\n\n";
  }
  for my $id (@events_found) {
    my $tune = $chime{$id};
    my $tune_to_typeset = defined $typesettable_version{$tune}? $typesettable_version{$tune}: $tune;
    my $attr = parse_chime_id $id;
    my $duration = determine_chime_duration $id, undef;
    $tune_to_typeset =~ s/\s*\|\s*/\|\n/sg;	# make barcheck warnings more understandable
    print "\\markup{\\column{\n";
    print "\\vspace #1\n";
    print "\\line{\\bold \"$id\"}\n";
    print "\\line{\\tiny \"", Debug::cvs($attr), "\"}\n";
    printf "\\line{\\tiny \"%.2f s\"}\n", $duration if defined $duration;
    print "\\vspace #0.4\n";
    print "}}\n";
    print "\\noPageBreak\n";
    print "$tune_to_typeset\n\n";
    print "\\markup{Note: melody was defined but not converted}\n" unless $interpretation{$tune};
  }
  print "\\layout { \\context { \\RemoveEmptyStaffContext } }\n";
}

sub usage (;$) {
  my($st) = @_;
  my $h = $st? *STDERR: *STDOUT;
  print $h <<EOF;
Usage: $0 [OPTION]...
Chime on the quarter hour and on the start of every fifth of a night watch.

  -d, --sink SINK             Use the specified SINK for audio
      --nonproportional-watches (NOT IMPLEMENTED)
                              Use watches that are aligned to duodecimal hours
  -l, --list                  Display available carillon melodies and exit
  -Q, --qing                  Same as --nonproportional-watches --qing-quarters
      --qing-quarters         Use the Qing quarters system (identical to modern
                              quarters) instead of the ancient centiday system
  -v, --verbose               Explain what is being done
  -z, --create-cache          Create missing cache files first
      --help                  Display this help and exit
EOF
  print $h <<EOF unless $debug;
                              (--debug --help to show debugging options)
EOF
  print $h <<EOF if $debug;

Options for debugging:

      --debug                 Produce debugging output
      --dump-defs             Dump source chime definitions, then exit
      --dump-notes            Dump compiled chime definitions, then exit
      --melody=MELODY         Use the specified MELODY (overrides config file)
      --method=METHOD         Use the specified METHOD (overrides config file)
      --mode=MODE             Use the specified MODE (overrides config file)
      --no-cache              Ignore any pregenerated audio
      --proofsheet            Generate proofsheet on standard output, then exit
      --test                  Continue with test parameters
      --test-event ID[,ID...] Fire event identified by ID, then exit
      --test-scale            Play the major scale from c4 to c5, if possible
  -W, --what-if=TIME          Continue as if current time were TIME
EOF
  print $h <<EOF;

Night watches are determined according to the proportional decimal time
system in use c. 7-2 century BC in ancient China. For details please see
https://github.com/acli/new_clock/blob/master/doc/Night_watches.md
EOF
  exit $st;
}

###############################################################################

sub set_die_handler () {
  $SIG{__DIE__} = sub {
      my($sig) = @_;
      for (my $i = 0; caller $i; $i += 1) {
	printf STDERR "\n%s%d: %s", (' ' x $i), $i, join(' ', caller $i);
      }
      disconnect_synth;
      die "\n$sig";
    };
}

sub do_setup () {
  state $setup_done_p = 0;
  set_die_handler;		# Force __DIE__ handler to be re-set here because GetOptions will force it to DEFAULT, which is wrong
  if (!$setup_done_p) {
    log_info sprintf "chimer booted at real time %.2f (time shifted %+.2f) in %s mode%s using %s",
	  $boottime, $time_displacement, $mode, ($mode eq MODE__CARILLON? " (using $melody melody)": ''), $method
	if $verbose_p || $debug || !-t STDERR;

    set_test_params if $test_p;
    define_chimes;
    if (defined $melody) {
      my $melody_exists_p = 0;
      for my $event_id (enumerate_defined_events) {
	my $chime_id = determine_chime_id_for_event($event_id);
	my $det = parse_chime_id $chime_id;
	$melody_exists_p = 1 if defined $det->{'melody'};
      last if $melody_exists_p;
      }
      if (!$melody_exists_p) {
	log_warning "There is no melody \"$melody\" for mode \"$mode\", melody will be ignored";
	$melody = undef;
      }
    }
    if ($method eq METHOD__SYNTH && $no_cache_p) {
      connect_synth 'test';
    }
    $setup_done_p = 1;
  }
}

sub do_test_setup () {
  set_test_params;
  do_setup;
  connect_synth('test') if $method eq METHOD__SYNTH;
}

sub parse_command_line_arguments () {
  my $what_if;

  select((select(STDERR), $| = 1)[0]); # I don't know why this is needed for STDERR

  # SIGCHLD handler must be IGNORE, otherwise Time::HiRes::sleep will fail randomly
  $SIG{CHLD} = 'IGNORE';

  # Handle config file
  $config = read_ini("$ENV{HOME}/.chimerrc");
  @sinks = @{$config->{'/'}->{'sink'}} if defined $config->{'/'}->{'sink'};
  $mode = $config->{'/'}->{'mode'}->[0] if defined $config->{'/'}->{'mode'};
  $method = $config->{'/'}->{'method'}->[0] if defined $config->{'/'}->{'method'};
  $melody = lc $config->{'/'}->{'melody'}->[0] if defined $config->{'/'}->{'melody'};
  $coords = {'lon' => $config->{'/'}->{'longitude'}->[0], 'lat' => $config->{'/'}->{'latitude'}->[0]}
      if defined $config->{'/'}->{'longitude'} && defined $config->{'/'}->{'latitude'};
  #FIXME die "Melody \"$melody\" is not known\n" unless defined $melody{$melody};
  $datadir = $config->{'/'}->{'datadir'}->[0] if defined $config->{'/'}->{'datadir'};

  # Guess location if not specified in config file
  $coords = guess_coordinates unless defined $coords;
  ($lat, $lon) = ($coords->{'lat'}, $coords->{'lon'}) unless defined $lat;
  die "$0: Can't determine coordinates\n" unless defined $coords;

  # Check command-line arguments
  Getopt::Long::config('bundling');
  GetOptions(
    'D|debug' => sub { $debug += 1; },
    'd|sink=s' => sub { @sinks = $_[1]; },
    'dump-defs' => sub { printf "%s\n", Debug::cvs \%chime; exit disconnect_synth },
    'dump-notes' => sub { for my $key (sort { Debug::lazy_sorter($a, $b) } keys %chime) {
	    printf "%s => %s\n", $key, Debug::cvs $interpretation{$chime{$key}}
	  };
	exit disconnect_synth },
    'enable-nonproportional-watches|nonproportional-watches' => \$enable_nonproportional_watches,
    'enable-qing-quarters|qing-quarters' => \$enable_qing_quarters,
    'l|list' => sub { my %a = map { /^carillon-(.*?)-[qh]\d*$/? ($1 => 1): () } keys %chime; # FIXME
	print join('', map { defined $melody_description{$_}?
	      sprintf("%-24s%s%s\n", $_, $melody_description{$_}->{'description'},
		      ($verbose_p? sprintf(' (source: %s)', $melody_description{$_}->{'source'}): '')):
	      "$_\n" } sort keys %a);
	exit disconnect_synth },
    'melody=s' => \$melody,
    'method=s' => \$method,
    'mode=s' => \$mode,
    'no-cache' => \$no_cache_p,
    'Q|qing' => sub { ($enable_nonproportional_watches, $enable_qing_quarters) = (1, 1); },
    'q|quit' => \$quit_p,
    'proofsheet' => sub { do_setup; generate_proofsheet; exit },
    'test' => \$test_p,
    'test-event=s' => sub { do_test_setup; for my $e (split(/,\s*/, $_[1])) { do_event $e; sleep determine_event_duration($e, undef) };
	exit },
    'test-scale' => sub { do_test_setup; strike_tune(map {[$_, 1]} @midi_number_to_note[48, 50, 52, 53, 55, 57, 59, 60]);
	exit },
    'test-tune=s' => sub { do_test_setup; strike_tune @{interpret_melody $_[1]};
	exit },
    'v|verbose' => \$verbose_p,
    'W|what-if=s' => \$what_if,
    'z|create-cache' => \$create_cache_p,
    'help' => \&usage,
  ) || exit(1);

  if (defined $what_if) {
    no integer;
    if ($what_if =~ /^[-+]\d+(?:\.\d+)?$/) {
      $time_displacement = $what_if + 0;
    } elsif ($what_if =~ /^\d+(?:\.\d+)?$/) {
      $time_displacement = $what_if - Time::HiRes::time;

      # update the restart command
      my $found_p = 0;
      for (my $i = 0; $i < @restart_cmd; $i += 1) {
	log_debug $restart_cmd[$i];
	if ($i && $restart_cmd[$i - 1] =~ /^(?:-w|--what-if)$/ && $restart_cmd[$i] eq $what_if) {
	  $restart_cmd[$i] = sprintf('%+f', $time_displacement);
	  $found_p = 1;
	} elsif ($restart_cmd[$i] =~ /^(--what-if)=$what_if$/) {
	  $restart_cmd[$i] = sprintf('%s=%+f', $1, $time_displacement);
	  $found_p = 1;
	}
      last if $found_p;
      }
      die "$0: Internal error: Could not update restart command\n" unless $found_p;
    } else {
      die "$0: $what_if: Time displacement must be specified as either absolute Unix time or as +seconds / -seconds\n";
    }
  }
}

sub do_main_loop () {
  for (my $countdown = COUNTDOWN, my $last_prediction_error, my $t_last_prediction, my %pending_events, my %completed_events;;) {
    my $t0 = current_time;
    my $c = determine_chinese_time $t0;
    ($_, $_, $_, $_, my $chinese_hour, my $quarter, my $centiday, my $deciday, $_, $_, my $deciday_size) = @$c;
    (my $sec, my $min, my $hour, $_, $_, $_, my $wday) = localtime $t0;

    my $max_sleep_time;

    # Detect terminated child processes
    for my $pid (keys %children) {
      if (!kill 0, $pid || waitpid($pid, WNOHANG) == $pid) {
	log_debug "child process $pid has exited" if $debug;
	close $children{$pid} if $children{$pid} =~ /\D/s;
	delete $children{$pid};
      }
    }

    # Determine what should happen next
    no integer;
    my @event = determine_events($t0, $hour, $min, $sec, $chinese_hour, $quarter, $centiday, $deciday, $deciday_size);
    my $next_event;
    log_debug "Upcoming events determined to be " . Debug::cvs(\@event) if $debug;
    for my $event (@event) {
      # Don't trust floating point calculations - don't use t as key, use id instead
      $pending_events{+$event->{'id'}} = $event;
    }
    # remove events that don't exist in the current personality
    for my $id (keys %pending_events) {
      my $chime_id = determine_chime_id_for_event($id);
      if (!defined $chime_id) {
	delete $pending_events{$id};
	log_debug "Event $id discarded because it's not defined for $mode $melody" if $debug;
      }
    }
    # delay night watches and post-hour chimes if they clash with other, more important chimes
    for my $id (sort { $pending_events{$a}->{'t'} + $pending_events{$a}->{'delay'} <=> $pending_events{$b}->{'t'} + $pending_events{$b}->{'delay'} } grep { $pending_events{$_}->{'type'} =~ /^(?:watch|post-quarter)$/ } keys %pending_events) {
      for my $id2 (sort { $pending_events{$a}->{'t'} + $pending_events{$a}->{'delay'} <=> $pending_events{$b}->{'t'} + $pending_events{$b}->{'delay'} } grep { $_ ne $id } keys %pending_events) {
	my $t1_start = $pending_events{$id}->{'t'} + $pending_events{$id}->{'delay'};
	my $t2_start = $pending_events{$id2}->{'t'} + $pending_events{$id2}->{'delay'};
	my $d1 = determine_event_duration($id, 30);
	my $d2 = determine_event_duration($id2, 30);
	my $t1_end = $t1_start + $d1;
	my $t2_end = $t2_start + $d2;
	if ($t2_start <= $t1_start && $t1_start <= $t2_end) {
	  my $delay = $t2_end - $t1_start + 5;
	  $pending_events{$id}->{'delay'} += $delay;
	  log_debug "$id start time $t1_start delayed by $delay s because it falls within $id2 [$t2_start, $t2_end]";
	} elsif ($t2_start <= $t1_end && $t1_end <= $t2_end) {
	  my $delay = $t2_end - $t1_end + $d1 + 5;
	  $pending_events{$id}->{'delay'} += $delay;
	  log_debug "$id end time $t1_start delayed by $delay s because it falls within $id2 [$t2_start, $t2_end]";
	}
      }
    }
    # remove events that we somehow missed
    for my $id (keys %pending_events) {
      my $e = $pending_events{$id};
      my $t = $e->{'t'};
      $t += $e->{'delay'} if defined $e->{'delay'};
      if ($t0 - $t > 60) { # just do it if we missed it by just a fraction of a second, actually it's fine even if it's a whole minute
	log_info sprintf "EVENT %s (%d) MISSED at %d (%.2f too late)", $id, $t, $t0, $t0 - $t;
	delete $pending_events{$id};
      }
    }
    # reconstitute the @event array
    @event = sort { $a->{'t'} + $a->{'delay'} <=> $b->{'t'} + $b->{'delay'} } map { $pending_events{$_} } keys %pending_events;

    # Determine when we should wake up; try to make some effort to align it to a second boundary
    my $t1 = current_time;
    my $dt0 = $event[0]->{'t'} - $t1;
    my $latency_key0 = determine_latency_key_from_event_id $event[0]->{'id'};
    $dt0 -= $expected_latency{$latency_key0}->predict() if defined $expected_latency{$latency_key0};
    my $t_next = ($countdown && $dt0 > 1)? (int($t0) + 1): ($t1 + $dt0/2);
    my $dt = $t_next - $t1;
    $dt = 0 if $dt < 0;

    # If we have time to generate some sound clips, do it
    if ($dt0 > 90 && $method eq METHOD__SYNTH && !$no_cache_p) {
      my $event = determine_next_uncached_event @event;
      if (defined $event) {
	$max_sleep_time = determine_event_duration($event, 60) + SECONDS_BEFORE_DISCONNECT + 15;
	if ($dt0 > $max_sleep_time) {
	  generate_sound_clip_for_event $event;
	}
	$countdown = 0; # force a re-countdown
      }
    }

    # Ditto for latencies, if it is possible to measure them
    if (latency_measurable_p) {
      my $t1 = current_time;
      my $dt0 = $event[0]->{'t'} - $t1;
      if ($dt0 > 90 && $method eq METHOD__SYNTH && !$no_cache_p) {
	my $event = determine_next_event_with_unknown_latency @event;
	measure_latency_for_event $event if defined $event;
      }
    }

    # Debug message
    log_comment sprintf "%10.2f=%02d+%2.2f=%2.2f=%2.2f (Δt=%2.2f) > %s",
	$t0, $chinese_hour, $quarter, $centiday, $deciday, $dt,
	join(', ', map { sprintf(($debug? '%.2f (%+.1f) %s': '%3$s%2$+.1f'), $_->{'t'}, ($_->{'t'} - $t0), $_->{'id'}) } @event) if $verbose_p;

    my $t2 = current_time;
    $dt = $max_sleep_time if defined $max_sleep_time && $dt > $max_sleep_time;
    Time::HiRes::sleep $dt;

    # Check if any event should be fired
    my $now = current_time;
    my $dt_actual = $now - $t2;
    log_warning sprintf "tried to sleep for %.2f s but slept for %.2f s\n", $dt, $dt_actual if $dt_actual > $dt + 1;
    for my $id (keys %pending_events) {
      my $e = $pending_events{$id};
      my $t = $e->{'t'};
      my $latency_key = determine_latency_key_from_event_id $id;
      my($effective_latency, $prediction_method) = $expected_latency{$latency_key}->predict() if defined $expected_latency{$latency_key};
      $t += $e->{'delay'} if defined $e->{'delay'};
      $t -= $effective_latency if defined $effective_latency;
      $t += $last_prediction_error if defined $last_prediction_error && $last_prediction_error > 0 && $t_last_prediction >= $now - 15; # XXX
      if ($now < $t) {
	;
      } elsif (defined $completed_events{$id} && $now - $completed_events{$id} < 15) { # This should never happen (but it does)
	log_error sprintf "EVENT %s (%.2f) already fired at %.2f (%.2f s ago)\n", $id, $t, $completed_events{$id}, $now - $completed_events{$id} if $debug;
	delete $pending_events{$id};
      } else {
	my $dt = $now - $t;
	log_info sprintf "EVENT %s (%.2f) fired at %.2f (%s)%s", $id, $t, $now, ($dt < 0.01? 'on time': sprintf('%.2f s late', $dt)),
	      (defined $effective_latency? sprintf(' (%.2f latency predicted by %s)', $effective_latency, $prediction_method):
					  ' (unable to predict latency)');
	set_sink_volumes($hour, $min, $sec, $deciday, $wday);
	my $actual_latency = do_event($id, $hour, $min, $sec, $deciday, $wday);

	# Remember prediction error
	my $duration = determine_event_duration($id, undef);
	$last_prediction_error = defined $actual_latency && defined $effective_latency? $actual_latency - $effective_latency: undef;
	$t_last_prediction = $now + $duration;
	log_info sprintf 'Latency for %s ending %.2f was %s', $id, $t_last_prediction,
		sprintf(($last_prediction_error == 0? 'perfect':
			$last_prediction_error > 0? 'underestimated by %.2f': 'overestimated by %.2f'), $last_prediction_error),
	    if defined $last_prediction_error;

	$countdown = 0; # force a re-countdown
	$completed_events{$id} = $now;
	delete $pending_events{$id};
      }
    }

    $countdown -= 1;
    $countdown = COUNTDOWN if $countdown < 0;
  }
}

if (!caller) {
  set_die_handler;
  parse_command_line_arguments;
  do_setup;
  if ($create_cache_p) {
    generate_sound_clips;
    do_setup;
  }
  do_main_loop unless $quit_p;
  disconnect_synth;
}

=pod

=head1 HISTORY

Concept from the Javascript chiming clocks:
"Copyright © 2018 by Ambrose Li :-)"

Mostly based on the genmon script for Chinese/Hebrew dates:
"Copyright 2016-2018, 2021 by Ambrose Li <ambrose.li@gmail.com>
The primary purpose of this script is to figure out the year number in the Chinese system
so that I can name my CV's without having to look up two web pages.
Everything else is just for kicks =P"

=cut

1;
