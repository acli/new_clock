#!/usr/bin/perl
# vi:set sw=2 ai sm:
#
# Re-implementation of the Javascript chiming clocks (sysline, silliness) in Perl
# Copyright © 2021 by Ambrose Li
# The primary purpose of this script is to avoid running the two chiming clock pages
# as Firefox tabs, because Firefox (and all Chrome-based browsers) are now unfriendly
# to Javascript pages that use audio as their primary UI. Firefox also leaks memory
# really fast so it's best to not keep Firefox running for long periods of time.
#
# Eventually this script might provide a way to make the genmon script less CPU
# intensive.
#
# This re-implementation uses the following sounds:
#
# strangehorizon. (2021). "Tuned Chau Gongs: g16_D#5-gong.wav" (audio file).
# Retrieved from https://freesound.org/people/strangehorizon/sounds/582159/
#
# ------
#
# Concept from the Javascript chiming clocks:
# "Copyright © 2018 by Ambrose Li :-)"
#
# ------
#
# Mostly based on the genmon script for Chinese/Hebrew dates:
# "Copyright 2016-2018, 2021 by Ambrose Li <ambrose.li@gmail.com>
# The primary purpose of this script is to figure out the year number in the Chinese system
# so that I can name my CV's without having to look up two web pages.
# Everything else is just for kicks =P"
#

# see https://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default for these crazy hacks
# THERE ARE MORE CRAZY HACKS THERE FOR MORE COMPLEX PROJECTS!!
use v5.12; # minimal for unicode string feature
use v5.14; # //u modifier
use utf8;
open qw( :encoding(UTF-8) :std );
use charnames qw( :full :short );
use feature "unicode_strings";

use warnings qw( FATAL utf8 );
use Encode qw( encode decode );
#@ARGV = map { decode("UTF-8", $_) } @ARGV if grep /\P{ASCII}/ => @ARGV;


use strict;
use integer;

use POSIX;
use DateTime;
use Time::HiRes; # overrides (qw) do not seem to work

use vars qw( $use_datetime_event_sunrise );
use vars qw( $use_datetime_astro_sunrise );
use vars qw( $use_astro_sunrise );
BEGIN {
  if (eval { require DateTime::Event::Sunrise; }) {
    $use_datetime_event_sunrise = 1;
  } elsif (eval { require DateTime::Astro::Sunrise; }) {
    $use_datetime_astro_sunrise = 1;
  } elsif (eval { require Astro::Sunrise; }) {
    $use_astro_sunrise = 1;
  } else {
    die "Cannot find a usable Sunrise package";
  }
}

use Getopt::Long;
use Data::Dumper;

use vars qw( $debug );
use vars qw( $verbose_p );
use vars qw( $enable_seconds );
use vars qw( $enable_nonproportional_watches );
use vars qw( $enable_qing_quarters );
use vars qw( $enable_planetary $planetary_omit_details );
use vars qw( $enable_decaminutes $enable_minutes );
use vars qw( $enable_4th_hebrew_watch );

use vars qw( $coords );
use vars qw( $lat $lon );
use vars qw( @sinks );

use vars qw( $datadir );
$datadir = "$1/data" if $0 =~ /^(.*?)\/[^\/]+$/;

# number of times we try sleeping for 1 second until we sleep until the target event
sub COUNTDOWN () { 5 } # things stablize after 2-3 times, we do 5 just in case (10 is overkill)

# night watch chime patterns
sub LONG_STRIKE  () { 1.5 }
sub SHORT_STRIKE () { 0.75 }
sub GAP          () { 5 }
# watch chime patterns: repetitions, pattern
# gap needs to be long enough to hear it, but short enough to not mistake it for a long strike. This is HARD
use vars qw( @watch_chime_pattern );
@watch_chime_pattern = ( # v. https://zh.wikipedia.org/wiki/打更 (q.v.)
   [3, '- .'		],
   [2, '. .'		],
   [3, '- . .'		],
   [4, '- . . .'	],
   [5, '- . . . .'	],
   [1, '-'		],		# test chime X
   [1, '.'		],		# test chime Y
);

use vars qw( @midi_number_to_note %note_to_midi_number );
@midi_number_to_note = (
  'c0', 'c#0', 'd0', 'd#0', 'e0', 'f0', 'f#0', 'g0', 'g#0', 'a0', 'a#0', 'b0',
  'c1', 'c#1', 'd1', 'd#1', 'e1', 'f1', 'f#1', 'g1', 'g#1', 'a1', 'a#1', 'b1',
  'c2', 'c#2', 'd2', 'd#2', 'e2', 'f2', 'f#2', 'g2', 'g#2', 'a2', 'a#2', 'b2',
  'c3', 'c#3', 'd3', 'd#3', 'e3', 'f3', 'f#3', 'g3', 'g#3', 'a3', 'a#3', 'b3',
  'c4', 'c#4', 'd4', 'd#4', 'e4', 'f4', 'f#4', 'g4', 'g#4', 'a4', 'a#4', 'b4',
  'c5', 'c#5', 'd5', 'd#5', 'e5', 'f5', 'f#5', 'g5', 'g#5', 'a5', 'a#5', 'b5',
  'c6', 'c#6', 'd6', 'd#6', 'e6', 'f6', 'f#6', 'g6', 'g#6', 'a6', 'a#6', 'b6',
  'c7', 'c#7', 'd7', 'd#7', 'e7', 'f7', 'f#7', 'g7', 'g#7', 'a7', 'a#7', 'b7',
  'c8', 'c#8', 'd8', 'd#8', 'e8', 'f8', 'f#8', 'g8', 'g#8', 'a8', 'a#8', 'b8',
  'c9', 'c#9', 'd9', 'd#9', 'e9', 'f9', 'f#9', 'g9', 'g#9', 'a9', 'a#9', 'b9',
);
%note_to_midi_number = map { $midi_number_to_note[$_] => $_ } 0..$#midi_number_to_note;

use vars qw( %scale );
%scale = (
  'c4'	=> '582141__strangehorizon__g01-c-4-gong.wav',
  'c#4'	=> '582140__strangehorizon__g02-c-4-gong.wav',
  'd4'	=> '582139__strangehorizon__g03-d-4-gong.wav',
  'd#4'	=> '582138__strangehorizon__g04-d-4-gong.wav',
  'e4'	=> '582145__strangehorizon__g05-e-4-gong.wav',
  'f4'	=> '582144__strangehorizon__g06-f-4-gong.wav',
  'f#4'	=> '582143__strangehorizon__g07-f-4-gong.wav',
  'g4'	=> '582142__strangehorizon__g08-g-4-gong.wav',
  'g#4'	=> '582147__strangehorizon__g09-g-4-gong.wav',
  'a4'	=> '582146__strangehorizon__g10-a-4-gong.wav',
  'a#4'	=> '582156__strangehorizon__g11-a-4-gong.wav',
  'b4'	=> '582155__strangehorizon__g12-b-4-gong.wav',
  'c5'	=> '582154__strangehorizon__g13-c-5-gong.wav',
  'c#5'	=> '582153__strangehorizon__g14-c-5-gong.wav',
  'd5'	=> '582160__strangehorizon__g15-d-5-gong.wav',
  'd#5'	=> '582159__strangehorizon__g16-d-5-gong.wav',
  'e5'	=> '582158__strangehorizon__g17-e-5-gong.wav',
  'f5'	=> '582157__strangehorizon__g18-f-5-gong.wav',
  'f#5'	=> '582162__strangehorizon__g19-f-5-gong.wav',
  'g5'	=> '582161__strangehorizon__g20-g-5-gong.wav',
);
use vars qw( $p1 $p2 $p3 $p4 $p5 $rest $strike );
$p1 = [
    ['g#4', 1],
    ['f#4', 1],
    ['e4', 1],
    ['b3', 1.5],
    ['r', 1.5],
  ];
$p2 = [
    ['e4', 1],
    ['g#4', 1],
    ['f#4', 1],
    ['b3', 1.5],
    ['r', 1.5],
  ];
$p3 = [
    ['e4', 1],
    ['f#4', 1],
    ['g#4', 1],
    ['e4', 1.5],
    ['r', 1.5],
  ];
$p4 = [
    ['g#4', 1],
    ['e4', 1],
    ['f#4', 1],
    ['b3', 1.5],
    ['r', 1.5],
  ];
$p5 = [
    ['b3', 1],
    ['f#4', 1],
    ['g#4', 1],
    ['e4', 1.5],
    ['r', 1.5],
  ];
$rest = [
    ['r', 1],
  ];
$strike = [
    ['f3', 1.5],
    ['r', 1.5],
  ];

sub start_of_day ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  return mktime(0, 0, 0, $mday, $mon, $year);
}

sub yesterday ($) {
  my($t) = @_;
  return start_of_day(start_of_day($t) - 12*3600);
}

sub tomorrow ($) {
  my($t) = @_;
  return start_of_day(start_of_day($t) + 36*3600);
}

sub estimate_sunrise ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->start;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[0];
    $it = $tmp->strftime('%s');
  } else {
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunrise;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub estimate_sunset ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->end;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[1];
    $it = $tmp->strftime('%s');
  } else {
    # this should be the same as the else case in estimate_sunrise except the last line
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunset;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub trim ($) {
  my($s) = @_;
  $s =~ s/^\s+//;
  $s =~ s/\s+$//;
  return $s;
}

sub guess_city () {
  my $input = '/etc/localtime';
  my $det = readlink $input;
  die "$input: $!\n" unless defined $det;
  return $1 if $det =~ /([^\/]+)$/s;
}

sub guess_coordinates () {
  my $it;
  my $city = guess_city;
  print STDERR "guessed city=($city)\n" if $debug;
  my @cmd = qw(hebcal cities);
  print STDERR 'DEBUG: running: ', join(' ', @cmd), "\n" if $debug;
  my $pid = open(INPUT, '-|');
  die "$0: guess_coordinates: $cmd[0]: fork: $!\n" unless defined $pid;
  if ($pid) {
    my $re = quotemeta $city;
    for (;;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp;
      if ($s =~ /^$re \((\d+)d(\d+)' ([NS]) lat, (\d+)d(\d+)' ([EW]) long/) {
	no integer;
	$it = {
	      'lat' => ($1 + $2/60)*($3 eq 'N'? 1: -1),
	      'lon' => ($4 + $5/60)*($6 eq 'E'? 1: -1),
	    };
      }
    last if defined $it;
    }
    close INPUT;
  } else {
    exec {$cmd[0]} @cmd;
    die "$0: guess_coordinates: $cmd[0]: exec: $!\n";
  }
  return $it;
}

# NOTE: modified to act like the current PHP version (root section goes to /, duplicate keys allowed and get stashed into an array)
sub read_ini ($) {
  my($input) = @_;
  my $it;
  local(*INPUT, $.);
  if (open(INPUT, '<:utf8', $input)) {
    for (my $section = '/';;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp $s;
      if ($s =~ /^\s*(?:[#\%;]|$)/) {
	;
      } elsif ($s =~ /^\s*\[\s*([^\[\]]+?)\s*\]\s*$/) {
	$section = $1;
      } elsif ($s =~ /^\s*([^=]+?)\s*=\s*(.*)/) {
	if (defined $section) {
	  $it->{$section}->{$1} = [] unless defined $it->{$section}->{$1};
	  push @{$it->{$section}->{$1}}, $2;
	} else {
	  $it->{$1} = [] unless defined $it->{$1};
	  push @{$it->{$1}}, $2;
	}
      } else {
	warn "$input:$.: Warning: Unknown input \"$s\"\n";
      }
    }
    close INPUT;
  }
  return $it;
}


# Quarters are weird. See https://zh.wikipedia.org/wiki/%E5%88%BB
#                     and http://yywz.snnu.edu.cn/show.aspx?id=697&cid=26
# Apparently the old Chinese system also used proportional hours... so we'll need to refactor things here at some point
# http://www.twword.com/wiki/%E5%B9%B2%E6%94%AF%E7%B4%80%E6%B3%95
sub determine_chinese_time ($) {
  my($t) = @_;
  my $it;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $midnight = start_of_day $t;
  my $deciday;
  my $slice; # size of proportional hour, needed to figure out when to sound the next chime
  # NOTE: according to one source (forgot which), the first hour (ˊdzi) spans [2300, 0100) but the new day still starts at 0000. Very odd :-/
  # therefore the old adjustment for [2300, 0000) has been deleted
  if (defined $coords) {
    my $today = start_of_day $t;
    my $yesterday = yesterday $t;
    my $tomorrow = tomorrow $t;
    my($daybreak, $slice_start, $slice_end, $starting_hour);
    # Proportional hour is used in a very early system (Spring and Autumn Period / Warring States),
    # but I don't even have an idea when the day starts (probably day before night) so we'll arbitrarily use sunrise as cutoff
    if ($t < estimate_sunrise($today)) {
      $daybreak = estimate_sunrise($yesterday);
      $slice_start = estimate_sunset($yesterday);
      $slice_end = estimate_sunrise($today);
      $starting_hour = 6;
    } elsif ($t < estimate_sunset($today)) {
      $daybreak = estimate_sunrise($today);
      $slice_start = $daybreak;
      $slice_end = estimate_sunset($today);
      $starting_hour = 1;
    } else {
      $daybreak = estimate_sunrise($today);
      $slice_start = estimate_sunset($today);
      $slice_end = estimate_sunrise($tomorrow);
      $starting_hour = 6;
    }
    if ($slice_start && $slice_end) {
      no integer;
      $slice = ($slice_end - $slice_start)/5;
      $deciday = $starting_hour + ($t - $slice_start)/$slice;
    }
  }
  my($greg_year, $greg_month, $greg_day) = ($year + 1900, $mon + 1, $mday);
  my $relative_chinese_hour = eval { no integer; fmod(($t - ($midnight - 3600))/7200, 12) };
  my $chinese_hour = $relative_chinese_hour + 1;
  my $quarter;
  my $centiday = eval { no integer; ($t - $midnight)/864 };
  if ($enable_qing_quarters) {
    $quarter = $min/15 + 1;
    $quarter += 4 if $hour%2 == 0;
  } else {
    # NOTE: traditionally these aren't quarters, but number of centiday marks past the beginning of the hour
    no integer;
    #
    # 0.5 hours maps exactly to 0 centidays. So to calculate the reporting origin, which is fractional.
    # Each hour is 86400/12 seconds, each centiday is 86400/100 seconds, so each hour is 100/12 centidays
    # In theory, each zero-based hour h begins exactly at ⌊h - 0.5⌋*100/12 centidays
    # However, when h ∈ [0, 0.5) this gives unexpected results because the formula will give a negative result
    # There's no easy way to fix this because reporting origins are hour-aligned, not half-hour aligned
    # (so we can't even change ⌊h - 0.5⌋ to (⌊h*2 - 1⌋%24)/2 because this breaks for h > 1.0)
    #
    my $reporting_origin = POSIX::floor(($relative_chinese_hour < 0.5? 11.5: (int($relative_chinese_hour) - 0.5)) * 100 / 12);
    print STDERR "relative_chinese_hour=$relative_chinese_hour => reporting_origin=$reporting_origin\n" if $debug;
    $quarter = $centiday - int($reporting_origin);
  }
  $it = [undef, undef, undef, undef, $chinese_hour, $quarter, $centiday, $deciday,
      $wday, eval { no integer; $relative_chinese_hour < 0.5 }, $slice];
  return $it;
}

sub determine_events ($$$$$$$$$) {
  my($t0, $hour, $min, $sec, $chinese_hour, $quarter, $centiday, $deciday, $deciday_size) = @_;
  my @it;
  no integer;

  # Western quarter-hour chime
  # Make absolutely sure we have a chime event, in case it gets thrown out because we're too close to the actual next quarter hour
  my $seconds_since_hour_change = 60*$min + $sec;
  my $t_next_quarter_chime = int($t0) + (900 - $seconds_since_hour_change%900);
  my $next_quarter = (int($seconds_since_hour_change / 900) + 1)%4;
  my $next_hour = (($next_quarter? $hour: $hour + 1) + 11)%12 + 1;
  my $quarter_chime_event_pushed_p = 0;
  die "Calculation error, next quarter $t_next_quarter_chime is in the past" if $t_next_quarter_chime < $t0;
  die "Calculation error, next quarter $t_next_quarter_chime more than 15 minutes away" if $t_next_quarter_chime - $t0 > 900;
  for (my $i = 0; $i < 2; $i += 1,
			  $t_next_quarter_chime += 900,
			  $next_quarter = ($next_quarter + 1)%4,
			  $next_hour += !$next_quarter, $next_hour = ($next_hour - 1)%12 + 1) {
    my $prechime_length;
    if ($next_quarter == 0) {
      push @it, {
	't' => $t_next_quarter_chime,
	'id' => "h$next_hour",
	'type' => 'hour',
	'comment' => "hour $next_hour chime",
      };
      $prechime_length = 25;
    } elsif ($next_quarter == 1) {
      $prechime_length = 5;
    } elsif ($next_quarter == 2) {
      $prechime_length = 10;
    } elsif ($next_quarter == 3) {
      $prechime_length = 15;
    }
    if ($t_next_quarter_chime - $prechime_length >= $t0) {
      push @it, {
	't' => $t_next_quarter_chime - $prechime_length,
	'id' => "q$next_quarter",
	'type' => 'quarter',
	'comment' => "hour $next_hour quarter $next_quarter prechime",
      };
      $quarter_chime_event_pushed_p = 1;
    }
  last if $quarter_chime_event_pushed_p;
  }

  # Shang-era proportional-deciday-based night watch chimes
  # 1 watch is exactly 1 deciday, which is not actually 1/10 of a day but 1/5 of the current proportional moitie
  if ($deciday > 5 && $deciday < 6) { # 5 is the last deciday in the "day" moitie
    my $t_first_watch = $t0 + (6 - $deciday)*$deciday_size;
    push @it, {
      't' => $t_first_watch,
      'id' => 'w1.1',
      'type' => 'watch',
      'comment' => 'watch 1',
    };
  } elsif ($deciday >= 6) {
    my $decidays_into_night = $deciday - 6;
    my $subwatches_into_night = 5*$decidays_into_night;
    my $zero_based_next_subwatch = (int($subwatches_into_night) + 1)%25;
    if ($zero_based_next_subwatch) {
      my $next_watch = int($zero_based_next_subwatch/5) + 1;
      my $next_fifth_of_watch = $zero_based_next_subwatch%5 + 1;
      my $t_next_fifth_of_watch = $t0 + (1 - fmod($subwatches_into_night, 1)) * ($deciday_size/5);
      push @it, {
	't' => $t_next_fifth_of_watch,
	'id' => "w$next_watch.$next_fifth_of_watch",
	'type' => 'watch',
	'comment' => "watch $next_watch.$next_fifth_of_watch",
      };
    }
  }

  @it = sort { $a->{'t'} <=> $b->{'t'} } @it;
  return wantarray? @it: \@it;
}

sub set_sink ($) {
  my($sink) = @_;
  $ENV{'PULSE_SINK'} = $sink if defined $sink;
}

sub play_sound_file_real ($;$$$) {
  my($input, $volume, $start, $end) = @_;
  $input = "$1.mp3" if !-f $input && $input =~ /^(.*?)\.wav$/ && -f "$1.mp3";

  # Fork and play it in the background
  my @cmd = ('mpv', '--audio-client-name', 'Chiming clock', '--no-video', '--really-quiet', '--input-terminal', 'no', '--volume', $volume);
  push @cmd, ('--start', $start) if defined $start;
  push @cmd, ('--end', $end) if defined $end;
  push @cmd, $input;
  print STDERR 'DEBUG: running: ', join(' ', @cmd), "\n" if $debug;
  my $h = fork;
  die "$cmd[0]: fork: $!\n" unless defined $h;
  if ($h == 0) {
    POSIX::close(0);
    exec { $cmd[0] } @cmd;
    die "$cmd[0]: exec: $!\n";
  }
}

sub play_sound_file ($;$$$) {
  my($input, $volume, $start, $end) = @_;
  $volume = 50 unless defined $volume;
  if (@sinks) {
    for my $sink (@sinks) {
      print STDERR "set sink $sink\n" if $debug;
      set_sink $sink;
      play_sound_file_real($input, $volume, $start, $end);
    }
  } else {
    play_sound_file_real($input, $volume, $start, $end);
  }
}

sub strike_gong (;$) {
  my($note) = @_;
  if ($note ne 'r') {
    $note = 'd#5' if !defined $note || !defined $scale{$note};
    play_sound_file sprintf('%s/%s', $datadir, $scale{$note}), 32;
  }
}

sub carillon_transpose ($) {
  my($note) = @_;
  my $it = $midi_number_to_note[$note_to_midi_number{$note} + 11] if $note ne 'r'; # or just shift it by one
  return defined $it? $it: $note;
}

sub strike_tune (@) {
  my @tune = @_;
  printf STDERR "Trying to strike %s\n", join(' ', map { $_->[0] } @tune) if $debug || $verbose_p;
  for my $spec (@tune) {
    my($note, $time) = @$spec;
    strike_gong carillon_transpose $note;
    Time::HiRes::sleep $time;
  }
}

sub announce_quarter_hour_by_carillon ($) {
  my($quarter) = @_;
  my @tune;
  print STDERR "Pretending to announce quarter hour for quarter $quarter\n";
  if ($quarter == 1) {
    @tune = @$p1;
  } elsif ($quarter == 2) {
    @tune = (@$p2, @$p3);
  } elsif ($quarter == 3) {
    @tune = (@$p4, @$p5, @$p1);
  } else {
    @tune = (@$p2, @$p3, @$p4, @$p5);
  }
  strike_tune @tune;
}

sub announce_quarter_hour_by_cuckoo ($) {
  my($quarter) = @_;
  if ($quarter == 2) {
    print STDERR "Cuckoo trying to announce quarter $quarter\n";
    play_sound_file "$datadir/35053__reinsamba__cuckoo-2007-04-17.wav", 100, 29, 33;
  } else {
    print STDERR "Cuckoo does not announce quarter $quarter\n";
  }
}

sub announce_quarter_hour ($) {
  my($quarter) = @_;
  announce_quarter_hour_by_carillon($quarter);
}

sub announce_hour_by_carillon ($) {
  my($hour) = @_;
  my @tune = (@$strike) x $hour;
  strike_tune @tune;
}

sub announce_hour_by_cuckoo ($) {
  my($hour) = @_;
  my $f = sub { my($x) = @_; no integer; 8 + (26 - 8)/12 * $x + ($x > 6) };
  print STDERR "Cuckoo trying to announce hour $hour\n";
  play_sound_file "$datadir/35053__reinsamba__cuckoo-2007-04-17.wav", 100, 8, &$f($hour);
  for my $dt ((undef, 1.4, 1.4, 1.3,  1.4, 1.4, 2.1,
                      1.8, 1.6, 1.6,  1.6, 1.6, 1.6)[1..$hour]) {
    strike_gong 'c#4';
    Time::HiRes::sleep($dt);
  }
}

sub announce_hour ($) {
  my($hour) = @_;
  announce_hour_by_carillon($hour);
}

sub announce_night_watch ($$) {
  my($watch, $subwatch) = @_;
  # Fork and play it in the background
  my $h = fork;
  die "fork: $!\n" unless defined $h;
  if ($h == 0) {
    my($repeats, $pattern) = @{$watch_chime_pattern[$watch - 1]};
    for (my $i = 0; $i < $repeats; $i += 1) {
      print STDERR "DEBUG: pattern is $pattern\n" if $debug;
      for my $length (split(/\s+/, $pattern)) {
	$length = ($length eq '.'? SHORT_STRIKE: LONG_STRIKE);
	strike_gong;
	Time::HiRes::sleep $length;
      }
      Time::HiRes::sleep GAP unless $i + 1 == $repeats;
    }
  }
}

sub do_event ($) {
  my($id) = @_;
  if ($id =~ /^q(\d+)$/) {			# quarter hour chime
    announce_quarter_hour $1;
  } elsif ($id =~ /^h(\d+)$/) {		# hourly chime
    announce_hour $1;
  } elsif ($id =~ /^w(\d+)\.(\d+)$/) {	# night watch
    announce_night_watch $1, $2;
  } else {
    print STDERR "Unknown event $id ignored\n";
  }
}

sub usage (;$) {
  my($st) = @_;
  my $h = $st? *STDERR: *STDOUT;
  print $h <<EOF;
Usage: $0 [OPTION]...
Display date and time information in a non-mainstream calendar.

  -d, --sink SINK             Use the specified SINK for audio
      --disable-hebrew        Do not display Hebrew date and time
  -M, --decaminutes           Enable display of ancient Chinese decaminutes
                              (and disable display of fractional centidays)
  -m, --minutes               Enable display of Western "planetary" minutes (and
                              ancient Chinese minutes if decaminutes are enabled)
      --nonproportional-watches
                              Use watches that are aligned to Chinese hours
  -p, --enable-planetary=all  Enable the Western "planetary" system and display
                              current time in addition to the equivalent zodiac
  -p, --enable-planetary=minimal
                              Enable the Western "planetary" system but display
                              only the zodiac corresponding to the current hour
  -Q, --qing                  Same as --nonproportional-watches --qing-quarters
      --qing-quarters         Use the Qing quarters system (identical to modern
                              quarters) instead of the ancient centiday system
  -s, --seconds               Enable display of Western "planetary" seconds
      --test-hour HOUR        Play hourly chime for HOUR (1..12)
      --test-quarter QUARTER  Play quarter chime for QUARTER (0..3)
      --test-watch WATCH      Play night watch chime for WATCH (1..5)
  -v, --verbose               Explain what is being done
  -3, --disable-4th-watch     Use 3 watches for Hebrew system. This is the default
  -4, --enable-4th-watch      Use 4 watches for Hebrew system
      --symbolic              Use zodiac names
      --debug                 Produce debugging output

Note that Chinese and Hebrew dates and times are always shown. Western "planetary"
times are shown only when enabled.
EOF
  exit $st;
}

binmode STDIN, ':utf8';
binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';

select((select(STDERR), $| = 1)[0]); # I don't know why this is needed for STDERR
$SIG{'CHLD'} = 'IGNORE';

# Handle config file
my $config = read_ini("$ENV{HOME}/.chimerrc");
@sinks = @{$config->{'/'}->{'sink'}} if defined $config->{'/'}->{'sink'};
$coords = {'lon' => $config->{'/'}->{'longitude'}->[0], 'lat' => $config->{'/'}->{'latitude'}->[0]}
    if defined $config->{'/'}->{'longitude'} && defined $config->{'/'}->{'latitude'};

# Guess location if not specified in config file
$coords = guess_coordinates unless defined $coords;
($lat, $lon) = ($coords->{'lat'}, $coords->{'lon'}) unless defined $lat;
die "$0: Can't determine coordinates\n" unless defined $coords;

# Check command-line arguments
if (!caller) {
  Getopt::Long::config('bundling');
  GetOptions(
    'D|debug' => sub { $debug += 1; },
    'd|sink=s' => sub { @sinks = $_[1]; },
    'M|enable-decaminutes|decaminutes' => \$enable_decaminutes,
    'm|enable-minutes|minutes' => \$enable_minutes,
    's|enable-seconds|seconds' => \$enable_seconds,
    'enable-nonproportional-watches|nonproportional-watches' => \$enable_nonproportional_watches,
    'enable-qing-quarters|qing-quarters' => \$enable_qing_quarters,
    'Q|qing' => sub { ($enable_nonproportional_watches, $enable_qing_quarters) = (1, 1); },
    'test-hour=i' => sub { exit announce_hour(($_[1] - 1) % 12 + 1) },
    'test-quarter=i' => sub { exit announce_quarter_hour($_[1] % 4) },
    'test-watch=i' => sub { exit announce_night_watch(($_[1] - 1) % 5 + 1, 1) },
    '3|disable-4th-hebrew-watch|disable-4th-watch' => sub { $enable_4th_hebrew_watch = 0; },
    '4|enable-4th-hebrew-watch|enable-4th-watch' => \$enable_4th_hebrew_watch,
    'v|verbose' => \$verbose_p,
    'help' => \&usage,
  ) || usage(1);

}

for (my $epsilon = 0, my $countdown = COUNTDOWN, my %events;;) {
  my $t0 = Time::HiRes::time;
  my $c = determine_chinese_time $t0;
  ($_, $_, $_, $_, my $chinese_hour, my $quarter, my $centiday, my $deciday, $_, $_, my $deciday_size) = @$c;
  my($sec, $min, $hour) = localtime $t0;

  # Determine what should happen next
  no integer;
  my @event = determine_events($t0, $hour, $min, $sec, $chinese_hour, $quarter, $centiday, $deciday, $deciday_size);
  my $next_event;
  for my $event (@event) {
    # Don't trust floating point calculations - don't use t as key, use id instead
    $events{+$event->{'id'}} = $event;
  }
  for my $id (keys %events) {
    my $e = $events{$id};
    my $t = $e->{'t'};
    if ($t0 - $t > 0.25) { # just do it if we missed it by just a fraction of a second
      printf STDERR "\nEVENT %s (%d) MISSED at %d (%.2f too late)\n", $id, $t, $t0, $t0 - $t;
      delete $events{$id};
    }
  }
  # reconstitute the @event array
  @event = sort { $a->{'t'} <=> $b->{'t'} } map { $events{$_} } keys %events;

  # Determine when we should wake up; try to make some effort to align it to a second boundary
  my $t1 = Time::HiRes::time;
  my $dt0 = $event[0]->{'t'} - $t1;
  my $t_next = ($countdown && $dt0 > 1)? (int($t0) + 1): ($t1 + $dt0/2);
  my $dt = $t_next - $t1 + $epsilon;
  $dt = 0 if $dt < 0;

  # Debug message
  printf STDERR "%10.2f - %02d %2.2f %2.2f %2.2f (Δt=%2.2f, ε=%2.2f) > %s\033[K\r",
      $t0, $chinese_hour, $quarter, $centiday, $deciday, $dt, $epsilon,
      join(', ', map { sprintf '%.2f (%+.1f) %s', $_->{'t'}, ($_->{'t'} - $t0), $_->{'id'} } @event) if $verbose_p;

  # Try to compensate for the printf. This actually seems to make things worse
  my $t2 = Time::HiRes::time;
  $epsilon = $t2 - $t1;

  Time::HiRes::sleep $dt;

  # Check if any event should be fired
  my $now = Time::HiRes::time;
  my $dt_actual = $now - $t2;
  printf STDERR "\nWARNING: tried to sleep for %.2f s but slept for %.2f s\n", $dt, $dt_actual if $dt_actual > $dt + 1;
  for my $id (keys %events) {
    my $e = $events{$id};
    my $t = $e->{'t'};
    if ($now >= $t) {
      my $dt = $now - $t;
      printf STDERR "\nEVENT %s (%d) fired at %d (%s)\n", $id, $t, $now, ($dt < 0.01? 'on time': sprintf('%.2f s late', $dt));
      do_event $id;
      $countdown = 0; # force a re-countdown
      delete $events{$id};
    }
  }

  $countdown -= 1;
  $countdown = COUNTDOWN if $countdown < 0;
}

1;
