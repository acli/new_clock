#!/usr/bin/perl
# vi:set sw=2 ai sm:
# Copyright © 2021 by Ambrose Li

=pod

=encoding utf8

=head1 NAME

chimer – Re-implementation of the Javascript chiming clocks in Perl

=head1 DESCRIPTION

The primary purpose of this script is to avoid running the two chiming clock pages as Firefox tabs,
because Firefox (and Chromium-based browsers) are now unfriendly to pages that primarily use audio for UI.
Firefox also leaks memory really fast so it's best to not keep Firefox running for long periods of time.

Eventually this script might provide a way to make the genmon script less CPU intensive.

=head1 INTERNALS

=cut

# see https://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default for these crazy hacks
# THERE ARE MORE CRAZY HACKS THERE FOR MORE COMPLEX PROJECTS!!
use v5.12; # minimal for unicode string feature
use v5.14; # //u modifier
use utf8;
open qw( :encoding(UTF-8) :std );
use charnames qw( :full :short );
use feature "unicode_strings";

use warnings qw( FATAL utf8 );
use Encode qw( encode decode );
#@ARGV = map { decode("UTF-8", $_) } @ARGV if grep /\P{ASCII}/ => @ARGV;


use strict;
use integer;

use POSIX;
use POSIX ":sys_wait_h"; # for nonblocking read
use DateTime;
use Time::HiRes; # overrides (qw) do not seem to work
use Expect::Simple;

use vars qw( @restart_cmd );
@restart_cmd = ($0, @ARGV); # save this because GetOpt will clear @ARGV

use vars qw( $use_datetime_event_sunrise );
use vars qw( $use_datetime_astro_sunrise );
use vars qw( $use_astro_sunrise );
BEGIN {
  if (eval { require DateTime::Event::Sunrise; }) {
    $use_datetime_event_sunrise = 1;
  } elsif (eval { require DateTime::Astro::Sunrise; }) {
    $use_datetime_astro_sunrise = 1;
  } elsif (eval { require Astro::Sunrise; }) {
    $use_astro_sunrise = 1;
  } else {
    die "Cannot find a usable Sunrise package";
  }
}

use Getopt::Long;
use Data::Dumper;

use vars qw( $config );
use vars qw( $debug );
use vars qw( $verbose_p );
use vars qw( $enable_nonproportional_watches );
use vars qw( $enable_qing_quarters );

use vars qw( $coords );
use vars qw( $lat $lon );
use vars qw( @sinks );
use vars qw( $synth );
use vars qw( %children );

use vars qw( $fluidR3 $gong_bank $gong_inst $bell_bank $bell_inst $wood_bank $wood_inst $wood_note );
$fluidR3 = '/usr/share/sounds/sf2/FluidR3_GM.sf2';

use vars qw( $beat_length );
$beat_length = 1;

sub MAX_UPTIME_ALLOWED () { 14400 }

use vars qw( $boottime );
$boottime = Time::HiRes::time;

use vars qw( $basedir $datadir );
$basedir = $1 if $0 =~ /^(.*?)\/+[^\/]+$/;
$basedir =~ s/(?:^|\/+)bin$//;
$basedir = '.' if $basedir eq '';
$datadir = "$basedir/data";

# number of times we try sleeping for 1 second until we sleep until the target event
sub COUNTDOWN () { 5 } # things stablize after 2-3 times, we do 5 just in case (10 is overkill)

sub MODE__SYSLINE   () { 'sysline' }
sub MODE__CUCKOO    () { 'cuckoo' }
sub MODE__CARILLON  () { 'carillon' }
sub METHOD__SAMPLES () { 'samples' }
sub METHOD__SYNTH   () { 'synth' }

sub MELODY__WESTMINSTER () { 'westminster' }
sub MELODY__WHITTINGTON () { 'whittington' }

use vars qw( $mode $method $melody );
$mode   = MODE__CARILLON;
$method = METHOD__SAMPLES;
$melody = MELODY__WESTMINSTER;

# night watch chime patterns
sub LONG_STRIKE  () { 1.5 }
sub SHORT_STRIKE () { 0.5 }
sub GAP          () { 2.5 }
# watch chime patterns: repetitions, pattern
# gap needs to be long enough to hear it, but short enough to not mistake it for a long strike. This is HARD
# but note that w5 is -.... x 5 should fit within 30s of time, so we must have (long + short x 4 + gap) ≤ 6
use vars qw( @watch_chime_pattern );
@watch_chime_pattern = ( # v. https://zh.wikipedia.org/wiki/打更 (q.v.)
   [3, '— .'		],
   [2, '. .'		],
   [3, '— . .'		],
   [4, '— . . .'	],
   [5, '— . . . .'	],
   [1, '—'		],		# test chime X
   [1, '.'		],		# test chime Y
);

use vars qw( @midi_number_to_note %note_to_midi_number );
@midi_number_to_note = (
  'c0', 'c#0', 'd0', 'd#0', 'e0', 'f0', 'f#0', 'g0', 'g#0', 'a0', 'a#0', 'b0',
  'c1', 'c#1', 'd1', 'd#1', 'e1', 'f1', 'f#1', 'g1', 'g#1', 'a1', 'a#1', 'b1',
  'c2', 'c#2', 'd2', 'd#2', 'e2', 'f2', 'f#2', 'g2', 'g#2', 'a2', 'a#2', 'b2',
  'c3', 'c#3', 'd3', 'd#3', 'e3', 'f3', 'f#3', 'g3', 'g#3', 'a3', 'a#3', 'b3',
  'c4', 'c#4', 'd4', 'd#4', 'e4', 'f4', 'f#4', 'g4', 'g#4', 'a4', 'a#4', 'b4',
  'c5', 'c#5', 'd5', 'd#5', 'e5', 'f5', 'f#5', 'g5', 'g#5', 'a5', 'a#5', 'b5',
  'c6', 'c#6', 'd6', 'd#6', 'e6', 'f6', 'f#6', 'g6', 'g#6', 'a6', 'a#6', 'b6',
  'c7', 'c#7', 'd7', 'd#7', 'e7', 'f7', 'f#7', 'g7', 'g#7', 'a7', 'a#7', 'b7',
  'c8', 'c#8', 'd8', 'd#8', 'e8', 'f8', 'f#8', 'g8', 'g#8', 'a8', 'a#8', 'b8',
  'c9', 'c#9', 'd9', 'd#9', 'e9', 'f9', 'f#9', 'g9', 'g#9', 'a9', 'a#9', 'b9',
);
%note_to_midi_number = map { $midi_number_to_note[$_] => $_ } 0..$#midi_number_to_note;

use vars qw( %gong_scale %chime_scale );
%gong_scale = (
  'c4'	=> '582141__strangehorizon__g01-c-4-gong.wav',
  'c#4'	=> '582140__strangehorizon__g02-c-4-gong.wav',
  'd4'	=> '582139__strangehorizon__g03-d-4-gong.wav',
  'd#4'	=> '582138__strangehorizon__g04-d-4-gong.wav',
  'e4'	=> '582145__strangehorizon__g05-e-4-gong.wav',
  'f4'	=> '582144__strangehorizon__g06-f-4-gong.wav',
  'f#4'	=> '582143__strangehorizon__g07-f-4-gong.wav',
  'g4'	=> '582142__strangehorizon__g08-g-4-gong.wav',
  'g#4'	=> '582147__strangehorizon__g09-g-4-gong.wav',
  'a4'	=> '582146__strangehorizon__g10-a-4-gong.wav',
  'a#4'	=> '582156__strangehorizon__g11-a-4-gong.wav',
  'b4'	=> '582155__strangehorizon__g12-b-4-gong.wav',
  'c5'	=> '582154__strangehorizon__g13-c-5-gong.wav',
  'c#5'	=> '582153__strangehorizon__g14-c-5-gong.wav',
  'd5'	=> '582160__strangehorizon__g15-d-5-gong.wav',
  'd#5'	=> '582159__strangehorizon__g16-d-5-gong.wav',
  'e5'	=> '582158__strangehorizon__g17-e-5-gong.wav',
  'f5'	=> '582157__strangehorizon__g18-f-5-gong.wav',
  'f#5'	=> '582162__strangehorizon__g19-f-5-gong.wav',
  'g5'	=> '582161__strangehorizon__g20-g-5-gong.wav',
);
%chime_scale = (
  'c4'	=> 'chimes_C1.ogg',
  'c#4'	=> 'chimes_C#1.ogg',
  'd4'	=> 'chimes_D1.ogg',
  'd#4'	=> 'chimes_D#1.ogg',
  'e4'	=> 'chimes_E1.ogg',
  'f4'	=> 'chimes_F1.ogg',
  'f#4'	=> 'chimes_F#1.ogg',
  'g4'	=> 'chimes_G1.ogg',
  'g#4'	=> 'chimes_G#1.ogg',
  'a4'	=> 'chimes_A1.ogg',
  'a#4'	=> 'chimes_A#1.ogg',
  'b4'	=> 'chimes_B1.ogg',
  'c5'	=> 'chimes_C2.ogg',
  'c#5'	=> 'chimes_C#2.ogg',
  'd5'	=> 'chimes_D2.ogg',
  'd#5'	=> 'chimes_D#2.ogg',
  'e5'	=> 'chimes_E2.ogg',
  'f5'	=> 'chimes_F2.ogg',
);

use vars qw( $strike );
$strike = [
    ['e3', 2], # both Wikipedia and clockguy say this should be a 4, but that would make h12 last 48 seconds, which isn't good
  ];

use vars qw( $last_logged );
sub log_internal ($$;$$$) {
  my($flag, $s, $prefix, $newline_p, $keep_p) = @_;
  $newline_p = 1 if $s =~ s/^\n+//s;
  $newline_p = 0 unless defined $last_logged;
  $newline_p = 1 if defined $last_logged && $last_logged->{'keep'};
  $keep_p = 1 if $debug;
  $prefix .= ': ' if defined $prefix && $prefix =~ /\S/s && $prefix !~ /: $/s;
  chomp $s;
  printf STDERR "%s%10.2f%s\t%s%s%s%s", ($newline_p? "\n": ''),
      Time::HiRes::time, $flag, $prefix, $s, ($newline_p? '': "\033[K"), "\r";

  $last_logged->{'keep'} = $keep_p + 0;
}

sub log_output  ($) { log_internal '>', $_[0] }
sub log_comment ($) { log_internal '#', $_[0] }
sub log_debug   ($) { log_internal '#', $_[0], 'DEBUG', 1, 1 }
sub log_info    ($) { log_internal '#', $_[0], undef,   0, 1 }
sub log_error   ($) { log_internal '#', $_[0], 'ERROR', 1, 1 }
sub log_warning ($) { log_internal '#', $_[0], 'WARNING', 1, 1 }


=pod

=head2 Chime melodies

Each chime melody is internally represented as an array of
B<[>I<midi note name>, I<time in seconds>B<]> entries,
but written as calls to I<interpret_quarters> which takes 6 parameters:
the length of a beat in seconds, first quarter, second quarter, third quarter, fourth quarter,
definitions for the quarters.

As many definitions as needed can be included, but each definition I<must> be of the form

=over

I<var> = B<\relative> I<pitch> B<{> I<melody> B<}>

=back

I<melody> is written in LilyPond notation, described in

=over

Relative Octave Entry. (n.d.). In I<LilyPond — Notation Reference v2.22.1 (stable-branch)>.
Retrieved August 18, 2021, from http://lilypond.org/doc/v2.22/Documentation/notation/writing-pitches#relative-octave-entry

=back

I<interpret_quarters> calls I<interpret_melody> to convert this notation into the internal representation described above,
but this conversion is just a simple pattern match and therefore can produce incorrect results.
If results are incorrect but the notation typesets correctly in LilyPond, the bug is in I<interpret_melody>.

=cut

use vars qw( %ly_notes );
%ly_notes = (
  'ces' => -1, 'c' => 0, 'cis' => 1,
  'des' => 1, 'd' => 2, 'dis' => 3,
  'ees' => 3, 'e' => 4, 'eis' => 5,
  'fes' => 4, 'f' => 5, 'fis' => 6,
  'ges' => 6, 'g' => 7, 'gis' => 8,
  'aes' => 8, 'a' => 9, 'ais' => 10,
  'bes' => 10, 'b' => 11, 'bis' => 12,
);
sub interpret_absolute_pitch ($) { # interpret c' as c4
  my($s) = @_;
  my $it;
  if ($s =~ /^(\w+)(?:(,*)|('*))$/) {
    $it = $ly_notes{$1} + 12*(3 - length($2) + length($3));
  } else {
    die "Can't interpret absolute pitch \"$s\"";
  }
  return $it;
}
sub interpret_melody ($$) {
  my($s, $unit_beat) = @_;
  my $it;
  # NOTE: GetOpt hasn't been called yet so if you need $debug you need to set it here by hand
  my $note_re = q(([a-g](?:[ei]s)?|r)(?:(,*)|('*))(?:(\d+)(\.+)?)?); # NOTE: 5 captures - pitch commas apostrophes divisor dots
  $s =~ s/^\s*\\relative\s*\{\s*$note_re(.*?)\s*\}\s*$/\\relative \1\2\3\4\5 { \1\4\5 \6 }/s;
  die unless $s =~ /^\s*\\relative\s+(\S+?)\s+\{\s*(.*?)\s*\}\s*$/s;
  ($s, my $start_pitch_as_written) = ($2, $1);
  my $starting_pitch = interpret_absolute_pitch $start_pitch_as_written;
  my $last_pitch = $starting_pitch;
  my($divisor, $dots) = (4);
  for my $note (split(/[\s<>\(\)\[\]\|]+/, $s)) {
    if ($note =~ /^$note_re$/) {
      my($base_pitch, $lower, $raise, $new_divisor, $new_dots) = (($ly_notes{$1} + 12)%12, 0 + length $2, 0 + length $3, $4, $5);
      my $last_base_pitch = ($last_pitch + 12)%12;
      no integer;
      ($divisor, $dots) = ($new_divisor, $new_dots) if defined $new_divisor;
      log_debug "note=$note -> divisor=$divisor" if $debug > 1;
      my $tentative;
      for (my $i = 0; $i < 8; $i += 1) {
	for my $dir (-1, 1) {
	  my $candidate = $last_pitch + $dir*$i;
	  $tentative = $candidate if $candidate%12 == $base_pitch;
	last if defined $tentative;
	}
      last if defined $tentative;
      }
      my $pitch = $tentative + 12*($raise - $lower);
      my $lhs = $note =~ /^r/? 'r': $midi_number_to_note[$pitch];
      my $rhs = $unit_beat * 4 / $divisor;
      for (my $i = length $dots, my $adj = $rhs/2; $i; $i -= 1, $adj /= 2) {
	$rhs += $adj;
      }
      push @$it, [$lhs, $rhs];
      $last_pitch = $pitch;
    }
  }
  log_debug sprintf "\\relative %s { %s } interpreted as %s", $start_pitch_as_written, $s,
      join(' ', map { $_->[0] . ($_->[1] == $unit_beat? '': sprintf('(%s)', $_->[1]/$unit_beat)) } @$it) if $debug;
  return $it;
}
sub interpret_quarters ($$$$$@) {
  my($beat_length, $q1_spec, $q2_spec, $q3_spec, $q4_spec, @elements) = @_;
  my $it;
  my %elements = map { /^\s*(\S+?)\s*=\s*(.*)$/s? ($1 => interpret_melody $2, $beat_length): () } @elements;
  for my $spec ($q4_spec, $q1_spec, $q2_spec, $q3_spec) {
    my @node;
    for my $ref (split(/\s*/, $spec)) {
      die "interpret_quarters: $spec: Unknown reference $ref\n" unless defined $elements{$ref};
      push @node, @{$elements{$ref}};
    }
    push @$it, [@node];
  }
  return $it;
}

use vars qw( %melody );
%melody = (
  &MELODY__WESTMINSTER => interpret_quarters(1, 'A', 'BC', 'DEA', 'BCDE',
      q( A = \relative e' { gis4 fis e b2  }),
      q( B = \relative e' { e4 gis fis b,2 }),
      q( C = \relative e' { e4 fis gis e2  }),
      q( D = \relative e' { gis4 e fis b,2 }),
      q( E = \relative e' { b4 fis' gis e2 })),
  &MELODY__WHITTINGTON => interpret_quarters(0.5, 'E', 'AB', 'CDE', 'ABCD',
      q( A = \relative e' { e'4 fis, dis' gis, cis a b e, }),
      q( B = \relative e' { e'4 cis a fis dis' b gis e    }),
      q( C = \relative e' { e'4 dis a gis cis b fis e     }),
      q( D = \relative e' { fis4 a cis e dis b gis e      }),
      q( E = \relative e' { e'4 dis cis b a gis fis e     })),
);
$melody{'cambridge'} = $melody{&MELODY__WESTMINSTER};
$melody{'st mary'} = $melody{&MELODY__WHITTINGTON};



sub start_of_day ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  return mktime(0, 0, 0, $mday, $mon, $year);
}

sub yesterday ($) {
  my($t) = @_;
  return start_of_day(start_of_day($t) - 12*3600);
}

sub tomorrow ($) {
  my($t) = @_;
  return start_of_day(start_of_day($t) + 36*3600);
}

sub estimate_sunrise ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->start;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[0];
    $it = $tmp->strftime('%s');
  } else {
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunrise;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub estimate_sunset ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->end;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[1];
    $it = $tmp->strftime('%s');
  } else {
    # this should be the same as the else case in estimate_sunrise except the last line
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunset;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub trim ($) {
  my($s) = @_;
  $s =~ s/^\s+//;
  $s =~ s/\s+$//;
  return $s;
}

sub guess_city () {
  my $input = '/etc/localtime';
  my $det = readlink $input;
  die "$input: $!\n" unless defined $det;
  return $1 if $det =~ /([^\/]+)$/s;
}

sub guess_coordinates () {
  my $it;
  my $city = guess_city;
  log_comment "guessed city=($city)" if $debug;
  my @cmd = qw(hebcal cities);
  log_comment 'DEBUG: running: '. join(' ', @cmd) if $debug;
  my $pid = open(INPUT, '-|');
  die "$0: guess_coordinates: $cmd[0]: fork: $!\n" unless defined $pid;
  if ($pid) {
    my $re = quotemeta $city;
    for (;;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp;
      if ($s =~ /^$re \((\d+)d(\d+)' ([NS]) lat, (\d+)d(\d+)' ([EW]) long/) {
	no integer;
	$it = {
	      'lat' => ($1 + $2/60)*($3 eq 'N'? 1: -1),
	      'lon' => ($4 + $5/60)*($6 eq 'E'? 1: -1),
	    };
      }
    last if defined $it;
    }
    close INPUT;
  } else {
    exec {$cmd[0]} @cmd;
    die "$0: guess_coordinates: $cmd[0]: exec: $!\n";
  }
  return $it;
}

# NOTE: modified to act like the current PHP version (root section goes to /, duplicate keys allowed and get stashed into an array)
sub read_ini ($) {
  my($input) = @_;
  my $it;
  local(*INPUT, $.);
  if (open(INPUT, '<:utf8', $input)) {
    for (my $section = '/';;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp $s;
      if ($s =~ /^\s*(?:[#\%;]|$)/) {
	;
      } elsif ($s =~ /^\s*\[\s*([^\[\]]+?)\s*\]\s*$/) {
	$section = $1;
      } elsif ($s =~ /^\s*([^=]+?)\s*=\s*(.*)/) {
	if (defined $section) {
	  $it->{$section}->{$1} = [] unless defined $it->{$section}->{$1};
	  push @{$it->{$section}->{$1}}, $2;
	} else {
	  $it->{$1} = [] unless defined $it->{$1};
	  push @{$it->{$1}}, $2;
	}
      } else {
	warn "$input:$.: Warning: Unknown input \"$s\"\n";
      }
    }
    close INPUT;
  }
  return $it;
}

use vars qw( $deciday_1_re $deciday_2_re $deciday_3_re $deciday_4_re $deciday_5_re );
use vars qw( $deciday_6_re $deciday_7_re $deciday_8_re $deciday_9_re $deciday_10_re );
use vars qw( $clocktime_re $deciday_re );
$clocktime_re = '(?:(?:0?\d|1\d|2[0-3]):[0-5]\d|24:00)';
$deciday_1_re = '\b(?:morning|ˈ?dziu)\b';
$deciday_2_re = '\b(?:forenoon|ˌ?jy)\b';
$deciday_3_re = '\b(?:midday|ˈ?dzuŋ)\b';
$deciday_4_re = '\b(?:afternoon|ˈbou)\b';
$deciday_5_re = '\b(?:evening|ˍdzik)\b';
$deciday_6_re = '\b(?:A|ˉ?gap)\b';
$deciday_7_re = '\b(?:B|ˍ?jyt)\b';
$deciday_8_re = '\b(?:C|ˊ?biŋ)\b';
$deciday_9_re = '\b(?:D|ˈ?diŋ)\b';
$deciday_10_re = '\b(?:E|ˍ?mou)\b';
$deciday_re = "(?:$deciday_1_re|$deciday_2_re|$deciday_3_re|$deciday_4_re|$deciday_5_re|$deciday_6_re|$deciday_7_re|$deciday_8_re|$deciday_9_re|$deciday_10_re)";

use vars qw( $sun_re $mon_re $tue_re $wed_re $thu_re $fri_re $sat_re $dow_re $dow_range_re );
$sun_re = '(?:\b(?:U|Sun(?:day)?)\b)';
$mon_re = '(?:\b(?:M|Mon(?:day)?)\b)';
$tue_re = '(?:\b(?:T|Tue(?:s(?:day)?)?)\b)';
$wed_re = '(?:\b(?:W|Wed(?:nes(?:day)?)?)\b)';
$thu_re = '(?:\b(?:R|Thu(?:r(?:s(?:day)?)?)?)\b)';
$fri_re = '(?:\b(?:F|Fri(?:day)?)\b)';
$sat_re = '(?:\b(?:S|Sat(?:urday)?)\b)';
$dow_re = "(?:$sun_re|$mon_re|$tue_re|$wed_re|$thu_re|$fri_re|$sat_re)";
$dow_range_re = "(?:[UMTWRFS]+|(?:$dow_re(?:\\s*[-,]\\s*$dow_re)*))";

sub parse_dow ($) {
  my($s) = @_;
  local($`, $&, $');
  return $s =~ /^$sun_re$/? 0:
	 $s =~ /^$mon_re$/? 1:
	 $s =~ /^$tue_re$/? 2:
	 $s =~ /^$wed_re$/? 3:
	 $s =~ /^$thu_re$/? 4:
	 $s =~ /^$fri_re$/? 5:
	 $s =~ /^$sat_re$/? 6: undef;
}


sub parse_clocktime ($) {
  my($s) = @_;
  local($`, $&, $', $1, $2);
  no integer;
  return $s =~ /^(?=$clocktime_re$)(\d+):(\d\d)/? $1 + $2/60: undef;
}

sub parse_named_deciday ($) {
  my($s) = @_;
  local($`, $&, $', $1, $2);
  no integer;
  return $s =~ /^$deciday_1_re$/? 1:
	 $s =~ /^$deciday_2_re$/? 2:
	 $s =~ /^$deciday_3_re$/? 3:
	 $s =~ /^$deciday_4_re$/? 4:
	 $s =~ /^$deciday_5_re$/? 5:
	 $s =~ /^$deciday_6_re$/? 6:
	 $s =~ /^$deciday_7_re$/? 7:
	 $s =~ /^$deciday_8_re$/? 8:
	 $s =~ /^$deciday_9_re$/? 9:
	 $s =~ /^$deciday_10_re$/? 10: undef
}

sub parse_dow_range ($) {
  my($s) = @_;
  my $it;
  if (defined $s) {
    local($`, $&, $', $1, $2);
    if ($s =~ /^[UMTWRFS]+$/) { # Waterloo style single-letter codes
      $it = join(',', map { parse_dow($_) } split(//, $s));
    } else {
      $it = join('', map { substr($_, 0, 1) =~ /[-,]/? (substr($_, 0, 1) . parse_dow(substr($_, 1))): parse_dow($_) } split(/(?=[-,]|$)/, $s));
      $it = 'ERROR' unless $it =~ /^\d+(?:[-,]\d+)*$/;

      # Handle looparounds like Fri-Sun or Sat-Tue
      $it =~ s/\b([1-6])-([1-6])\b/ $1 < $2? $&: "$1-6,0-$2" /ge;
      $it =~ s/\b(?<!-)([1-5])-0\b/\1-6,0/g;
      $it =~ s/\b(?<!-)(6)-0\b/\1,0/g;
    }
  }
  return $it;
}

sub parse_clocktime_range ($) {
  my($s) = @_;
  my $it;
  if (defined $s) {
    local($`, $&, $', $1, $2);
    $it = join('', map { substr($_, 0, 1) =~ /[-,]/? (substr($_, 0, 1) . parse_clocktime(substr($_, 1))): parse_clocktime($_) } split(/(?=[-,]|$)/, $s));
    $it = 'ERROR' unless $it =~ /^\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*$/;

    # Handle looparounds like 23:00-07:00
    no integer;
    $it =~ s/\b(\d+(?:.\d+)?)-(0)\b/ $1 < $2? $&: "$1-24" /ge;
    $it =~ s/\b(\d+(?:.\d+)?)-(\d+(?:.\d+)?)\b/ $1 < $2? $&: "$1-24,0-$2" /ge;
  }
  return $it;
}

sub parse_named_deciday_range ($) {
  my($s) = @_;
  my $it;
  if (defined $s) {
    local($`, $&, $', $1, $2);
    $it = join('', map { substr($_, 0, 1) =~ /[-,]/? (substr($_, 0, 1) . parse_named_deciday(substr($_, 1))): parse_named_deciday($_) } split(/(?=[-,]|$)/, $s));
    $it = 'ERROR' unless $it =~ /^\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*$/;

    # Handle looparounds like C-morning
    no integer;
    $it =~ s/\b(\d+)-(1)\b/ $1 < $2? $&: "$1-10,1" /ge;
    $it =~ s/\b(\d+)-(\d+)\b/ $1 < $2? $&: "$1-10,1-$2" /ge;
  }
  return $it;
}


# Quarters are weird. See https://zh.wikipedia.org/wiki/%E5%88%BB
#                     and http://yywz.snnu.edu.cn/show.aspx?id=697&cid=26
# Apparently the old Chinese system also used proportional hours... so we'll need to refactor things here at some point
# http://www.twword.com/wiki/%E5%B9%B2%E6%94%AF%E7%B4%80%E6%B3%95
sub determine_chinese_time ($) {
  my($t) = @_;
  my $it;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $midnight = start_of_day $t;
  my $deciday;
  my $slice; # size of proportional hour, needed to figure out when to sound the next chime
  # NOTE: according to one source (forgot which), the first hour (ˊdzi) spans [2300, 0100) but the new day still starts at 0000. Very odd :-/
  # therefore the old adjustment for [2300, 0000) has been deleted
  if (defined $coords) {
    my $today = start_of_day $t;
    my $yesterday = yesterday $t;
    my $tomorrow = tomorrow $t;
    my($daybreak, $slice_start, $slice_end, $starting_hour);
    # Proportional hour is used in a very early system (Spring and Autumn Period / Warring States),
    # but I don't even have an idea when the day starts (probably day before night) so we'll arbitrarily use sunrise as cutoff
    if ($t < estimate_sunrise($today)) {
      $daybreak = estimate_sunrise($yesterday);
      $slice_start = estimate_sunset($yesterday);
      $slice_end = estimate_sunrise($today);
      $starting_hour = 6;
    } elsif ($t < estimate_sunset($today)) {
      $daybreak = estimate_sunrise($today);
      $slice_start = $daybreak;
      $slice_end = estimate_sunset($today);
      $starting_hour = 1;
    } else {
      $daybreak = estimate_sunrise($today);
      $slice_start = estimate_sunset($today);
      $slice_end = estimate_sunrise($tomorrow);
      $starting_hour = 6;
    }
    if ($slice_start && $slice_end) {
      no integer;
      $slice = ($slice_end - $slice_start)/5;
      $deciday = $starting_hour + ($t - $slice_start)/$slice;
    }
  }
  my($greg_year, $greg_month, $greg_day) = ($year + 1900, $mon + 1, $mday);
  my $relative_chinese_hour = eval { no integer; fmod(($t - ($midnight - 3600))/7200, 12) };
  my $chinese_hour = $relative_chinese_hour + 1;
  my $quarter;
  my $centiday = eval { no integer; ($t - $midnight)/864 };
  if ($enable_qing_quarters) {
    $quarter = $min/15 + 1;
    $quarter += 4 if $hour%2 == 0;
  } else {
    # NOTE: traditionally these aren't quarters, but number of centiday marks past the beginning of the hour
    no integer;
    #
    # 0.5 hours maps exactly to 0 centidays. So to calculate the reporting origin, which is fractional.
    # Each hour is 86400/12 seconds, each centiday is 86400/100 seconds, so each hour is 100/12 centidays
    # In theory, each zero-based hour h begins exactly at ⌊h - 0.5⌋*100/12 centidays
    # However, when h ∈ [0, 0.5) this gives unexpected results because the formula will give a negative result
    # There's no easy way to fix this because reporting origins are hour-aligned, not half-hour aligned
    # (so we can't even change ⌊h - 0.5⌋ to (⌊h*2 - 1⌋%24)/2 because this breaks for h > 1.0)
    #
    my $reporting_origin = POSIX::floor(($relative_chinese_hour < 0.5? 11.5: (int($relative_chinese_hour) - 0.5)) * 100 / 12);
    log_debug "relative_chinese_hour=$relative_chinese_hour => reporting_origin=$reporting_origin" if $debug;
    $quarter = $centiday - int($reporting_origin);
  }
  $it = [undef, undef, undef, undef, $chinese_hour, $quarter, $centiday, $deciday,
      $wday, eval { no integer; $relative_chinese_hour < 0.5 }, $slice];
  return $it;
}

sub determine_events ($$$$$$$$$) {
  my($t0, $hour, $min, $sec, $chinese_hour, $quarter, $centiday, $deciday, $deciday_size) = @_;
  my @it;
  no integer;
  my $global_delay = $config->{'/'}->{'delay'}->[0] if defined $config->{'/'}->{'delay'};
  $global_delay = 0 unless defined $global_delay;

  # Western quarter-hour chime
  # Make absolutely sure we have a chime event, in case it gets thrown out because we're too close to the actual next quarter hour
  my $seconds_since_hour_change = 60*$min + $sec;
  my $t_next_quarter_chime = int($t0) + (900 - $seconds_since_hour_change%900) + $global_delay;
  my $next_quarter = (int($seconds_since_hour_change / 900) + 1)%4;
  my $next_hour = (($next_quarter? $hour: $hour + 1) + 11)%12 + 1;
  my $quarter_chime_event_pushed_p = 0;
  die "Calculation error, next quarter $t_next_quarter_chime is in the past (t0=$t0)" if $t_next_quarter_chime < int($t0);
  die "Calculation error, next quarter $t_next_quarter_chime more than 15 minutes away (t0=$t0)" if $t_next_quarter_chime - $t0 > 900;
  for (my $i = 0; $i < 2; $i += 1,
			  $t_next_quarter_chime += 900,
			  $next_quarter = ($next_quarter + 1)%4,
			  $next_hour += !$next_quarter, $next_hour = ($next_hour - 1)%12 + 1) {
    my $prechime_length;
    if ($next_quarter == 0) {
      push @it, {
	't' => $t_next_quarter_chime,
	'id' => "h$next_hour",
	'type' => 'hour',
	'comment' => "hour $next_hour chime",
      };
      $prechime_length = 25;
    } elsif ($next_quarter == 1) {
      $prechime_length = 5;
    } elsif ($next_quarter == 2) {
      $prechime_length = 10;
    } elsif ($next_quarter == 3) {
      $prechime_length = 15;
    }
    if ($t_next_quarter_chime - $prechime_length >= $t0) {
      push @it, {
	't' => $t_next_quarter_chime - $prechime_length,
	'id' => "q$next_quarter",
	'type' => 'quarter',
	'comment' => "hour $next_hour quarter $next_quarter prechime",
	'anticipating' => $prechime_length,
      };
      $quarter_chime_event_pushed_p = 1;
    }
  last if $quarter_chime_event_pushed_p;
  }

  # Spring-and-Autumn-era proportional-deciday-based night watch chimes
  # 1 watch is exactly 1 deciday, which is not actually 1/10 of a day but 1/5 of the current proportional moitie
  if ($deciday > 5 && $deciday < 6) { # 5 is the last deciday in the "day" moitie
    my $t_first_watch = $t0 + (6 - $deciday)*$deciday_size;
    push @it, {
      't' => $t_first_watch,
      'id' => 'w1.1',
      'type' => 'watch',
      'comment' => 'watch 1',
    };
  } elsif ($deciday >= 6) {
    my $decidays_into_the_night = $deciday - 6;
    my $subwatches_into_the_night = 5*$decidays_into_the_night;
    my $zero_based_next_subwatch = (int($subwatches_into_the_night) + 1)%25;
    if ($zero_based_next_subwatch) {
      my $next_watch = int($zero_based_next_subwatch/5) + 1;
      my $next_subwatch = $zero_based_next_subwatch%5 + 1;
      my $t_next_subwatch = $t0 + (1 - fmod($subwatches_into_the_night, 1)) * ($deciday_size/5) + $global_delay;
      push @it, {
	't' => $t_next_subwatch,
	'id' => "w$next_watch.$next_subwatch",
	'type' => 'watch',
	'comment' => "watch $next_watch.$next_subwatch",
      };
      # Check if we should delay this because it would run into the middle of a quarter hour chime
      my $delay = 0;
      for my $event (@it) {
	my $t = $event->{'t'};
	if ($event->{'id'} =~ /^[qh]/ && (($t - 30 <= $t_next_subwatch + $delay && $t_next_subwatch + $delay <= $t)
				      || ($t <= $t_next_subwatch + $delay && $t_next_subwatch + $delay <= $t + 30))) {
	  $delay = ($t + 30) - $t_next_subwatch;
	  $it[$#it]->{'delay'} = $delay;
	}
      }
    }
  }

  @it = sort { $a->{'t'} <=> $b->{'t'} } @it;
  return wantarray? @it: \@it;
}

sub in_range ($$) {
  my($n, $range_spec) = @_;
  my $it = 0;
  no integer;
  for my $subrange_spec (split(/\s*,\s*/, $range_spec)) {
    die "in_range: Malformed element \"$subrange_spec\" in \"$range_spec\"" unless $subrange_spec =~ /^(\d+(?:\.\d+)?)(?:-(\d+(?:\.\d+)?))?$/;
    if (defined $2) {
      $it = $1 <= $n && $n <= $2;
    } else {
      $it = $1 == $n;
    }
  last if $it;
  }
  return $it;
}

sub in_semi_closed_range ($$) {
  my($n, $range_spec) = @_;
  my $it = 0;
  no integer;
  for my $subrange_spec (split(/\s*,\s*/, $range_spec)) {
    die "in_range: Malformed element \"$subrange_spec\" in \"$range_spec\"" unless $subrange_spec =~ /^(\d+(?:\.\d+)?)(?:-(\d+(?:\.\d+)?))?$/;
    if (defined $2) {
      $it = $1 <= $n && $n < $2;
    } else {
      $it = $1 == $n;
    }
  last if $it;
  }
  return $it;
}

sub get_sink () {
  return $ENV{'PULSE_SINK'};
}

sub set_sink ($) {
  my($sink) = @_;
  $ENV{'PULSE_SINK'} = $sink if defined $sink;
}

sub set_test_params () {
  @sinks = @{$config->{'test'}->{'sink'}} if defined $config->{'test'}->{'sink'};
  $mode = $config->{'test'}->{'mode'}->[0] if defined $config->{'test'}->{'mode'};
  $method = $config->{'test'}->{'method'}->[0] if defined $config->{'test'}->{'method'};
  $melody = lc $config->{'test'}->{'melody'}->[0] if defined $config->{'test'}->{'melody'};
  log_debug sprintf "test params set at %.2f: mode=%s, method=%s, melody=%s", $boottime, $mode, $method, $melody if $verbose_p || $debug;
}

sub set_sink_volume ($$) {
  my($sink, $volume) = @_;
  my @cmd = ('pactl', 'set-sink-volume', $sink, int($volume));
  log_debug 'running: '. join(' ', @cmd) if $debug;
  system { $cmd[0] } @cmd;
}

sub determine_volume_from_directive_and_time ($$$$$$) {
  my($directive, $hour, $min, $sec, $deciday, $wday) = @_;
  my($target_dow, $target_times, $target_volume, $dow_in_range_p, $time_in_range_p);
  my($result, $error);
  no integer;
  if ($directive =~ /^(?:($dow_range_re)\s+)?hours?\s+(\d+(?:[-,]\d+)*)\s*[:=]\s*(\d+(?:\.\d+)?)$/) {		# integer to integer
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range($hour, $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?hours?\s+(\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*)\s*[:=]\s*(\d+(?:\.\d+)?)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range($hour + $min/60 + $sec/3600, $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?decidays?\s+(\d+(?:[-,]\d+)*)\s*[:=]\s*(\d+(?:\.\d+)?)$/) {	# integer to integer
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range(int($deciday), $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?decidays?\s+(\d+(?:\.\d+)?(?:[-,]\d+(?:\.\d+)?)*)\s*[:=]\s*(\d+(?:\.\d+)?)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range($deciday, $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?($clocktime_re-$clocktime_re)\s*[:=]\s*(\d+(?:\.\d+)?)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_semi_closed_range($hour + $min/60 * $sec/3600, parse_clocktime_range $target_times);
  } elsif ($directive =~ /^(?:($dow_range_re)\s+)?($deciday_re(?:\s*-\s*$deciday_re)?)\s*[:=]\s*(\d+(?:\.\d+)?)$/) {
    ($target_dow, $target_times, $target_volume) = ($1, $2, $3);
    $time_in_range_p = in_range(int($deciday), parse_named_deciday_range $target_times);
  } elsif ($directive =~ /^\d+(?:\.\d+)?$/) {	# just a number
    ($target_dow, $time_in_range_p, $target_volume) = (undef, 1, $directive);
  } else {
    $error = "unrecognized directive \"$directive\"";
  }
  $dow_in_range_p = !defined $target_dow || in_range($wday, parse_dow_range($target_dow)) if !defined $error;
  if (defined $error || !$dow_in_range_p || !defined $time_in_range_p || !$time_in_range_p) {
    ;
  } elsif ($target_volume >= 0 && $target_volume <= 1) {
    $result = $target_volume;
  } else {
    $error = "out of range volume $target_volume";
  }
  return wantarray? ($result, $error): [$result, $error];
}

sub set_sink_volumes ($$$$$) {
  my($hour, $min, $sec, $deciday, $wday) = @_;
  for my $sink (@sinks) {
    my $label = defined $config->{$sink} && defined $config->{$sink}->{'label'}? $config->{$sink}->{'label'}->[0]: "sink $sink";
    no integer;
    my $adj;
    my $reason;
    if (defined $config->{$sink} && defined $config->{$sink}->{'volume'}) {
      for my $directive (map { split /(?:^|(?<=\d))\s*,\s*/ } @{$config->{$sink}->{'volume'}}) {
	my($candidate_adj, $error) = determine_volume_from_directive_and_time($directive, $hour, $min, $sec, $deciday, $wday);
	($adj, $reason) = ($candidate_adj, "because of volume rule \"$directive\"") if defined $candidate_adj;
	log_error "CONFIG ERROR: $error in [$sink] volumes" if defined $error;
      last if defined $adj;
      }
      $adj = 1.0 unless defined $adj;
    } else {
      # Default adjustment for "night"
      $adj = 1.0;
      $adj *= 0.9 if $deciday < 1 || $deciday > 5;
      $adj *= 0.9 if $hour < 9 || $hour > 8;
    }
    $reason = 'by default' if defined $adj && !defined $reason;
    log_comment "Volume adjusted to $adj for $label $reason" if $debug || $verbose_p;
    set_sink_volume $sink, 65535 * $adj;
  }
}

sub get_cache_pathname_for_event ($) {
  my($id) = @_;
  my $it = "data/cache-"; # FIXME
  die "get_cache_pathname_for_event: Internal error: $mode: Illegal mode" unless $mode =~ /^[-\.\w]+$/s;
  die "get_cache_pathname_for_event: $id: Illegal event id" unless $id =~ /^[-\.\w]+$/s;
  $id =~ s/^(w\d)\.\d$/\1/sg; # we don't really distinguish between subwatches
  $it .= "$mode-" unless $id =~ /^w/;
  $it .= "\L$melody-" if $id =~ /^q/ && $mode eq MODE__CARILLON;
  $it .= "$id.oga";
  return $it;
}

sub send_midi_command ($) {
  my($cmd) = @_;
  log_output $cmd if $debug || $verbose_p;
  $synth->send($cmd);
}

sub probe_synth_instruments () {
  send_midi_command('inst 1');
  my @instruments = $synth->before;
  my %instruments = map { /^(\d+)-(\d+)\s+(.*)$/s? ($3 => [$1 + 0, $2 + 0], "$1-$2" => $3): () } split(/\r?\n/, $synth->before);
  return wantarray? %instruments: \%instruments;
}

sub find_synth_instrument ($@) {
  my($instruments, @preferences) = @_;
  my $it;
  for my $candidate (@preferences) {
    $it = $instruments->{$candidate} if defined $instruments->{$candidate};
  last if defined $it;
  }
  return $it;
}

sub synth_instrument_name ($$) {
  my($instruments, $instrument) = @_;
  my $id = sprintf('%03d-%03d', $instrument->[0], $instrument->[1]);
  return $instruments->{$id};
}

sub connect_synth ($) {
  my($id) = @_;
  my $output = get_cache_pathname_for_event($id);
  my($sf_path, $gain, $delay);

  # Figure out where our soundfont is
  for my $key ('Timbres Of Heaven', 'FluidR3') {
    if (defined $config->{'/'}->{$key}) {
      foreach my $candidate (@{$config->{'/'}->{$key}}) {
	$sf_path = $candidate if -f $candidate;
      last if defined $sf_path;
      }
    }
    if (defined $sf_path && $key eq 'Timbres Of Heaven') {
      $gain = 0.18; # even default gain (0.2) feels too loud for a chiming clock
      $delay = 3.5;
    }
  last if defined $sf_path;
  }
  $sf_path = $fluidR3 if !defined $sf_path; # hmm hope this works
  $gain = 1 if !defined $gain;
  $delay = 1 if !defined $delay;

  log_comment "Connecting synth for write to $output" if $debug || $verbose_p;
  my @cmd = ('fluidsynth', '-a', 'file',
			   '-g', $gain,
			   '-o', "audio.file.name=$output",
			   '--midi-channels', '3',
			   $sf_path);

  log_debug 'running: '. join(' ', @cmd) if $debug;
  $synth = new Expect::Simple({
      'Cmd' => \@cmd,
      'Prompt' => "\n> ",
      'DisconnectCmd' => 'quit',
    });

  # Figure out what instruments to use
  my $instruments = probe_synth_instruments;
  my $gong = find_synth_instrument($instruments, 'Gong!!!', 'Tubular Bells');
  my $bell = find_synth_instrument($instruments, 'Carillon', 'Tubular Bells');
  my $wood = find_synth_instrument($instruments, 'Woodblock', 'Orchestra Kit');
  ($gong_bank, $gong_inst) = @$gong;
  ($bell_bank, $bell_inst) = @$bell;
  ($wood_bank, $wood_inst) = @$wood;
  $wood_note = synth_instrument_name($instruments, $wood) =~ / Kit\b/? 31: $note_to_midi_number{'d#5'};
  send_midi_command "select 0 1 $gong_bank $gong_inst";
  send_midi_command "select 1 1 $bell_bank $bell_inst";
  send_midi_command "select 2 1 $wood_bank $wood_inst";
  return;
}

sub disconnect_synth () {
  sleep 6;					# FIXME wait a bit for things to stabilize
  $synth = undef;
}

sub generate_sound_clip_for_event ($) {
  my($event_id) = @_;
  my $output = get_cache_pathname_for_event($event_id);
  if (!-f $output) {
    log_info "Generating audio for event $event_id";
    local @sinks;
    connect_synth $event_id;
    if ($event_id =~ /^h(\d+)$/) {
      announce_hour($1);
    } elsif ($event_id =~ /^q(\d+)$/) {
      announce_quarter_hour($1);
    } elsif ($event_id =~ /^w(\d+)\.(\d+)$/) {
      announce_night_watch($1, $2);
    } else {
      disconnect_synth;
      die "generate_sound_clips: $event_id: Unknown event id\n";
    }
    disconnect_synth;
  }
}

sub generate_sound_clips () {
  for my $event_id (
    (map { my $n = $_; map { "w$n.$_" } 1..5 } 1..5),		# night watches
    (map { "q$_" } 0..3),					# quarterly chimes
    (map { "h$_" } 1..12),					# hourly chimes
  ) {
    generate_sound_clip_for_event $event_id;
  }
}

sub play_sound_file_real ($;$$$) {
  my($input, $volume, $start, $end) = @_;
  my $sink = get_sink;
  my @exts = ('wav', 'mp3', 'ogg', 'oga', 'flac');
  my $ext_re = sprintf('(?:%s)', join('|', @exts));

  # Find a playable file
  for my $ext (@exts) {
  last if -f $input;
    $input = "$1.ext" if !-f $input && $input =~ /^(.*?)\.$ext_re$/ && -f "$1.ext";
  }

  # Fork and play it in the background
  my @cmd = ('mpv', '--audio-client-name', 'Chiming clock', '--no-video', '--really-quiet', '--input-terminal', 'no', '--volume', $volume);
  push @cmd, ('--start', $start) if defined $start;
  push @cmd, ('--end', $end) if defined $end;
  push @cmd, ("--ao=pulse::$sink") if $sink;
  push @cmd, $input;
  log_debug 'running: '. join(' ', @cmd) if $debug;
  my $h = fork;
  die "$cmd[0]: fork: $!\n" unless defined $h;
  if ($h == 0) {
    my $sink = get_sink;
    my $dt = $config->{$sink}->{'delay'}->[0] if defined $config->{$sink} && defined $config->{$sink}->{'delay'};
    Time::HiRes::sleep $dt if $dt > 0;
    POSIX::close(0);
    exec { $cmd[0] } @cmd;
    die "$cmd[0]: exec: $!\n";
  }
  $children{$h} = 1;
}

sub play_sound_file ($;$$$) {
  my($input, $volume, $start, $end) = @_;
  $volume = 50 unless defined $volume;
  if (@sinks) {
    for my $sink (@sinks) {
      log_debug "set sink $sink" if $debug;
      set_sink $sink;
      play_sound_file_real($input, $volume, $start, $end);
    }
  } else {
    play_sound_file_real($input, $volume, $start, $end);
  }
}

sub strike_gong (;$) {
  my($note) = @_;
  if ($note ne 'r') {
    $note = 'd#5' if !defined $note || !defined $gong_scale{$note};
    if ($method eq METHOD__SYNTH) {
      send_midi_command sprintf('noteon 0 %d 127', $note_to_midi_number{$note});
    } else {
      play_sound_file sprintf('%s/%s', $datadir, $gong_scale{$note}), 50;
    }
  }
}

sub strike_bell ($) {
  my($note) = @_;
  if ($note ne 'r') {
    $note = 'd#5' if !defined $note || !defined $chime_scale{$note};
    if ($method eq METHOD__SYNTH) {
      send_midi_command sprintf('noteon 1 %d 127', $note_to_midi_number{$note});
    } else {
      play_sound_file sprintf('%s/%s', $datadir, $chime_scale{$note}), 100;
    }
  }
}

sub strike_stick () {
  if ($method eq METHOD__SYNTH) {
    send_midi_command sprintf('noteon 2 %d 127', $wood_note);
  } else {
    #play_sound_file sprintf('%s/269735__theriavirra__drumsticks-stagg-maple-sm5a-powerclick-no4a.wav', $datadir), 70;
    play_sound_file sprintf('%s/claves_ff.mp3', $datadir), 90;
  }
}

sub transpose_note ($;$) {
  my($note, $shift) = @_;
  my $it = $midi_number_to_note[$note_to_midi_number{$note} + $shift] if $note ne 'r';
  return defined $it? $it: $note;
}

sub strike_tune (@) {
  my @tune = @_;
  log_debug sprintf "Striking %s", join(' ', map { $_->[0] } @tune) if $debug || $verbose_p;
  for my $spec (@tune) {
    my($note, $time) = @$spec;
    # The gongs have a range of [c4, g5], or [48, 67]; the Westminster chimes require a range of [b3, g#4] or [47, 56]
    # for just the melody, or [e3, g#4], or [40, 56], if we count also the strikes that count the hours
    # If we just deal with the melody, we therefore need to transpose everything up by 1 to 11 semitones
    # (and be content that the hourly strikes will sound a random note); otherwise we need to transpose it up by 8 to 11 semitones.
    # The VCSL chimes have a slightly narrower range of [c4, f5] or [48, 65] so we'll need to transpose it up by 8 to 9 semitones.
    if ($method eq METHOD__SYNTH) {
      send_midi_command sprintf 'noteon 1 %d 127', $note_to_midi_number{$note} if defined $note_to_midi_number{$note};
    } else {
      #strike_gong transpose_note $note, 8;
      strike_bell transpose_note $note, 8;
    }
    no integer;
    Time::HiRes::sleep $time * $beat_length;
  }
}

sub announce_quarter_hour_by_carillon ($) {
  my($quarter) = @_;
  strike_tune @{$melody{$melody}->[$quarter%4]};
}

sub announce_quarter_hour_by_cuckoo ($) {
  my($quarter) = @_;
  if ($quarter == 2) {
    log_debug "Cuckoo announcing quarter $quarter" if $debug || $verbose_p;
    strike_gong 'c#4';
    play_sound_file "$datadir/121203__inchadney__cuckoo.wav", 100, 1.25, 3.05;
  } else {
    log_debug "Cuckoo does not announce quarter $quarter" if $debug || $verbose_p;
  }
}

sub announce_quarter_hour ($) {
  my($quarter) = @_;
  if ($mode eq MODE__CUCKOO) {
    announce_quarter_hour_by_cuckoo($quarter);
  } else {
    announce_quarter_hour_by_carillon($quarter);
  }
}

sub announce_hour_by_carillon ($) {
  my($hour) = @_;
  my @tune = (@$strike) x $hour;
  strike_tune @tune;
}

sub announce_hour_by_cuckoo ($) {
  my($hour) = @_;
  my $f = sub { my($x) = @_; no integer; 1.5 + 1.55*$x };
  log_debug "Cuckoo announcing hour $hour\n" if $debug || $verbose_p;
  play_sound_file "$datadir/121203__inchadney__cuckoo.wav", 100, 1.25, &$f($hour);
  for (my $i = 0; $i < $hour; $i += 1) {
    #strike_gong 'c#4';
    Time::HiRes::sleep(1.5);
  }
}

sub announce_hour ($) {
  my($hour) = @_;
  if ($mode eq MODE__CUCKOO) {
    announce_hour_by_cuckoo($hour);
  } else {
    announce_hour_by_carillon($hour);
  }
}

sub announce_night_watch ($$) {
  my($watch, $subwatch) = @_;
  my($repeats, $pattern) = @{$watch_chime_pattern[$watch - 1]};
  no integer;
  for (my $i = 0, my $sleep = 0; $i < $repeats; $i += 1) {
    log_debug "Striking $pattern" if $debug || $verbose_p;
    for my $length (split(/\s+/, $pattern)) {
      Time::HiRes::sleep($sleep * $beat_length);
      if ($length eq '.') {
	strike_stick;
	$sleep = SHORT_STRIKE;
      } else {
	strike_gong;
	$sleep = LONG_STRIKE;
      }
    }
    $sleep += GAP;
  }
}

sub do_event ($) {
  my($id) = @_;
  my $output = get_cache_pathname_for_event($id);
  if ($method eq METHOD__SYNTH && -f $output) {
    play_sound_file $output, 100;
  } elsif ($id =~ /^q(\d+)$/) {		# quarter hour chime
    announce_quarter_hour $1;
  } elsif ($id =~ /^h(\d+)$/) {		# hourly chime
    announce_hour $1;
  } elsif ($id =~ /^w(\d+)\.(\d+)$/) {	# night watch
    announce_night_watch $1, $2;
  } else {
    log_warning "Unknown event $id ignored";
  }
}

sub restart_script_real () {	# NOTE: this function exists only to silence the "Statement unlikely to be reached" warning
  for my $pid (keys %children) {
    log_comment "DEBUG: killing synth $pid" if $debug;
    kill 'TERM', $pid;
  }
  my @cmd = @restart_cmd;
  log_warning 'restarting: '. join(' ', @cmd) if $verbose_p || $debug;
  exec { $cmd[0] } @cmd;
}

sub restart_script () {
  restart_script_real;
  log_warning "restart failed: $!";
}

sub safe_to_restart_p () {
  my @cmd = ('perl', '-cw', $restart_cmd[0]);
  log_comment 'DEBUG: running: '. join(' ', @cmd) if $debug;
  local $SIG{'CHLD'} = 'DEFAULT'; # need this to check exit status
  return 0 == system { $cmd[0] } @cmd;
}

sub usage (;$) {
  my($st) = @_;
  my $h = $st? *STDERR: *STDOUT;
  print $h <<EOF;
Usage: $0 [OPTION]...
Chime on the quarter hour and on the start of every fifth of a night watch.

  -d, --sink SINK             Use the specified SINK for audio
      --nonproportional-watches (NOT IMPLEMENTED)
                              Use watches that are aligned to duodecimal hours
  -Q, --qing                  Same as --nonproportional-watches --qing-quarters
      --qing-quarters         Use the Qing quarters system (identical to modern
                              quarters) instead of the ancient centiday system
  -v, --verbose               Explain what is being done
      --help                  Display this help and exit
EOF
  print $h <<EOF unless $debug;
                              (--debug --help to show debugging options)
EOF
  print $h <<EOF if $debug;

Options for debugging:

      --debug                 Produce debugging output
      --test                  Continue with test parameters
      --test-hour HOUR        Play hourly chime for HOUR (1..12)
      --test-quarter QUARTER  Play quarter chime for QUARTER (0..3)
      --test-tune             Play the major scale from c4 to c5, if possible
      --test-watch WATCH      Play night watch chime for WATCH (1..5)
EOF
  print $h <<EOF;

Night watches are determined according to the proportional decimal time
system in use c. 7-2 century BC in ancient China. For details please see
https://github.com/acli/new_clock/blob/master/doc/Night_watches.md
EOF
  exit $st;
}

###############################################################################
# BEGIN test cases
{ no integer;
for my $test ([1,	'1',		1],
	      [1,	'2',		0],
	      [1,	'1-2',		1],
	      [1,	'2, 1',		1],
	      [2,	'1-2',		1],
	      [2,	'1-3',		1],
	      [2.5,	'1-2',		0],
	      [2.5,	'1-3',		1],
	      [5,	'1, 3-8, 10',	1]) {
  my($n, $range_spec, $expected_result) = @$test;
  my $actual_result = in_range($n, $range_spec);
  die "in_range($n, \"$range_spec\"): test failed: expected $expected_result but got $actual_result\n" unless $expected_result == $actual_result;
}
for my $test (['Sunday',		0],
	      ['Monday',		1],
	      ['Tuesday',		2],
	      ['Wednesday',		3],
	      ['Thursday',		4],
	      ['Friday',		5],
	      ['Saturday',		6],
	      ['Sun',			0],
	      ['Mon',			1],
	      ['Tue',			2],
	      ['Tues',			2],
	      ['Wed',			3],
	      ['Thu',			4],
	      ['Thur',			4],
	      ['Thurs',			4],
	      ['Fri',			5],
	      ['Sat',			6],
	      ['Sun',			0],
	      ['M',			1],
	      ['T',			2],
	      ['W',			3],
	      ['R',			4],
	      ['F',			5],
	      ['S',			6],
	      ['someday',		undef]) {
  my($s, $expected_result) = @$test;
  my $actual_result = parse_dow($s);
  die "parse_dow(\"$s\"): test failed: expected $expected_result but got $actual_result\n" unless $expected_result == $actual_result;
  # dow_re
  ($expected_result, $actual_result) = (defined $expected_result, $s =~ /^$dow_re$/);
  die "\"$s\" =~ /\$dow_re/: test failed: expected $expected_result but got $actual_result\n" unless $expected_result == $actual_result;
  # dow_range_re
  ($expected_result, $actual_result) = ($expected_result, $s =~ /^$dow_range_re$/);
  die "\"$s\" =~ /\$dow_range_re/: test failed: expected $expected_result but got $actual_result\n" unless $expected_result == $actual_result;
}
for my $test (['Thursday',		'4'],
	      ['M-R',			'1-4'],
	      ['Tues-Wed',		'2-3'],
	      ['Mon,Tues-Wed',		'1,2-3'],
	      ['Fri-Sun',		'5-6,0'],
	      ['Fri-Tue',		'5-6,0-2'],
	      ['TRF',			'2,4,5'],
	      ['someday',		'ERROR']) {
  my($s, $expected_result) = @$test;
  my $actual_result = parse_dow_range($s);
  die "parse_dow_range(\"$s\"): test failed: expected $expected_result but got $actual_result\n" unless $expected_result eq $actual_result;
  # dow_range_re
  ($expected_result, $actual_result) = (defined $expected_result && $expected_result ne 'ERROR', $s =~ /^$dow_range_re$/);
  die "\"$s\" =~ /\$dow_range_re/: test failed: expected $expected_result but got $actual_result\n" unless $expected_result == $actual_result;
}
for my $test (['A',		6],
	      ['B',		7],
	      ['E',		10],
	      ['morning',	1],
	      ['midday',	3],
	      ['evening',	5]) {
  my($name, $expected_result) = @$test;
  my $actual_result = parse_named_deciday($name);
  die "parse_named_deciday(\"$name\"): test failed: expected $expected_result but got $actual_result\n" unless $expected_result == $actual_result;
}
for my $test (['00:00',		0.0],
	      ['07:30',		7.5],
	      ['19:15',		19.25],
	      ['24:00',		24.0]) {
  my($name, $expected_result) = @$test;
  my $actual_result = parse_clocktime($name);
  die "parse_clocktime(\"$name\"): test failed: expected $expected_result but got $actual_result\n" unless $expected_result == $actual_result;
}
for my $test (['00:00',		'0'],
	      ['12:00-12:30',	'12-12.5'],
	      ['12:00-00:00',	'12-24'],
	      ['23:00-7:00',	'23-24,0-7']) {
  my($s, $expected_result) = @$test;
  my $actual_result = parse_clocktime_range($s);
  die "parse_clocktime_range(\"$s\"): test failed: expected $expected_result but got $actual_result\n" unless $expected_result eq $actual_result;
}
for my $test (['morning',		'1'],
	      ['morning-evening',	'1-5'],
	      ['evening-B',		'5-7'],
	      ['midday,A',		'3,6'],
	      ['C-morning',		'8-10,1']) {
  my($s, $expected_result) = @$test;
  my $actual_result = parse_named_deciday_range($s);
  die "parse_named_deciday_range(\"$s\"): test failed: expected $expected_result but got $actual_result\n" unless $expected_result eq $actual_result;
}
for my $test (['Thursday hour 19.75-22: 0.25',	21, 30,  0, 6.66, 0, undef, undef],
	      ['Thursday 19:45-22:00: 0.25',	21, 30,  0, 6.66, 0, undef, undef],
	      ['morning: 0.5',			17, 53, 36, 5.14, 0, undef, undef],
	      ['E-evening: 0.75',		17, 53,  0, 5.14, 0, 0.75,  undef],
	      ['3:00-9:00: 0.6',		14, 0,   0, 3.76, 2, undef, undef],	# actual failure on 20210817
	      ['Tue,Fri-Sat,Sun 19:31-20:30: 0.5',21, 0, 0, 6.37, 2, undef, undef],	# actual failure on 20210817
	      ['A: 0.5',			21, 30,  0, 6.66, 0, 0.5,   undef],
	      ['0.5',                           12, 30,  0, 3.20, 0, 0.5,   undef]) {
  my($directive, $hour, $min, $sec, $deciday, $wday, $expected_result1, $expected_result2) = @$test;
  my($actual_result1, $actual_result2) = determine_volume_from_directive_and_time($directive, $hour, $min, $sec, $deciday, $wday);
  die "determine_volume_from_directive_and_time(\"$directive\", $hour, $min, $sec, $deciday, $wday): test failed: expected ($expected_result1, $expected_result2) but got ($actual_result1, $actual_result2)\n" unless $expected_result1 == $actual_result1 && $expected_result2 eq $actual_result2;
}
for my $test ([q(\relative c' {c d e}),		1,	'c4 1 d4 1 e4 1'],
	      [q(\relative c' {ces c cis}),	2,	'b3 2 c4 2 c#4 2'],
	      [q(\relative c'' {e dis a gis}),	1,	'e5 1 d#5 1 a4 1 g#4 1'],
	      [q(\relative e { fis4 }),		1,	'f#3 1'],
	      [q(\relative e { fis4. }),	1,	'f#3 1.5'],
	      [q(\relative e { fis4.. }),	1,	'f#3 1.75'],
	      [q(\relative e { fis4.. e e4 }),	1,	'f#3 1.75 e3 1.75 e3 1'],
	      [q(\relative e { r1 }),		1,	'r 4']) {
  my($lilypond_code, $beat_length, $stringified_expected_result) = @$test;
  my $actual_result = interpret_melody($lilypond_code, $beat_length);
  my $stringified_actual_result = ref $actual_result? join(' ', map { @$_ } @$actual_result): defined $actual_result? $actual_result: 'undef';
  die "interpret_melody(\"$lilypond_code\", $beat_length): test failed: expected ($stringified_expected_result) but got ($stringified_actual_result)\n" unless $stringified_expected_result eq $stringified_actual_result;
}
}
# END test cases
###############################################################################

binmode STDIN, ':utf8';
binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';

select((select(STDERR), $| = 1)[0]); # I don't know why this is needed for STDERR

# SIGCHLD handler must be IGNORE, otherwise Time::HiRes::sleep will fail randomly
$SIG{CHLD} = 'IGNORE';

# Handle config file
$config = read_ini("$ENV{HOME}/.chimerrc");
@sinks = @{$config->{'/'}->{'sink'}} if defined $config->{'/'}->{'sink'};
$method = $config->{'/'}->{'method'}->[0] if defined $config->{'/'}->{'method'};
$melody = lc $config->{'/'}->{'melody'}->[0] if defined $config->{'/'}->{'melody'};
$coords = {'lon' => $config->{'/'}->{'longitude'}->[0], 'lat' => $config->{'/'}->{'latitude'}->[0]}
    if defined $config->{'/'}->{'longitude'} && defined $config->{'/'}->{'latitude'};
die "Melody \"$melody\" is not known\n" unless defined $melody{$melody};

# Guess location if not specified in config file
$coords = guess_coordinates unless defined $coords;
($lat, $lon) = ($coords->{'lat'}, $coords->{'lon'}) unless defined $lat;
die "$0: Can't determine coordinates\n" unless defined $coords;

# Check command-line arguments
if (!caller) {
  Getopt::Long::config('bundling');
  GetOptions(
    'D|debug' => sub { $debug += 1; },
    'd|sink=s' => sub { @sinks = $_[1]; },
    'enable-nonproportional-watches|nonproportional-watches' => \$enable_nonproportional_watches,
    'enable-qing-quarters|qing-quarters' => \$enable_qing_quarters,
    'Q|qing' => sub { ($enable_nonproportional_watches, $enable_qing_quarters) = (1, 1); },
    'test' => sub { set_test_params },
    'test-tune' => sub { set_test_params; exit strike_tune(map {[$_, 1]} @midi_number_to_note[48, 50, 52, 53, 55, 57, 59, 60]) },
    'test-hour=i' => sub { set_test_params; exit announce_hour(($_[1] - 1) % 12 + 1) },
    'test-quarter=i' => sub { set_test_params; exit announce_quarter_hour($_[1] % 4) },
    'test-watch=i' => sub { set_test_params; exit announce_night_watch(($_[1] - 1) % 5 + 1, 1) },
    'v|verbose' => \$verbose_p,
    'help' => \&usage,
  ) || usage(1);

  log_info sprintf "chimer booted at %.2f in %s mode%s using %s", $boottime, $mode, ($mode eq MODE__CARILLON? " (using $melody melody)": ''), $method if $verbose_p || $debug;
  generate_sound_clips if $method eq METHOD__SYNTH;
  for (my $countdown = COUNTDOWN, my %pending_events, my %completed_events;;) {
    my $t0 = Time::HiRes::time;
    my $c = determine_chinese_time $t0;
    ($_, $_, $_, $_, my $chinese_hour, my $quarter, my $centiday, my $deciday, $_, $_, my $deciday_size) = @$c;
    (my $sec, my $min, my $hour, $_, $_, $_, my $wday) = localtime $t0;

    # Detect terminated child processes
    for my $pid (keys %children) {
      if (!kill 0, $pid || waitpid($pid, WNOHANG) == $pid) {
	log_debug "child process $pid has exited" if $debug;
	delete $children{$pid};
      }
    }

    # Determine what should happen next
    no integer;
    my @event = determine_events($t0, $hour, $min, $sec, $chinese_hour, $quarter, $centiday, $deciday, $deciday_size);
    my $next_event;
    for my $event (@event) {
      # Don't trust floating point calculations - don't use t as key, use id instead
      $pending_events{+$event->{'id'}} = $event;
    }
    for my $id (keys %pending_events) {
      my $e = $pending_events{$id};
      my $t = $e->{'t'};
      $t += $e->{'delay'} if defined $e->{'delay'};
      if ($t0 - $t > 60) { # just do it if we missed it by just a fraction of a second, actually it's fine even if it's a whole minute
	log_info sprintf "EVENT %s (%d) MISSED at %d (%.2f too late)", $id, $t, $t0, $t0 - $t;
	delete $pending_events{$id};
      }
    }
    # reconstitute the @event array
    @event = sort { $a->{'t'} + $a->{'delay'} <=> $b->{'t'} + $b->{'delay'} } map { $pending_events{$_} } keys %pending_events;

    # Determine when we should wake up; try to make some effort to align it to a second boundary
    my $t1 = Time::HiRes::time;
    my $dt0 = $event[0]->{'t'} - $t1;
    my $t_next = ($countdown && $dt0 > 1)? (int($t0) + 1): ($t1 + $dt0/2);
    my $dt = $t_next - $t1;
    $dt = 0 if $dt < 0;

    # Debug message
    log_comment sprintf "%10.2f=%02d %2.2f/%2.2f/%2.2f (Δt=%2.2f) > %s",
	$t0, $chinese_hour, $quarter, $centiday, $deciday, $dt,
	join(', ', map { sprintf '%.2f (%+.1f) %s', $_->{'t'}, ($_->{'t'} - $t0), $_->{'id'} } @event) if $verbose_p;

    my $t2 = Time::HiRes::time;
    Time::HiRes::sleep $dt;

    # Check if any event should be fired
    my $now = Time::HiRes::time;
    my $dt_actual = $now - $t2;
    log_warning sprintf "tried to sleep for %.2f s but slept for %.2f s\n", $dt, $dt_actual if $dt_actual > $dt + 1;
    for my $id (keys %pending_events) {
      my $e = $pending_events{$id};
      my $t = $e->{'t'};
      $t += $e->{'delay'} if defined $e->{'delay'};
      if ($now < $t) {
	;
      } elsif (defined $completed_events{$id} && $now - $completed_events{$id} < 15) { # This should never happen (but it does)
	log_error sprintf "EVENT %s (%.2f) already fired at %.2f (%.2f s ago)\n", $id, $t, $completed_events{$id}, $now - $completed_events{$id} if $debug;
	delete $pending_events{$id};
      } else {
	my $dt = $now - $t;
	log_info sprintf "EVENT %s (%.2f) fired at %.2f (%s)\n", $id, $t, $now, ($dt < 0.01? 'on time': sprintf('%.2f s late', $dt));
	set_sink_volumes($hour, $min, $sec, $deciday, $wday);
	do_event $id;
	$countdown = 0; # force a re-countdown
	$completed_events{$id} = $now;
	delete $pending_events{$id};
      }
    }

    $countdown -= 1;
    $countdown = COUNTDOWN if $countdown < 0;
  }
}

=pod

=head1 HISTORY

Concept from the Javascript chiming clocks:
"Copyright © 2018 by Ambrose Li :-)"

Mostly based on the genmon script for Chinese/Hebrew dates:
"Copyright 2016-2018, 2021 by Ambrose Li <ambrose.li@gmail.com>
The primary purpose of this script is to figure out the year number in the Chinese system
so that I can name my CV's without having to look up two web pages.
Everything else is just for kicks =P"

=cut

1;
