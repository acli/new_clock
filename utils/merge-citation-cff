#!/usr/bin/perl
# vi:set sw=2 ai sm:
# short script to pull references from doc/CREDITS.md and stash them into CITATION.cff

# see https://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default for these crazy hacks
# THERE ARE MORE CRAZY HACKS THERE FOR MORE COMPLEX PROJECTS!!
use v5.12; # minimal for unicode string feature
use v5.14; # //u modifier
use utf8;
open qw( :encoding(UTF-8) :std );
use charnames qw( :full :short );
use feature "unicode_strings";

use warnings qw( FATAL utf8 );
use Encode qw( encode decode );
#@ARGV = map { decode("UTF-8", $_) } @ARGV if grep /\P{ASCII}/ => @ARGV;

use strict;
use integer;

use POSIX;
use POSIX ":sys_wait_h"; # for nonblocking read
use DateTime;
use Data::Dumper;

binmode STDIN, ':utf8';
binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';

select((select(STDERR), $| = 1)[0]); # I don't know why this is needed for STDERR

# End of boilerplate


# DSM states for credits file scanning
sub STATE__INITIAL               () { 'INITIAL' }
sub STATE__CITATION              () { 'CITATION' }
sub STATE__ANNOTATION_OR_UNKNOWN () { 'ANNOTATION_OR_UNKNOWN' }
sub STATE__ANNOTATION            () { 'ANNOTATION' }
sub STATE__UNKNOWN               () { 'UNKNOWN' }


# hack in trying to make GitHub happy. error messages are garbage, docs are unclear, official tools don't work, we're left guessing what's wrong
sub quotable ($) {
  my($s) = @_;
  return ($s =~ /\s/s || $s =~ /^https?:\/\//)? "\"$s\"": $s;
}


# apparently the docs are very out of date. see https://github.com/citation-file-format/citation-file-format/blob/main/schema.json
use vars qw( %apa_type_to_cff_type );
%apa_type_to_cff_type = (
  'Audio file' => 'sound-recording',
  'Dataset' => 'data',
  'Data set' => 'data', # typo
);

sub convert_apa_type_to_cff_type ($) {
  my($s) = @_;
  if (!defined $apa_type_to_cff_type{$s}) {
    printf STDERR "$0: Warning: Type \"%s\" cannot be converted and has been thrown away\n", $s;
    undef $s;
  }
  return defined $s? $apa_type_to_cff_type{$s}: undef;
}


use vars qw( %months );
%months = (
  'January' => 1,
  'February' => 2,
  'March' => 3,
  'April' => 4,
  'May' => 5,
  'June' => 6,
  'July' => 7,
  'August' => 8,
  'September' => 9,
  'October' => 10,
  'November' => 11,
  'December' => 12,
);

sub parse_date ($) {
  my($s) = @_;
  return sprintf('%04d-%02d-%02d', $3, $months{$1}, $2) if $s =~ /^([A-Z][a-z]+) (\d+), (\d{4})$/;
}


sub format_list (@) {
  my @s = @_;
  return @s < 3? join(' and ', @s): sprintf('%s, and %s', join(', ', @s[0..$#s - 1]), $_[$#s]);
}


use vars qw( $year_re );
$year_re = '\s*\((\d{4,}|n\.d\.)([a-z])?\)\.\s'; # NOTE: 2 captures


# Scan for citations in credits file
# This is just a quick-and-dirty hack -- it will have LOTS OF BUGS
sub scan_for_citations ($) {
  my($files) = @_;
  my @citations;
  for my $credits_input (@$files) {
    open(INPUT, '<:utf8', $credits_input) or die "$0: $credits_input: $!\n";
    for (my $state = STATE__INITIAL;;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      if ($state eq STATE__INITIAL || $state eq STATE__UNKNOWN) {
	if ($s =~ /$year_re/s) { # looks like a citation?
	  push @citations, $s;
	  $state = STATE__CITATION;
	}
      } elsif ($state eq STATE__CITATION) {
	if ($s =~ /^\s*-/s || $s =~ /^\s*$/s) {
	  $state = STATE__UNKNOWN;
	} else {
	  $citations[$#citations] .= $s;
	}
      } else {
	die "$0: INTERNAL ERROR: Reached unknown state $state";
      }
    }
    close INPUT;
  }
  return @citations;
}


# Analyze our citations
sub analyze_citations (@) {
  my(@citations) = @_;
  for (my $i = 0; $i < @citations; $i += 1) {
    my $s = $citations[$i];
    my $node;
    $s =~ s/\s+$//;
    $s =~ s/\s+/ /g;

    # Hack off the retrieval URL first since that's the easiest step
    if ($s =~ s/(?<=\.)\s(?:(doi:\S+)|(?:(?:Available at|Retrieved from)|(\w[\w\s]+\w) (?:available at|retrieved from)) (\S+))$//s) {
      my($doi, $thing, $url) = ($1, $2, $3);
      $node->{'url'} = defined $doi? $doi: $url;
    } elsif ($s =~ s/(?<=\.)\s(?:(?:Retrieved ([A-Z][a-z]+ \d+, \d{4}), from)|(\w[\w\s]+\w) retrieved ([A-Z][a-z]+ \d+, \d{4}), from) (\S+)$//s) {
      my($retrieval_date_1, $thing, $retrieval_date_2, $url) = ($1, $2, $3, $4);
      $node->{'date-accessed'} = parse_date(defined $retrieval_date_1? $retrieval_date_1: $retrieval_date_2);
      $node->{'url'} = $url;
    }

    # Does it look like we have an author? sigh.
    my $possible_author_list;
    if ($s =~ s/^((?:(?!$year_re).)*\.(?:<\/span>)?(?:\]\([^\(\)]+\))?) (?=$year_re)//s) {
      ($possible_author_list, my $author_type) = ($1);
      ($possible_author_list, $author_type) = ($1, $2) if $possible_author_list =~ /^(.*?), (ed\.)$/;
      my @people;
      for (my $i = 0; substr($possible_author_list, $i) =~ /\S/s;) {
	my $s = substr($possible_author_list, $i);
	my($possible_name, $url, $last_name, $given_names, $initials, $single_name, $node);
	if ($s =~ /^\[(.*?)\]\((.*?)\)(?:,|$)/s) {
	  ($possible_name, $url) = ($1, $2);
	} elsif ($s =~ /^\[(.*?)\]\((.*?)\)\.(?:,|$)/s) { # certainly a handle/team name/company name?
	  ($possible_name, $url) = ($1, $2);
	} else {
	  $possible_name = $s;
	}
	if ($possible_name =~ /^(.*?), <span title="([^""]+)">((?:\w\.(?:-\w\.)*\s*)+)<\/span>$/) {
	  ($last_name, $given_names, $initials) = ($1, $2, $3);
	} elsif ($possible_name =~ /^(.*?), <span title=([^""<>]+)>((?:\w\.(?:-\w\.)*\s*)+)<\/span>$/) {
	  ($last_name, $given_names, $initials) = ($1, $2, $3);
	} elsif ($possible_name =~ /^(.*?), ((?:.\.\s*)+)$/) {
	  ($last_name, $initials) = ($1, $2);
	} elsif ($possible_name =~ /^\S+$/) {
	  $single_name = $possible_name;
	} else {
      last if !@people; # not an author list, possibly an article name with no author
	  die "Can't figure out \"$s\"\n";
	}

	$node->{'family-names'} = $last_name if defined $last_name;
	$node->{'given-names'} = $given_names if defined $given_names;
	$node->{'given-names'} = $initials if defined $initials && !defined $given_names;
	$node->{'name'} = $single_name if defined $single_name;
	$node->{'url'} = $url if defined $url;
	push @people, $node if $node;

	$i += length $s;
	$i += length $& if substr($s, $i) =~ /^,\s*/;
      }
      $node->{'authors'} = [@people] if @people;
    }

    # Does it look like we have a title?
    if (!defined $node->{'authors'} && $s =~ s/^$year_re\s*(In )?<cite>(.*?)<\/cite>\.//s) {
      my($year, $serial, $in_p, $in) = ($1, $2, $3, $4);
      my($title, $translated_title) = ($1, $2) if $possible_author_list =~ /^(.*?)(?: \[(.*?)\])?$/;
      $node->{'year'} = $year unless $year eq 'n.d.';
      if ($in =~ /^Wikipedia$/) {
	$node->{'term'} = $title;
	$node->{'term'} .= " [$translated_title]" if defined $translated_title;
	$node->{'title'} = $in;
	$node->{'type'} = 'encyclopedia';
      } else {
	$node->{'title'} = $title;
	$node->{'title'} .= " [$translated_title]" if defined $translated_title;
	if (defined $in_p && $in_p) {
	  die; # article in a book
	} else {
	  $node->{'journal'} = $in;
	}
      }
    } elsif ($s =~ s/^$year_re\s*(.*?)(?: \[(.*)\])?\.$//s) {
      my($year, $serial, $title, $type) = ($1, $2, $3, $4);
      $node->{'year'} = $year unless $year eq 'n.d.';
      $node->{'title'} = $title;
      $node->{'type'} = convert_apa_type_to_cff_type($type);
    } elsif ($s =~ s/^$year_re\s*(.*?)\s+\[(.*?)\]\. <cite>(.*)<\/cite>, (\d+), (\d+)â€“(\d+)\.\s*//s) {
      my($year, $serial, $title, $translated_title, $journal, $issue, $start, $end) = ($1, $2, $3, $4, $5, $6, $7, $8);
      $node->{'year'} = $year unless $year eq 'n.d.';
      $node->{'title'} = "$title [$translated_title]";
      $node->{'journal'} = $journal;
      $node->{'issue'} = $issue;
      $node->{'start'} = $start;
      $node->{'end'} = $end;
      $node->{'type'} = 'article';
    } else {
    }

    $node->{'unknown'} = $s if $s =~ /\S/s;
    $citations[$i] = $node;
  }
  return @citations;
}


sub emit_file_header () {
  # Do not output BOM (U+feff), GitHub doesn't like it
}


sub emit_file_footer ($$) {
  my($template_input, $credits_input) = @_;
  printf "\n# This file was generated from %s\n", format_list($template_input, @$credits_input);
}


sub copy_template ($) {
  my($template_input) = @_;

  # Copy everything from the cff template
  my %keys_in_template;
  open(INPUT, '<:utf8', $template_input) or die "$0: $template_input: $!\n";
  for (;;) {
    my $s = scalar <INPUT>;
  last unless defined $s;
    $keys_in_template{$1} = 1 if $s =~ /^([^\s:]+):/;
    print $s;
  }
  close INPUT;

  # GitHub doesn't like files that don't have a version key, even though version is optional
  print "version: n/a\n" unless defined $keys_in_template{'version'};
}


sub emit_citations (@) {
  my(@citations) = @_;

  # Add citations
  print "\nreferences:\n" if @citations;
  for my $citation (@citations) {
    my $indent = "\n- ";
    for my $key (sort keys %$citation) {
      if ($key eq 'authors') {
	printf "%s%s:\n", $indent, $key;
	for my $author (@{$citation->{'authors'}}) {
	  my $indent = '  - ';
	  for my $field ('family-names', 'given-names', 'name') {
	    if (defined $author->{$field}) {
	      printf "%s%s: %s\n", $indent, $field, quotable $author->{$field};
	      $indent =~ s/-/ /g;
	    }
	  }
	}
	$indent =~ s/^\n+//g; $indent =~ s/-/ /g;
      } elsif ($key eq 'url') { # if we got a url it needs to be examined more carefully
	my($type, $url) = ($key, $citation->{$key});
	if ($url =~ /^https:\/\/github\.com\//) {
	  $type = 'repository-code';
	} elsif ($url =~ /^https:\/\/freesound\.org\//) {
	  $type = 'repository';
	}
	printf "%s%s: %s\n", $indent, $type, quotable $citation->{$key};
	$indent =~ s/^\n+//g; $indent =~ s/-/ /g;
      } elsif ($key ne 'unknown') {
	printf "%s%s: %s\n", $indent, $key, quotable $citation->{$key};
	$indent =~ s/^\n+//g; $indent =~ s/-/ /g;
      }
    }
  }
}


# main loop starts here
my($template_input, $credits_input);
for my $arg (@ARGV) {
  if ($arg =~ /\.cff.in$/) {
    die "$0: $arg: CFF template already defined\n" if defined $template_input;
    $template_input = $arg;
  } elsif ($arg =~ /\.md$/) {
    push @$credits_input, $arg;
  } else {
    die "$0: $arg: Unknown input\n";
  }
}

my @citations = scan_for_citations($credits_input);
@citations = analyze_citations(@citations);

emit_file_header;

copy_template $template_input;
emit_citations @citations;

emit_file_footer $template_input, $credits_input;
